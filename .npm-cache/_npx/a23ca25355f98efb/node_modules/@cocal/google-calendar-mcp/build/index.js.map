{
  "version": 3,
  "sources": ["../src/auth/paths.js", "../src/auth/utils.ts", "../src/auth/client.ts", "../src/index.ts", "../src/server.ts", "../src/auth/server.ts", "../src/auth/tokenManager.ts", "../src/web/templates.ts", "../src/tools/registry.ts", "../src/utils/field-mask-builder.ts", "../src/handlers/core/BaseToolHandler.ts", "../src/services/CalendarRegistry.ts", "../src/utils/datetime.ts", "../src/types/structured-responses.ts", "../src/utils/response-builder.ts", "../src/handlers/core/ListCalendarsHandler.ts", "../src/handlers/core/BatchRequestHandler.ts", "../src/handlers/core/ListEventsHandler.ts", "../src/handlers/core/SearchEventsHandler.ts", "../src/handlers/core/GetEventHandler.ts", "../src/handlers/core/ListColorsHandler.ts", "../src/utils/event-id-validator.ts", "../src/services/conflict-detection/ConflictDetectionService.ts", "../src/services/conflict-detection/EventSimilarityChecker.ts", "../src/services/conflict-detection/config.ts", "../src/utils/event-url.ts", "../src/handlers/core/CreateEventHandler.ts", "../src/handlers/core/RecurringEventHelpers.ts", "../src/handlers/core/UpdateEventHandler.ts", "../src/handlers/core/DeleteEventHandler.ts", "../src/handlers/core/FreeBusyEventHandler.ts", "../src/handlers/core/GetCurrentTimeHandler.ts", "../src/handlers/core/RespondToEventHandler.ts", "../src/handlers/core/ManageAccountsHandler.ts", "../src/transports/stdio.ts", "../src/transports/http.ts", "../src/config/TransportConfig.ts"],
  "sourcesContent": ["#!/usr/bin/env node\n\n/**\n * Shared path utilities for token management\n * This module provides consistent token path resolution across all scripts\n */\n\nimport path from 'path';\nimport { homedir } from 'os';\n\n/**\n * Get the secure token storage path\n * Priority: GOOGLE_CALENDAR_MCP_TOKEN_PATH > XDG_CONFIG_HOME > ~/.config\n */\nexport function getSecureTokenPath() {\n  // Priority 1: Custom token path from environment variable\n  if (process.env.GOOGLE_CALENDAR_MCP_TOKEN_PATH) {\n    return path.resolve(process.env.GOOGLE_CALENDAR_MCP_TOKEN_PATH);\n  }\n  // Priority 2: XDG Base Directory specification\n  const configDir = process.env.XDG_CONFIG_HOME || path.join(homedir(), '.config');\n  return path.join(configDir, 'google-calendar-mcp', 'tokens.json');\n}\n\n/**\n * Get the legacy token path (for migration purposes)\n */\nexport function getLegacyTokenPath() {\n  return path.join(process.cwd(), '.gcp-saved-tokens.json');\n}\n\n/**\n * Reserved account names that cannot be used\n */\nconst RESERVED_NAMES = ['.', '..', 'con', 'prn', 'aux', 'nul', 'com1', 'com2', 'com3', 'com4',\n                        'lpt1', 'lpt2', 'lpt3'];\n\n/**\n * Validate account ID format\n * Must be 1-64 characters: lowercase letters, numbers, dashes, underscores only\n * Cannot be reserved names\n */\nexport function validateAccountId(accountId) {\n  if (!accountId || accountId.length === 0) {\n    throw new Error('Invalid account ID. Must be 1-64 characters: lowercase letters, numbers, dashes, underscores only.');\n  }\n\n  // Check reserved names first (before regex, since \".\" and \"..\" won't match regex)\n  if (RESERVED_NAMES.includes(accountId)) {\n    throw new Error(`Account ID \"${accountId}\" is reserved and cannot be used.`);\n  }\n\n  // Check format: lowercase alphanumeric, dashes, underscores, 1-64 chars\n  if (!/^[a-z0-9_-]{1,64}$/.test(accountId)) {\n    throw new Error('Invalid account ID. Must be 1-64 characters: lowercase letters, numbers, dashes, underscores only.');\n  }\n\n  return accountId;\n}\n\n/**\n * Get current account mode from environment\n * Uses same logic as utils.ts but compatible with both JS and TS\n */\nexport function getAccountMode() {\n  // If set explicitly via environment variable use that instead\n  const explicitMode = process.env.GOOGLE_ACCOUNT_MODE;\n  if (explicitMode !== undefined && explicitMode !== null) {\n    // Validate the account ID (no lowercasing - must be lowercase already)\n    return validateAccountId(explicitMode);\n  }\n\n  // Auto-detect test environment\n  if (process.env.NODE_ENV === 'test') {\n    return 'test';\n  }\n\n  // Default to normal for regular app usage\n  return 'normal';\n}", "import * as path from 'path';\nimport * as os from 'os';\nimport * as fs from 'fs';\nimport { fileURLToPath } from 'url';\nimport { getSecureTokenPath as getSharedSecureTokenPath, getLegacyTokenPath as getSharedLegacyTokenPath, getAccountMode as getSharedAccountMode } from './paths.js';\n\n// Helper to get the project root directory reliably\nfunction getProjectRoot(): string {\n  const __dirname = path.dirname(fileURLToPath(import.meta.url));\n  // In build output (e.g., build/bundle.js), __dirname is .../build\n  // Go up ONE level to get the project root\n  const projectRoot = path.join(__dirname, \"..\"); // Corrected: Go up ONE level\n  return path.resolve(projectRoot); // Ensure absolute path\n}\n\n// Get the current account mode - delegates to shared implementation\n// Now supports arbitrary account IDs instead of just 'normal' and 'test'\nexport function getAccountMode(): string {\n  return getSharedAccountMode();\n}\n\n// Helper to detect if we're running in a test environment\nfunction isRunningInTestEnvironment(): boolean {\n  // Simple and reliable: just check NODE_ENV\n  return process.env.NODE_ENV === 'test';\n}\n\n// Returns the absolute path for the saved token file - delegates to shared implementation\nexport function getSecureTokenPath(): string {\n  return getSharedSecureTokenPath();\n}\n\n// Returns the legacy token path for backward compatibility - delegates to shared implementation  \nexport function getLegacyTokenPath(): string {\n  return getSharedLegacyTokenPath();\n}\n\n// Returns the absolute path for the GCP OAuth keys file with priority:\n// 1. Environment variable GOOGLE_OAUTH_CREDENTIALS (highest priority)\n// 2. Default file path (lowest priority)\nexport function getKeysFilePath(): string {\n  // Priority 1: Environment variable\n  const envCredentialsPath = process.env.GOOGLE_OAUTH_CREDENTIALS;\n  if (envCredentialsPath) {\n    return path.resolve(envCredentialsPath);\n  }\n  \n  // Priority 2: Default file path\n  const projectRoot = getProjectRoot();\n  const keysPath = path.join(projectRoot, \"gcp-oauth.keys.json\");\n  return keysPath; // Already absolute from getProjectRoot\n}\n\n// Helper to determine if we're currently in test mode\nexport function isTestMode(): boolean {\n  return getAccountMode() === 'test';\n}\n\n// Interface for OAuth credentials\nexport interface OAuthCredentials {\n  client_id: string;\n  client_secret: string;\n  redirect_uris: string[];\n}\n\n// Interface for credentials file with project_id\nexport interface OAuthCredentialsWithProject {\n  installed?: {\n    project_id?: string;\n    client_id?: string;\n    client_secret?: string;\n    redirect_uris?: string[];\n  };\n  project_id?: string;\n  client_id?: string;\n  client_secret?: string;\n  redirect_uris?: string[];\n}\n\n// Get project ID from OAuth credentials file\n// Returns undefined if credentials file doesn't exist, is invalid, or missing project_id\nexport function getCredentialsProjectId(): string | undefined {\n  try {\n    // Use existing helper to get credentials file path\n    const credentialsPath = getKeysFilePath();\n\n    if (!fs.existsSync(credentialsPath)) {\n      return undefined;\n    }\n\n    const credentialsContent = fs.readFileSync(credentialsPath, 'utf-8');\n    const credentials: OAuthCredentialsWithProject = JSON.parse(credentialsContent);\n\n    // Extract project_id from installed format or direct format\n    if (credentials.installed?.project_id) {\n      return credentials.installed.project_id;\n    } else if (credentials.project_id) {\n      return credentials.project_id;\n    }\n\n    return undefined;\n  } catch (error) {\n    // If we can't read project ID, return undefined (backward compatibility)\n    return undefined;\n  }\n}\n\n// Generate helpful error message for missing credentials\nexport function generateCredentialsErrorMessage(): string {\n  return `\nOAuth credentials not found. Please provide credentials using one of these methods:\n\n1. Environment variable:\n   Set GOOGLE_OAUTH_CREDENTIALS to the path of your credentials file:\n   export GOOGLE_OAUTH_CREDENTIALS=\"/path/to/gcp-oauth.keys.json\"\n\n2. Default file path:\n   Place your gcp-oauth.keys.json file in the package root directory.\n\nToken storage:\n- Tokens are saved to: ${getSecureTokenPath()}\n- To use a custom token location, set GOOGLE_CALENDAR_MCP_TOKEN_PATH environment variable\n\nTo get OAuth credentials:\n1. Go to the Google Cloud Console (https://console.cloud.google.com/)\n2. Create or select a project\n3. Enable the Google Calendar API\n4. Create OAuth 2.0 credentials\n5. Download the credentials file as gcp-oauth.keys.json\n`.trim();\n}\n", "import { OAuth2Client } from 'google-auth-library';\nimport * as fs from 'fs/promises';\nimport { getKeysFilePath, generateCredentialsErrorMessage, OAuthCredentials } from './utils.js';\n\nasync function loadCredentialsFromFile(): Promise<OAuthCredentials> {\n  const keysContent = await fs.readFile(getKeysFilePath(), \"utf-8\");\n  const keys = JSON.parse(keysContent);\n\n  if (keys.installed) {\n    // Standard OAuth credentials file format\n    const { client_id, client_secret, redirect_uris } = keys.installed;\n    return { client_id, client_secret, redirect_uris };\n  } else if (keys.client_id && keys.client_secret) {\n    // Direct format\n    return {\n      client_id: keys.client_id,\n      client_secret: keys.client_secret,\n      redirect_uris: keys.redirect_uris || ['http://localhost:3000/oauth2callback']\n    };\n  } else {\n    throw new Error('Invalid credentials file format. Expected either \"installed\" object or direct client_id/client_secret fields.');\n  }\n}\n\nasync function loadCredentialsWithFallback(): Promise<OAuthCredentials> {\n  // Load credentials from file (CLI param, env var, or default path)\n  try {\n    return await loadCredentialsFromFile();\n  } catch (fileError) {\n    // Generate helpful error message\n    const errorMessage = generateCredentialsErrorMessage();\n    throw new Error(`${errorMessage}\\n\\nOriginal error: ${fileError instanceof Error ? fileError.message : fileError}`);\n  }\n}\n\nexport async function initializeOAuth2Client(): Promise<OAuth2Client> {\n  // Always use real OAuth credentials - no mocking.\n  // Unit tests should mock at the handler level, integration tests need real credentials.\n  try {\n    const credentials = await loadCredentialsWithFallback();\n    \n    // Use the first redirect URI as the default for the base client\n    return new OAuth2Client({\n      clientId: credentials.client_id,\n      clientSecret: credentials.client_secret,\n      redirectUri: credentials.redirect_uris[0],\n    });\n  } catch (error) {\n    throw new Error(`Error loading OAuth keys: ${error instanceof Error ? error.message : error}`);\n  }\n}\n\nexport async function loadCredentials(): Promise<{ client_id: string; client_secret: string }> {\n  try {\n    const credentials = await loadCredentialsWithFallback();\n    \n    if (!credentials.client_id || !credentials.client_secret) {\n        throw new Error('Client ID or Client Secret missing in credentials.');\n    }\n    return {\n      client_id: credentials.client_id,\n      client_secret: credentials.client_secret\n    };\n  } catch (error) {\n    throw new Error(`Error loading credentials: ${error instanceof Error ? error.message : error}`);\n  }\n}", "import { fileURLToPath } from \"url\";\nimport { GoogleCalendarMcpServer } from './server.js';\nimport { parseArgs } from './config/TransportConfig.js';\nimport { readFileSync } from \"fs\";\nimport { join, dirname } from \"path\";\n\n// Import modular components\nimport { initializeOAuth2Client } from './auth/client.js';\nimport { AuthServer } from './auth/server.js';\n\n// Get package version\nconst __filename = fileURLToPath(import.meta.url);\nconst __dirname = dirname(__filename);\nconst packageJsonPath = join(__dirname, '..', 'package.json');\nconst packageJson = JSON.parse(readFileSync(packageJsonPath, 'utf-8'));\nconst VERSION = packageJson.version;\n\n// --- Main Application Logic --- \nasync function main() {\n  try {\n    // Parse command line arguments\n    const config = parseArgs(process.argv.slice(2));\n    \n    // Create and initialize the server\n    const server = new GoogleCalendarMcpServer(config);\n    await server.initialize();\n    \n    // Start the server with the appropriate transport\n    await server.start();\n\n  } catch (error: unknown) {\n    process.stderr.write(`Failed to start server: ${error instanceof Error ? error.message : error}\\n`);\n    process.exit(1);\n  }\n}\n\n\n// --- Command Line Interface ---\nasync function runAuthServer(accountId?: string): Promise<void> {\n  // Set account mode if specified\n  if (accountId) {\n    // Validate account ID format\n    if (!/^[a-z0-9_-]{1,64}$/.test(accountId)) {\n      process.stderr.write('Invalid account ID. Must be 1-64 characters: lowercase letters, numbers, dashes, underscores only.\\n');\n      process.exit(1);\n    }\n    process.env.GOOGLE_ACCOUNT_MODE = accountId;\n    process.stderr.write(`Authenticating account: ${accountId}\\n`);\n  }\n\n  // Use the same logic as auth-server.ts\n  try {\n    // Initialize OAuth client\n    const oauth2Client = await initializeOAuth2Client();\n\n    // Create and start the auth server\n    const authServerInstance = new AuthServer(oauth2Client);\n\n    // Start with browser opening (true by default)\n    const success = await authServerInstance.start(true);\n\n    if (!success && !authServerInstance.authCompletedSuccessfully) {\n      // Failed to start and tokens weren't already valid\n      process.stderr.write(\n        \"Authentication failed. Could not start server or validate existing tokens. Check port availability (3000-3004) and try again.\\n\"\n      );\n      process.exit(1);\n    } else if (authServerInstance.authCompletedSuccessfully) {\n      // Auth was successful (either existing tokens were valid or flow completed just now)\n      process.stderr.write(\"Authentication successful.\\n\");\n      process.exit(0); // Exit cleanly if auth is already done\n    }\n\n    // If we reach here, the server started and is waiting for the browser callback\n    process.stderr.write(\n      \"Authentication server started. Please complete the authentication in your browser...\\n\"\n    );\n\n    // Wait for completion\n    const intervalId = setInterval(async () => {\n      if (authServerInstance.authCompletedSuccessfully) {\n        clearInterval(intervalId);\n        await authServerInstance.stop();\n        process.stderr.write(\"Authentication completed successfully!\\n\");\n        process.exit(0);\n      }\n    }, 1000);\n  } catch (error) {\n    process.stderr.write(`Authentication failed: ${error}\\n`);\n    process.exit(1);\n  }\n}\n\nfunction showHelp(): void {\n  process.stdout.write(`\nGoogle Calendar MCP Server v${VERSION}\n\nUsage:\n  npx @cocal/google-calendar-mcp [command] [options]\n\nCommands:\n  auth [account-id]  Run the authentication flow\n                     Optional account-id for multi-account support (e.g., work, personal)\n  start              Start the MCP server (default)\n  version            Show version information\n  help               Show this help message\n\nOptions:\n  --enable-tools <list>   Comma-separated list of tools to enable (whitelist)\n\nExamples:\n  npx @cocal/google-calendar-mcp auth              # Authenticate default account\n  npx @cocal/google-calendar-mcp auth work         # Authenticate \"work\" account\n  npx @cocal/google-calendar-mcp start\n  npx @cocal/google-calendar-mcp start --enable-tools list-events,create-event,get-current-time\n  npx @cocal/google-calendar-mcp\n\nEnvironment Variables:\n  GOOGLE_OAUTH_CREDENTIALS    Path to OAuth credentials file\n  GOOGLE_ACCOUNT_MODE         Account ID to use (alternative to auth argument)\n  ENABLED_TOOLS               Comma-separated list of tools to enable\n`);\n}\n\nfunction showVersion(): void {\n  process.stdout.write(`Google Calendar MCP Server v${VERSION}\\n`);\n}\n\n// --- Exports & Execution Guard --- \n// Export main for testing or potential programmatic use\nexport { main, runAuthServer };\n\n// Parse CLI arguments\nfunction parseCliArgs(): { command: string | undefined; accountId: string | undefined } {\n  const args = process.argv.slice(2);\n  let command: string | undefined;\n  let accountId: string | undefined;\n\n  for (let i = 0; i < args.length; i++) {\n    const arg = args[i];\n\n    // Handle special version/help flags as commands\n    if (arg === '--version' || arg === '-v' || arg === '--help' || arg === '-h') {\n      command = arg;\n      continue;\n    }\n\n    // Skip transport options and their values\n    if (arg === '--transport' || arg === '--port' || arg === '--host' || arg === '--enable-tools') {\n      i++; // Skip the next argument (the value)\n      continue;\n    }\n\n    // Skip other flags\n    if (arg === '--debug') {\n      continue;\n    }\n\n    // Check for command (first non-option argument)\n    if (!command && !arg.startsWith('--')) {\n      command = arg;\n      continue;\n    }\n\n    // If command is 'auth', capture the next non-option argument as account ID\n    if (command === 'auth' && !accountId && !arg.startsWith('--')) {\n      accountId = arg;\n      continue;\n    }\n  }\n\n  return { command, accountId };\n}\n\n// CLI logic here (run always)\nconst { command, accountId } = parseCliArgs();\n\nswitch (command) {\n  case \"auth\":\n    runAuthServer(accountId).catch((error) => {\n      process.stderr.write(`Authentication failed: ${error}\\n`);\n      process.exit(1);\n    });\n    break;\n  case \"start\":\n  case void 0:\n    main().catch((error) => {\n      process.stderr.write(`Failed to start server: ${error}\\n`);\n      process.exit(1);\n    });\n    break;\n  case \"version\":\n  case \"--version\":\n  case \"-v\":\n    showVersion();\n    break;\n  case \"help\":\n  case \"--help\":\n  case \"-h\":\n    showHelp();\n    break;\n  default:\n    process.stderr.write(`Unknown command: ${command}\\n`);\n    showHelp();\n    process.exit(1);\n}", "import { McpServer } from \"@modelcontextprotocol/sdk/server/mcp.js\";\nimport { McpError, ErrorCode } from \"@modelcontextprotocol/sdk/types.js\";\nimport { OAuth2Client } from \"google-auth-library\";\n\n// Import authentication components\nimport { initializeOAuth2Client } from './auth/client.js';\nimport { AuthServer } from './auth/server.js';\nimport { TokenManager } from './auth/tokenManager.js';\n\n// Import tool registry\nimport { ToolRegistry } from './tools/registry.js';\n\n// Import account management handler\nimport { ManageAccountsHandler, ServerContext } from './handlers/core/ManageAccountsHandler.js';\nimport { z } from 'zod';\n\n// Import transport handlers\nimport { StdioTransportHandler } from './transports/stdio.js';\nimport { HttpTransportHandler, HttpTransportConfig } from './transports/http.js';\n\n// Import config\nimport { ServerConfig } from './config/TransportConfig.js';\n\nexport class GoogleCalendarMcpServer {\n  private server: McpServer;\n  private oauth2Client!: OAuth2Client;\n  private tokenManager!: TokenManager;\n  private authServer!: AuthServer;\n  private config: ServerConfig;\n  private accounts!: Map<string, OAuth2Client>;\n\n  constructor(config: ServerConfig) {\n    this.config = config;\n    this.server = new McpServer({\n      name: \"google-calendar\",\n      version: \"1.3.0\"\n    });\n  }\n\n  async initialize(): Promise<void> {\n    // 1. Initialize Authentication (but don't block on it)\n    this.oauth2Client = await initializeOAuth2Client();\n    this.tokenManager = new TokenManager(this.oauth2Client);\n    this.authServer = new AuthServer(this.oauth2Client);\n\n    // 2. Load all authenticated accounts\n    this.accounts = await this.tokenManager.loadAllAccounts();\n\n    // 3. Handle startup authentication based on transport type\n    await this.handleStartupAuthentication();\n\n    // 4. Set up Modern Tool Definitions\n    this.registerTools();\n\n    // 5. Set up Graceful Shutdown\n    this.setupGracefulShutdown();\n  }\n\n  private async handleStartupAuthentication(): Promise<void> {\n    // Skip authentication in test environment\n    if (process.env.NODE_ENV === 'test') {\n      return;\n    }\n\n    this.accounts = await this.tokenManager.loadAllAccounts();\n    if (this.accounts.size > 0) {\n      const accountList = Array.from(this.accounts.keys()).join(', ');\n      process.stderr.write(`Valid tokens found for account(s): ${accountList}\\n`);\n      return;\n    }\n    \n    const accountMode = this.tokenManager.getAccountMode();\n    \n    if (this.config.transport.type === 'stdio') {\n      // For stdio mode, check for existing tokens\n      const hasValidTokens = await this.tokenManager.validateTokens(accountMode);\n      if (!hasValidTokens) {\n        // No existing tokens - server will start but calendar tools won't work\n        // User can authenticate via the 'add-account' tool\n        process.stderr.write(`\u26A0\uFE0F  No authenticated accounts found.\\n`);\n        process.stderr.write(`Use the 'add-account' tool to authenticate a Google account, or run:\\n`);\n        process.stderr.write(`  npx @cocal/google-calendar-mcp auth\\n\\n`);\n        // Don't exit - allow server to start so add-account tool is available\n      } else {\n        process.stderr.write(`Valid ${accountMode} user tokens found.\\n`);\n        this.accounts = await this.tokenManager.loadAllAccounts();\n      }\n    } else {\n      // For HTTP mode, check for tokens but don't block startup\n      const hasValidTokens = await this.tokenManager.validateTokens(accountMode);\n      if (!hasValidTokens) {\n        process.stderr.write(`\u26A0\uFE0F  No valid ${accountMode} user authentication tokens found.\\n`);\n        process.stderr.write('Visit the server URL in your browser to authenticate, or run \"npm run auth\" separately.\\n');\n      } else {\n        process.stderr.write(`Valid ${accountMode} user tokens found.\\n`);\n        this.accounts = await this.tokenManager.loadAllAccounts();\n      }\n    }\n  }\n\n  private registerTools(): void {\n    ToolRegistry.registerAll(this.server, this.executeWithHandler.bind(this), this.config);\n\n    // Register account management tools separately (they need special context)\n    this.registerAccountManagementTools();\n  }\n\n  /**\n   * Register the manage-accounts tool that needs access to server internals.\n   * This tool is special because it:\n   * - Doesn't require existing authentication (for 'add' action)\n   * - Needs access to authServer, tokenManager, etc.\n   */\n  private registerAccountManagementTools(): void {\n    const serverContext: ServerContext = {\n      oauth2Client: this.oauth2Client,\n      tokenManager: this.tokenManager,\n      authServer: this.authServer,\n      accounts: this.accounts,\n      reloadAccounts: async () => {\n        this.accounts = await this.tokenManager.loadAllAccounts();\n        return this.accounts;\n      }\n    };\n\n    const manageAccountsHandler = new ManageAccountsHandler();\n    this.server.tool(\n      'manage-accounts',\n      \"Manage Google account authentication. Actions: 'list' (show accounts), 'add' (authenticate new account), 'remove' (remove account).\",\n      {\n        action: z.enum(['list', 'add', 'remove'])\n          .describe(\"Action to perform: 'list' shows all accounts, 'add' authenticates a new account, 'remove' removes an account\"),\n        account_id: z.string()\n          .regex(/^[a-z0-9_-]{1,64}$/, \"Account nickname must be 1-64 characters: lowercase letters, numbers, dashes, underscores only\")\n          .optional()\n          .describe(\"Account nickname (e.g., 'work', 'personal') - a friendly name to identify this Google account. Required for 'add' and 'remove'. Optional for 'list' (shows all if omitted)\")\n      },\n      async (args) => {\n        return manageAccountsHandler.runTool(args, serverContext);\n      }\n    );\n  }\n\n  private async ensureAuthenticated(): Promise<void> {\n    const availableAccounts = await this.tokenManager.loadAllAccounts();\n    if (availableAccounts.size > 0) {\n      this.accounts = availableAccounts;\n      return;\n    }\n\n    // Check if we already have valid tokens\n    if (await this.tokenManager.validateTokens()) {\n      const refreshedAccounts = await this.tokenManager.loadAllAccounts();\n      if (refreshedAccounts.size > 0) {\n        this.accounts = refreshedAccounts;\n        return;\n      }\n    }\n\n    // For stdio mode, authentication should have been handled at startup\n    if (this.config.transport.type === 'stdio') {\n      throw new McpError(\n        ErrorCode.InvalidRequest,\n        \"Authentication tokens are no longer valid. Please restart the server to re-authenticate.\"\n      );\n    }\n\n    // For HTTP mode, try to start auth server if not already running\n    try {\n      const authSuccess = await this.authServer.start(false); // openBrowser = false for HTTP mode\n      \n      if (!authSuccess) {\n        throw new McpError(\n          ErrorCode.InvalidRequest,\n          \"Authentication required. Please run 'npm run auth' to authenticate, or visit the auth URL shown in the logs for HTTP mode.\"\n        );\n      }\n    } catch (error) {\n      if (error instanceof McpError) {\n        throw error;\n      }\n      if (error instanceof Error) {\n        throw new McpError(ErrorCode.InvalidRequest, error.message);\n      }\n      throw new McpError(ErrorCode.InvalidRequest, \"Authentication required. Please run 'npm run auth' to authenticate.\");\n    }\n  }\n\n  private async executeWithHandler(handler: any, args: any): Promise<{ content: Array<{ type: \"text\"; text: string }> }> {\n    await this.ensureAuthenticated();\n\n    const result = await handler.runTool(args, this.accounts);\n    return result;\n  }\n\n  async start(): Promise<void> {\n    switch (this.config.transport.type) {\n      case 'stdio':\n        const stdioHandler = new StdioTransportHandler(this.server);\n        await stdioHandler.connect();\n        break;\n        \n      case 'http':\n        const httpConfig: HttpTransportConfig = {\n          port: this.config.transport.port,\n          host: this.config.transport.host\n        };\n        const httpHandler = new HttpTransportHandler(\n          this.server,\n          httpConfig,\n          this.tokenManager\n        );\n        await httpHandler.connect();\n        break;\n        \n      default:\n        throw new Error(`Unsupported transport type: ${this.config.transport.type}`);\n    }\n  }\n\n  private setupGracefulShutdown(): void {\n    const cleanup = async () => {\n      try {\n        if (this.authServer) {\n          await this.authServer.stop();\n        }\n        \n        // McpServer handles transport cleanup automatically\n        this.server.close();\n        \n        process.exit(0);\n      } catch (error: unknown) {\n        process.stderr.write(`Error during cleanup: ${error instanceof Error ? error.message : error}\\n`);\n        process.exit(1);\n      }\n    };\n\n    process.on(\"SIGINT\", cleanup);\n    process.on(\"SIGTERM\", cleanup);\n  }\n\n  // Expose server for testing\n  getServer(): McpServer {\n    return this.server;\n  }\n} \n", "import { OAuth2Client } from 'google-auth-library';\nimport { TokenManager } from './tokenManager.js';\nimport http from 'http';\nimport { URL } from 'url';\nimport open from 'open';\nimport { loadCredentials } from './client.js';\nimport { getAccountMode } from './utils.js';\nimport { renderAuthSuccess, renderAuthError, renderAuthLanding, loadWebFile } from '../web/templates.js';\n\nexport interface StartForMcpToolResult {\n  success: boolean;\n  authUrl?: string;\n  callbackUrl?: string;\n  error?: string;\n}\n\nexport class AuthServer {\n  private baseOAuth2Client: OAuth2Client; // Used by TokenManager for validation/refresh\n  private flowOAuth2Client: OAuth2Client | null = null; // Used specifically for the auth code flow\n  private server: http.Server | null = null;\n  private tokenManager: TokenManager;\n  private portRange: { start: number; end: number };\n  private activeConnections: Set<import('net').Socket> = new Set(); // Track active socket connections\n  public authCompletedSuccessfully = false; // Flag for standalone script\n  private mcpToolTimeout: ReturnType<typeof setTimeout> | null = null; // Timeout for MCP tool auth flow\n  private autoShutdownOnSuccess = false; // Whether to auto-shutdown after successful auth\n\n  constructor(oauth2Client: OAuth2Client) {\n    this.baseOAuth2Client = oauth2Client;\n    this.tokenManager = new TokenManager(oauth2Client);\n    this.portRange = { start: 3500, end: 3505 };\n  }\n\n  /**\n   * Creates the flow-specific OAuth2Client with the correct redirect URI.\n   */\n  private async createFlowOAuth2Client(port: number): Promise<OAuth2Client> {\n    const { client_id, client_secret } = await loadCredentials();\n    return new OAuth2Client(\n      client_id,\n      client_secret,\n      `http://localhost:${port}/oauth2callback`\n    );\n  }\n\n  /**\n   * Generates an OAuth authorization URL with standard settings.\n   */\n  private generateOAuthUrl(client: OAuth2Client): string {\n    return client.generateAuthUrl({\n      access_type: 'offline',\n      scope: ['https://www.googleapis.com/auth/calendar'],\n      prompt: 'consent'\n    });\n  }\n\n  private createServer(): http.Server {\n    const server = http.createServer(async (req, res) => {\n      const url = new URL(req.url || '/', `http://${req.headers.host}`);\n      \n      if (url.pathname === '/styles.css') {\n        // Serve shared CSS\n        const css = await loadWebFile('styles.css');\n        res.writeHead(200, { 'Content-Type': 'text/css; charset=utf-8' });\n        res.end(css);\n\n      } else if (url.pathname === '/') {\n        // Root route - show auth link\n        const clientForUrl = this.flowOAuth2Client || this.baseOAuth2Client;\n        const authUrl = this.generateOAuthUrl(clientForUrl);\n        const accountMode = getAccountMode();\n\n        const landingHtml = await renderAuthLanding({\n          accountId: accountMode,\n          authUrl: authUrl\n        });\n        res.writeHead(200, { 'Content-Type': 'text/html; charset=utf-8' });\n        res.end(landingHtml);\n\n      } else if (url.pathname === '/oauth2callback') {\n        // OAuth callback route\n        const code = url.searchParams.get('code');\n        if (!code) {\n          const errorHtml = await renderAuthError({\n            errorMessage: 'Authorization code missing'\n          });\n          res.writeHead(400, { 'Content-Type': 'text/html; charset=utf-8' });\n          res.end(errorHtml);\n          return;\n        }\n\n        if (!this.flowOAuth2Client) {\n          const errorHtml = await renderAuthError({\n            errorMessage: 'Authentication flow not properly initiated.'\n          });\n          res.writeHead(500, { 'Content-Type': 'text/html; charset=utf-8' });\n          res.end(errorHtml);\n          return;\n        }\n        \n        try {\n          const { tokens } = await this.flowOAuth2Client.getToken(code);\n          await this.tokenManager.saveTokens(tokens);\n          this.authCompletedSuccessfully = true;\n\n          const tokenPath = this.tokenManager.getTokenPath();\n          const accountMode = this.tokenManager.getAccountMode();\n\n          // Auto-shutdown after successful auth if triggered by MCP tool\n          if (this.autoShutdownOnSuccess) {\n            // Clear the timeout since auth succeeded\n            if (this.mcpToolTimeout) {\n              clearTimeout(this.mcpToolTimeout);\n              this.mcpToolTimeout = null;\n            }\n            // Give the browser time to render success page, then shutdown\n            setTimeout(() => {\n              this.stop().catch(() => {});\n            }, 2000);\n          }\n          \n          const successHtml = await renderAuthSuccess({\n            accountId: accountMode,\n            tokenPath: tokenPath\n          });\n          res.writeHead(200, { 'Content-Type': 'text/html; charset=utf-8' });\n          res.end(successHtml);\n        } catch (error: unknown) {\n          this.authCompletedSuccessfully = false;\n          const message = error instanceof Error ? error.message : 'Unknown error';\n          process.stderr.write(`\u2717 Token save failed: ${message}\\n`);\n\n          const errorHtml = await renderAuthError({\n            errorMessage: message\n          });\n          res.writeHead(500, { 'Content-Type': 'text/html; charset=utf-8' });\n          res.end(errorHtml);\n        }\n      } else {\n        // 404 for other routes\n        res.writeHead(404, { 'Content-Type': 'text/plain' });\n        res.end('Not Found');\n      }\n    });\n\n    // Track connections at server level\n    server.on('connection', (socket) => {\n      this.activeConnections.add(socket);\n      socket.on('close', () => {\n        this.activeConnections.delete(socket);\n      });\n    });\n    \n    return server;\n  }\n\n  async start(openBrowser = true): Promise<boolean> {\n    // Add timeout wrapper to prevent hanging\n    return Promise.race([\n      this.startWithTimeout(openBrowser),\n      new Promise<boolean>((_, reject) => {\n        setTimeout(() => reject(new Error('Auth server start timed out after 10 seconds')), 10000);\n      })\n    ]).catch(() => false); // Return false on timeout instead of throwing\n  }\n\n  private async startWithTimeout(openBrowser = true): Promise<boolean> {\n    if (await this.tokenManager.validateTokens()) {\n      this.authCompletedSuccessfully = true;\n      return true;\n    }\n    \n    // Try to start the server and get the port\n    const port = await this.startServerOnAvailablePort();\n    if (port === null) {\n      process.stderr.write(`Could not start auth server on available port. Please check port availability (${this.portRange.start}-${this.portRange.end}) and try again.\\n`);\n\n      this.authCompletedSuccessfully = false;\n      return false;\n    }\n\n    // Successfully started server on `port`. Now create the flow-specific OAuth client.\n    try {\n      this.flowOAuth2Client = await this.createFlowOAuth2Client(port);\n    } catch (error) {\n        // Could not load credentials, cannot proceed with auth flow\n        this.authCompletedSuccessfully = false;\n        await this.stop(); // Stop the server we just started\n        return false;\n    }\n\n    // Generate Auth URL using the newly created flow client\n    const authorizeUrl = this.generateOAuthUrl(this.flowOAuth2Client);\n    \n    // Always show the URL in console for easy access\n    process.stderr.write(`\\n\uD83D\uDD17 Authentication URL: ${authorizeUrl}\\n\\n`);\n    process.stderr.write(`Or visit: http://localhost:${port}\\n\\n`);\n    \n    if (openBrowser) {\n      try {\n        await open(authorizeUrl);\n        process.stderr.write(`Browser opened automatically. If it didn't open, use the URL above.\\n`);\n      } catch (error) {\n        process.stderr.write(`Could not open browser automatically. Please use the URL above.\\n`);\n      }\n    } else {\n      process.stderr.write(`Please visit the URL above to complete authentication.\\n`);\n    }\n\n    return true; // Auth flow initiated\n  }\n\n  private async startServerOnAvailablePort(): Promise<number | null> {\n    for (let port = this.portRange.start; port <= this.portRange.end; port++) {\n      try {\n        await new Promise<void>((resolve, reject) => {\n          const testServer = this.createServer();\n          testServer.listen(port, () => {\n            this.server = testServer; // Assign to class property *only* if successful\n            resolve();\n          });\n          testServer.on('error', (err: NodeJS.ErrnoException) => {\n            if (err.code === 'EADDRINUSE') {\n              // Port is in use, close the test server and reject\n              testServer.close(() => reject(err)); \n            } else {\n              // Other error, reject\n              reject(err);\n            }\n          });\n        });\n        return port; // Port successfully bound\n      } catch (error: unknown) {\n        // Check if it's EADDRINUSE, otherwise rethrow or handle\n        if (!(error instanceof Error && 'code' in error && error.code === 'EADDRINUSE')) {\n            // An unexpected error occurred during server start\n            return null;\n        }\n        // EADDRINUSE occurred, loop continues\n      }\n    }\n    return null; // No port found\n  }\n\n  public getRunningPort(): number | null {\n    if (this.server) {\n      const address = this.server.address();\n      if (typeof address === 'object' && address !== null) {\n        return address.port;\n      }\n    }\n    return null;\n  }\n\n  async stop(): Promise<void> {\n    // Clear any pending MCP tool timeout\n    if (this.mcpToolTimeout) {\n      clearTimeout(this.mcpToolTimeout);\n      this.mcpToolTimeout = null;\n    }\n    this.autoShutdownOnSuccess = false;\n\n    return new Promise((resolve, reject) => {\n      if (this.server) {\n        // Force close all active connections\n        for (const connection of this.activeConnections) {\n          connection.destroy();\n        }\n        this.activeConnections.clear();\n\n        // Add a timeout to force close if server doesn't close gracefully\n        const timeout = setTimeout(() => {\n          process.stderr.write('Server close timeout, forcing exit...\\n');\n          this.server = null;\n          resolve();\n        }, 2000); // 2 second timeout\n\n        this.server.close((err) => {\n          clearTimeout(timeout);\n          if (err) {\n            reject(err);\n          } else {\n            this.server = null;\n            resolve();\n          }\n        });\n      } else {\n        resolve();\n      }\n    });\n  }\n\n  /**\n   * Start the auth server for use by an MCP tool.\n   *\n   * Unlike the regular start() method:\n   * - Does not open the browser automatically\n   * - Returns the auth URL for the MCP tool to return to the user\n   * - Auto-shutdowns after successful auth or timeout (5 minutes)\n   * - Does not validate existing tokens (allows adding new accounts)\n   *\n   * @param accountId - The account ID to authenticate\n   * @returns Result with auth URL on success, or error on failure\n   */\n  async startForMcpTool(accountId: string): Promise<StartForMcpToolResult> {\n    // If server is already running, stop it first\n    if (this.server) {\n      await this.stop();\n    }\n\n    // Set the account mode\n    this.tokenManager.setAccountMode(accountId);\n\n    // Try to start the server and get the port\n    const port = await this.startServerOnAvailablePort();\n    if (port === null) {\n      return {\n        success: false,\n        error: `Could not start auth server. Ports ${this.portRange.start}-${this.portRange.end} may be in use.`\n      };\n    }\n\n    // Create the flow-specific OAuth client\n    try {\n      this.flowOAuth2Client = await this.createFlowOAuth2Client(port);\n    } catch (error) {\n      await this.stop();\n      return {\n        success: false,\n        error: `Failed to load OAuth credentials: ${error instanceof Error ? error.message : 'Unknown error'}`\n      };\n    }\n\n    // Generate Auth URL\n    const authUrl = this.generateOAuthUrl(this.flowOAuth2Client);\n\n    // Enable auto-shutdown on success\n    this.autoShutdownOnSuccess = true;\n    this.authCompletedSuccessfully = false;\n\n    // Set timeout to auto-shutdown if auth not completed (5 minutes)\n    this.mcpToolTimeout = setTimeout(async () => {\n      if (!this.authCompletedSuccessfully) {\n        process.stderr.write(`Auth timeout for account \"${accountId}\" - shutting down auth server\\n`);\n        await this.stop();\n      }\n    }, 5 * 60 * 1000);\n\n    return {\n      success: true,\n      authUrl,\n      callbackUrl: `http://localhost:${port}/oauth2callback`\n    };\n  }\n} ", "import { OAuth2Client, Credentials } from 'google-auth-library';\nimport fs from 'fs/promises';\nimport { getSecureTokenPath, getAccountMode, getLegacyTokenPath } from './utils.js';\nimport { GaxiosError } from 'gaxios';\nimport { mkdir } from 'fs/promises';\nimport { dirname } from 'path';\n\n// Cached calendar info\ninterface CachedCalendar {\n  id: string;\n  summary: string;\n  summaryOverride?: string;\n  accessRole: string;\n  primary: boolean;\n  backgroundColor?: string;\n}\n\n// Extended credentials with cached email and calendars\ninterface CachedCredentials extends Credentials {\n  cached_email?: string;\n  cached_calendars?: CachedCalendar[];\n  calendars_cached_at?: number;\n}\n\n// Interface for multi-account token storage\n// Now supports arbitrary account IDs\ninterface MultiAccountTokens {\n  [accountId: string]: CachedCredentials;\n}\n\nexport class TokenManager {\n  private oauth2Client: OAuth2Client;\n  private tokenPath: string;\n  private accountMode: string;\n  private accounts: Map<string, OAuth2Client> = new Map();\n  private credentials: {\n    clientId: string;\n    clientSecret: string;\n    redirectUri: string;\n  };\n  private writeQueue: Promise<void> = Promise.resolve();\n\n  constructor(oauth2Client: OAuth2Client) {\n    this.oauth2Client = oauth2Client;\n    this.tokenPath = getSecureTokenPath();\n    this.accountMode = getAccountMode();\n\n    // Store credentials to avoid accessing private properties later\n    this.credentials = {\n      clientId: (oauth2Client as any)._clientId,\n      clientSecret: (oauth2Client as any)._clientSecret,\n      redirectUri: (oauth2Client as any)._redirectUri\n    };\n\n    this.setupTokenRefresh();\n  }\n\n  // Method to expose the token path\n  public getTokenPath(): string {\n    return this.tokenPath;\n  }\n\n  // Method to get current account mode\n  public getAccountMode(): string {\n    return this.accountMode;\n  }\n\n  // Method to switch account mode (supports arbitrary account IDs)\n  public setAccountMode(mode: string): void {\n    this.accountMode = mode;\n  }\n\n  private async ensureTokenDirectoryExists(): Promise<void> {\n    try {\n      await mkdir(dirname(this.tokenPath), { recursive: true });\n    } catch (error) {\n      process.stderr.write(`Failed to create token directory: ${error}\\n`);\n    }\n  }\n\n  private isFileNotFoundError(error: unknown): boolean {\n    return error instanceof Error && 'code' in error && (error as any).code === 'ENOENT';\n  }\n\n  private async writeTokenFile(tokens: MultiAccountTokens): Promise<void> {\n    await this.ensureTokenDirectoryExists();\n    await fs.writeFile(this.tokenPath, JSON.stringify(tokens, null, 2), { mode: 0o600 });\n  }\n\n  private async loadMultiAccountTokens(): Promise<MultiAccountTokens> {\n    try {\n      const fileContent = await fs.readFile(this.tokenPath, \"utf-8\");\n      const parsed = JSON.parse(fileContent);\n\n      // Check if this is the old single-account format\n      if (parsed.access_token || parsed.refresh_token) {\n        // Convert old format to new multi-account format\n        const multiAccountTokens: MultiAccountTokens = {\n          normal: parsed\n        };\n        await this.saveMultiAccountTokens(multiAccountTokens);\n        return multiAccountTokens;\n      }\n\n      // Already in multi-account format\n      return parsed as MultiAccountTokens;\n    } catch (error: unknown) {\n      if (this.isFileNotFoundError(error)) {\n        return {};\n      }\n      throw error;\n    }\n  }\n\n  /**\n   * Raw token file read without migration logic.\n   * Used for atomic read-modify-write operations where we need to re-read current state.\n   */\n  private async loadMultiAccountTokensRaw(): Promise<MultiAccountTokens> {\n    try {\n      const fileContent = await fs.readFile(this.tokenPath, \"utf-8\");\n      return JSON.parse(fileContent) as MultiAccountTokens;\n    } catch (error: unknown) {\n      if (this.isFileNotFoundError(error)) {\n        return {};\n      }\n      throw error;\n    }\n  }\n\n  private async saveMultiAccountTokens(multiAccountTokens: MultiAccountTokens): Promise<void> {\n    return this.enqueueTokenWrite(async () => {\n      await this.writeTokenFile(multiAccountTokens);\n    });\n  }\n\n  private enqueueTokenWrite(operation: () => Promise<void>): Promise<void> {\n    const pendingWrite = this.writeQueue\n      .catch(() => undefined)\n      .then(operation);\n\n    this.writeQueue = pendingWrite\n      .catch(error => {\n        process.stderr.write(`Error writing token file: ${error instanceof Error ? error.message : error}\\n`);\n        throw error;\n      })\n      .catch(() => undefined);\n\n    return pendingWrite;\n  }\n\n  private setupTokenRefresh(): void {\n    this.setupTokenRefreshForAccount(this.oauth2Client, this.accountMode);\n  }\n\n  /**\n   * Set up token refresh handler for a specific account\n   * Uses enqueueTokenWrite to prevent race conditions when multiple accounts refresh simultaneously\n   */\n  private setupTokenRefreshForAccount(client: OAuth2Client, accountId: string): void {\n    client.on(\"tokens\", async (newTokens) => {\n      try {\n        // Wrap entire read-modify-write in the queue to prevent race conditions\n        await this.enqueueTokenWrite(async () => {\n          const multiAccountTokens = await this.loadMultiAccountTokens();\n          const currentTokens = multiAccountTokens[accountId] || {};\n\n          const updatedTokens = {\n            ...currentTokens,\n            ...newTokens,\n            refresh_token: newTokens.refresh_token || currentTokens.refresh_token,\n          };\n\n          multiAccountTokens[accountId] = updatedTokens;\n          await this.writeTokenFile(multiAccountTokens);\n        });\n\n        if (process.env.NODE_ENV !== 'test') {\n          process.stderr.write(`Tokens updated and saved for ${accountId} account\\n`);\n        }\n      } catch (error: unknown) {\n        process.stderr.write(\"Error saving updated tokens: \");\n        if (error instanceof Error) {\n          process.stderr.write(error.message);\n        } else if (typeof error === 'string') {\n          process.stderr.write(error);\n        }\n        process.stderr.write(\"\\n\");\n      }\n    });\n  }\n\n  private async migrateLegacyTokens(): Promise<boolean> {\n    const legacyPath = getLegacyTokenPath();\n    try {\n      // Check if legacy tokens exist\n      if (!(await fs.access(legacyPath).then(() => true).catch(() => false))) {\n        return false; // No legacy tokens to migrate\n      }\n\n      // Read legacy tokens\n      const legacyTokens = JSON.parse(await fs.readFile(legacyPath, \"utf-8\"));\n      \n      if (!legacyTokens || typeof legacyTokens !== \"object\") {\n        process.stderr.write(\"Invalid legacy token format, skipping migration\\n\");\n        return false;\n      }\n\n      // Copy to new location (ensures directory exists)\n      await this.writeTokenFile(legacyTokens);\n      \n      process.stderr.write(`Migrated tokens from legacy location: ${legacyPath} to: ${this.tokenPath}\\n`);\n      \n      // Optionally remove legacy file after successful migration\n      try {\n        await fs.unlink(legacyPath);\n        process.stderr.write(\"Removed legacy token file\\n\");\n      } catch (unlinkErr) {\n        process.stderr.write(`Warning: Could not remove legacy token file: ${unlinkErr}\\n`);\n      }\n      \n      return true;\n    } catch (error) {\n      process.stderr.write(`Error migrating legacy tokens: ${error}\\n`);\n      return false;\n    }\n  }\n\n  async loadSavedTokens(): Promise<boolean> {\n    try {\n      await this.ensureTokenDirectoryExists();\n      \n      // Check if current token file exists\n      const tokenExists = await fs.access(this.tokenPath).then(() => true).catch(() => false);\n      \n      // If no current tokens, try to migrate from legacy location\n      if (!tokenExists) {\n        const migrated = await this.migrateLegacyTokens();\n        if (!migrated) {\n          process.stderr.write(`No token file found at: ${this.tokenPath}\\n`);\n          return false;\n        }\n      }\n\n      const multiAccountTokens = await this.loadMultiAccountTokens();\n      const tokens = multiAccountTokens[this.accountMode];\n\n      if (!tokens || typeof tokens !== \"object\") {\n        process.stderr.write(`No tokens found for ${this.accountMode} account in file: ${this.tokenPath}\\n`);\n        return false;\n      }\n\n      this.oauth2Client.setCredentials(tokens);\n      process.stderr.write(`Loaded tokens for ${this.accountMode} account\\n`);\n      return true;\n    } catch (error: unknown) {\n      process.stderr.write(`Error loading tokens for ${this.accountMode} account: `);\n      if (error instanceof Error && 'code' in error && error.code !== 'ENOENT') { \n          try { \n              await fs.unlink(this.tokenPath); \n              process.stderr.write(\"Removed potentially corrupted token file\\n\"); \n            } catch (unlinkErr) { /* ignore */ } \n      }\n      return false;\n    }\n  }\n\n  async refreshTokensIfNeeded(): Promise<boolean> {\n    const expiryDate = this.oauth2Client.credentials.expiry_date;\n    const isExpired = expiryDate\n      ? Date.now() >= expiryDate - 5 * 60 * 1000 // 5 minute buffer\n      : !this.oauth2Client.credentials.access_token; // No token means we need one\n\n    if (isExpired && this.oauth2Client.credentials.refresh_token) {\n      if (process.env.NODE_ENV !== 'test') {\n        process.stderr.write(`Auth token expired or nearing expiry for ${this.accountMode} account, refreshing...\\n`);\n      }\n      try {\n        const response = await this.oauth2Client.refreshAccessToken();\n        const newTokens = response.credentials;\n\n        if (!newTokens.access_token) {\n          throw new Error(\"Received invalid tokens during refresh\");\n        }\n        // The 'tokens' event listener should handle saving\n        this.oauth2Client.setCredentials(newTokens);\n        if (process.env.NODE_ENV !== 'test') {\n          process.stderr.write(`Token refreshed successfully for ${this.accountMode} account\\n`);\n        }\n        return true;\n      } catch (refreshError) {\n        if (refreshError instanceof GaxiosError && refreshError.response?.data?.error === 'invalid_grant') {\n            process.stderr.write(`Error refreshing auth token for ${this.accountMode} account: Invalid grant. Token likely expired or revoked. Please re-authenticate.\\n`);\n            return false; // Indicate failure due to invalid grant\n        } else {\n            // Handle other refresh errors\n            process.stderr.write(`Error refreshing auth token for ${this.accountMode} account: `);\n            if (refreshError instanceof Error) {\n              process.stderr.write(refreshError.message);\n            } else if (typeof refreshError === 'string') {\n              process.stderr.write(refreshError);\n            }\n            process.stderr.write(\"\\n\");\n            return false;\n        }\n      }\n    } else if (!this.oauth2Client.credentials.access_token && !this.oauth2Client.credentials.refresh_token) {\n        process.stderr.write(`No access or refresh token available for ${this.accountMode} account. Please re-authenticate.\\n`);\n        return false;\n    } else {\n        // Token is valid or no refresh token available\n        return true;\n    }\n  }\n\n  async validateTokens(accountMode?: string): Promise<boolean> {\n    // For unit tests that don't need real authentication, they should mock at the handler level\n    // Integration tests always need real tokens\n\n    const modeToValidate = accountMode || this.accountMode;\n    const currentMode = this.accountMode;\n    \n    try {\n      // Temporarily switch to the mode we want to validate if different\n      if (modeToValidate !== currentMode) {\n        this.accountMode = modeToValidate;\n      }\n      \n      if (!this.oauth2Client.credentials || !this.oauth2Client.credentials.access_token) {\n          // Try loading first if no credentials set\n          if (!(await this.loadSavedTokens())) {\n              return false; // No saved tokens to load\n          }\n          // Check again after loading\n          if (!this.oauth2Client.credentials || !this.oauth2Client.credentials.access_token) {\n              return false; // Still no token after loading\n          }\n      }\n      \n      const result = await this.refreshTokensIfNeeded();\n      return result;\n    } finally {\n      // Always restore the original account mode\n      if (modeToValidate !== currentMode) {\n        this.accountMode = currentMode;\n      }\n    }\n  }\n\n  async saveTokens(tokens: Credentials, email?: string): Promise<void> {\n    try {\n        // Wrap entire read-modify-write in the queue to prevent race conditions\n        await this.enqueueTokenWrite(async () => {\n          const multiAccountTokens = await this.loadMultiAccountTokens();\n          const cachedTokens: CachedCredentials = { ...tokens };\n\n          // Cache the email if provided\n          if (email) {\n            cachedTokens.cached_email = email;\n          }\n\n          multiAccountTokens[this.accountMode] = cachedTokens;\n          await this.writeTokenFile(multiAccountTokens);\n        });\n        this.oauth2Client.setCredentials(tokens);\n        process.stderr.write(`Tokens saved successfully for ${this.accountMode} account to: ${this.tokenPath}\\n`);\n    } catch (error: unknown) {\n        process.stderr.write(`Error saving tokens for ${this.accountMode} account: ${error}\\n`);\n        throw error;\n    }\n  }\n\n  async clearTokens(): Promise<void> {\n    try {\n      this.oauth2Client.setCredentials({}); // Clear in memory\n\n      // Wrap entire read-modify-write in the queue to prevent race conditions\n      await this.enqueueTokenWrite(async () => {\n        const multiAccountTokens = await this.loadMultiAccountTokens();\n        delete multiAccountTokens[this.accountMode];\n\n        // If no accounts left, delete the entire file\n        if (Object.keys(multiAccountTokens).length === 0) {\n          await fs.unlink(this.tokenPath);\n          process.stderr.write(`All tokens cleared, file deleted\\n`);\n        } else {\n          await this.writeTokenFile(multiAccountTokens);\n          process.stderr.write(`Tokens cleared for ${this.accountMode} account\\n`);\n        }\n      });\n    } catch (error: unknown) {\n      if (this.isFileNotFoundError(error)) {\n        // File already gone, which is fine\n        process.stderr.write(\"Token file already deleted\\n\");\n      } else {\n        process.stderr.write(`Error clearing tokens for ${this.accountMode} account: ${error}\\n`);\n        // Don't re-throw, clearing is best-effort\n      }\n    }\n  }\n\n  // Method to list available accounts\n  async listAvailableAccounts(): Promise<string[]> {\n    try {\n      const multiAccountTokens = await this.loadMultiAccountTokens();\n      return Object.keys(multiAccountTokens);\n    } catch (error) {\n      return [];\n    }\n  }\n\n  /**\n   * Remove a specific account's tokens from storage.\n   * @param accountId - The account ID to remove\n   * @throws Error if account doesn't exist or removal fails\n   */\n  async removeAccount(accountId: string): Promise<void> {\n    const normalizedId = accountId.toLowerCase();\n\n    await this.enqueueTokenWrite(async () => {\n      const multiAccountTokens = await this.loadMultiAccountTokens();\n\n      if (!multiAccountTokens[normalizedId]) {\n        throw new Error(`Account \"${normalizedId}\" not found`);\n      }\n\n      delete multiAccountTokens[normalizedId];\n\n      // If no accounts left, delete the entire file\n      if (Object.keys(multiAccountTokens).length === 0) {\n        await fs.unlink(this.tokenPath);\n        process.stderr.write(`All tokens cleared, file deleted\\n`);\n      } else {\n        await this.writeTokenFile(multiAccountTokens);\n        process.stderr.write(`Account \"${normalizedId}\" removed successfully\\n`);\n      }\n\n      // Remove from in-memory accounts map if present\n      this.accounts.delete(normalizedId);\n    });\n  }\n\n  // Method to switch to a different account (supports arbitrary account IDs)\n  async switchAccount(newMode: string): Promise<boolean> {\n    this.accountMode = newMode;\n    return this.loadSavedTokens();\n  }\n\n  /**\n   * Load all authenticated accounts from token file\n   * Returns a Map of account ID to OAuth2Client\n   *\n   * Reuses existing OAuth2Client instances to prevent memory leaks\n   * Sets up token refresh handlers for new accounts\n   */\n  async loadAllAccounts(): Promise<Map<string, OAuth2Client>> {\n    try {\n      const multiAccountTokens = await this.loadMultiAccountTokens();\n\n      // Remove accounts that no longer exist in token file\n      for (const accountId of this.accounts.keys()) {\n        if (!multiAccountTokens[accountId]) {\n          const client = this.accounts.get(accountId);\n          if (client) {\n            // Clean up event listeners before removing\n            client.removeAllListeners('tokens');\n          }\n          this.accounts.delete(accountId);\n        }\n      }\n\n      // Add or update accounts\n      for (const [accountId, tokens] of Object.entries(multiAccountTokens)) {\n        // Validate account ID\n        try {\n          const { validateAccountId } = await import('./paths.js') as any;\n          validateAccountId(accountId);\n\n          // Skip invalid token entries\n          if (!tokens || typeof tokens !== 'object' || !tokens.access_token) {\n            continue;\n          }\n\n          // Check if we already have a client for this account (reuse it to prevent memory leak)\n          let client = this.accounts.get(accountId);\n\n          if (!client) {\n            // Create a new OAuth2Client for this account using stored credentials\n            client = new OAuth2Client(\n              this.credentials.clientId,\n              this.credentials.clientSecret,\n              this.credentials.redirectUri\n            );\n\n            // Set up token refresh handler for this new client\n            this.setupTokenRefreshForAccount(client, accountId);\n\n            this.accounts.set(accountId, client);\n          }\n\n          // Update credentials (for both new and existing clients)\n          client.setCredentials(tokens);\n\n        } catch (error) {\n          // Skip invalid account IDs\n          if (process.env.NODE_ENV !== 'test') {\n            process.stderr.write(`Skipping invalid account \"${accountId}\": ${error}\\n`);\n          }\n          continue;\n        }\n      }\n\n      return this.accounts;\n    } catch (error: any) {\n      // Check for file not found error (works with both Error objects and plain objects)\n      if (error && error.code === 'ENOENT') {\n        // No token file exists, return empty map\n        return new Map();\n      }\n      throw error;\n    }\n  }\n\n  /**\n   * Get OAuth2Client for a specific account\n   * @param accountId The account ID to retrieve\n   * @throws Error if account not found or invalid\n   */\n  getClient(accountId: string): OAuth2Client {\n    // Validate account ID first\n    const { validateAccountId } = require('./paths.js');\n    validateAccountId(accountId);\n\n    const client = this.accounts.get(accountId);\n    if (!client) {\n      throw new Error(`Account \"${accountId}\" not found. Please authenticate this account first.`);\n    }\n\n    return client;\n  }\n\n  /**\n   * List all authenticated accounts with their email addresses, status, and calendars\n   * Uses cached data when available to avoid repeated API calls\n   */\n  async listAccounts(): Promise<Array<{\n    id: string;\n    email: string;\n    status: string;\n    calendars: CachedCalendar[];\n  }>> {\n    try {\n      const multiAccountTokens = await this.loadMultiAccountTokens();\n      const accountList: Array<{\n        id: string;\n        email: string;\n        status: string;\n        calendars: CachedCalendar[];\n      }> = [];\n      let tokensUpdated = false;\n\n      // Cache TTL: 5 minutes for calendars\n      const CALENDAR_CACHE_TTL = 5 * 60 * 1000;\n\n      for (const [accountId, tokens] of Object.entries(multiAccountTokens)) {\n        // Skip invalid entries\n        if (!tokens || typeof tokens !== 'object') {\n          continue;\n        }\n\n        let client: OAuth2Client | null = null;\n\n        // Create client and refresh if needed\n        if (tokens.access_token || tokens.refresh_token) {\n          try {\n            client = new OAuth2Client(\n              this.credentials.clientId,\n              this.credentials.clientSecret,\n              this.credentials.redirectUri\n            );\n            client.setCredentials(tokens);\n\n            // Try to refresh token if access token is expired or missing\n            if (tokens.refresh_token && (!tokens.access_token || (tokens.expiry_date && tokens.expiry_date < Date.now()))) {\n              try {\n                const response = await client.refreshAccessToken();\n                client.setCredentials(response.credentials);\n                Object.assign(tokens, response.credentials);\n                tokensUpdated = true;\n              } catch {\n                // Refresh failed\n              }\n            }\n          } catch {\n            client = null;\n          }\n        }\n\n        // Get email address - use cached value if available\n        let email = tokens.cached_email || 'unknown';\n        if (!tokens.cached_email && client) {\n          try {\n            email = await this.getUserEmail(client);\n            if (email !== 'unknown') {\n              tokens.cached_email = email;\n              tokensUpdated = true;\n            }\n          } catch {\n            // Email retrieval failed\n          }\n        }\n\n        // Get calendars - use cached if fresh, otherwise fetch\n        let calendars: CachedCalendar[] = tokens.cached_calendars || [];\n        const cacheExpired = !tokens.calendars_cached_at ||\n          (Date.now() - tokens.calendars_cached_at) > CALENDAR_CACHE_TTL;\n\n        if (cacheExpired && client) {\n          try {\n            calendars = await this.fetchCalendarsForClient(client);\n            tokens.cached_calendars = calendars;\n            tokens.calendars_cached_at = Date.now();\n            tokensUpdated = true;\n          } catch {\n            // Calendar fetch failed, use cached or empty\n          }\n        }\n\n        // Determine status\n        let status = 'active';\n        if (!tokens.refresh_token) {\n          if (!tokens.access_token || (tokens.expiry_date && tokens.expiry_date < Date.now())) {\n            status = 'expired';\n          }\n        }\n\n        accountList.push({ id: accountId, email, status, calendars });\n      }\n\n      // Save updated tokens with cached data using atomic read-modify-write\n      // This prevents race conditions when multiple listAccounts() calls run concurrently\n      if (tokensUpdated) {\n        await this.enqueueTokenWrite(async () => {\n          // Re-read current token state to preserve any concurrent auth changes\n          const latestTokens = await this.loadMultiAccountTokensRaw();\n\n          // Merge our cached metadata updates into the latest token state\n          for (const accountId of Object.keys(multiAccountTokens)) {\n            const localUpdates = multiAccountTokens[accountId];\n            const latestAccount = latestTokens[accountId];\n\n            if (latestAccount && localUpdates) {\n              // Only update cached metadata, not auth tokens\n              if (localUpdates.cached_email) {\n                latestAccount.cached_email = localUpdates.cached_email;\n              }\n              if (localUpdates.cached_calendars) {\n                latestAccount.cached_calendars = localUpdates.cached_calendars;\n                latestAccount.calendars_cached_at = localUpdates.calendars_cached_at;\n              }\n            }\n          }\n\n          await this.writeTokenFile(latestTokens);\n        });\n      }\n\n      return accountList;\n    } catch (error) {\n      return [];\n    }\n  }\n\n  /**\n   * Fetch calendars for a specific OAuth2Client\n   */\n  private async fetchCalendarsForClient(client: OAuth2Client): Promise<CachedCalendar[]> {\n    const { google } = await import('googleapis');\n    const calendar = google.calendar({ version: 'v3', auth: client });\n    const response = await calendar.calendarList.list();\n    const items = response.data.items || [];\n\n    const calendars: CachedCalendar[] = items.map(cal => ({\n      id: cal.id || '',\n      summary: cal.summary || '',\n      summaryOverride: cal.summaryOverride || undefined,\n      accessRole: cal.accessRole || 'reader',\n      primary: cal.primary || false,\n      backgroundColor: cal.backgroundColor || undefined\n    }));\n\n    // Sort: primary first, then by name\n    calendars.sort((a, b) => {\n      if (a.primary && !b.primary) return -1;\n      if (!a.primary && b.primary) return 1;\n      return (a.summaryOverride || a.summary).localeCompare(b.summaryOverride || b.summary);\n    });\n\n    return calendars;\n  }\n\n  /**\n   * Get user email address from OAuth2Client\n   * First tries getTokenInfo, then falls back to primary calendar ID\n   */\n  private async getUserEmail(client: OAuth2Client): Promise<string> {\n    try {\n      // Try getTokenInfo first (only works if token has email/openid scope)\n      const tokenInfo = await client.getTokenInfo(client.credentials.access_token || '');\n      if (tokenInfo.email) {\n        return tokenInfo.email;\n      }\n    } catch {\n      // Token info failed, try calendar fallback\n    }\n\n    // Fallback: Get primary calendar ID (usually the user's email)\n    try {\n      const { google } = await import('googleapis');\n      const calendar = google.calendar({ version: 'v3', auth: client });\n      const response = await calendar.calendars.get({ calendarId: 'primary' });\n      const primaryId = response.data.id;\n      // Primary calendar ID is typically the user's email\n      if (primaryId && primaryId.includes('@')) {\n        return primaryId;\n      }\n    } catch {\n      // Calendar fallback also failed\n    }\n\n    return 'unknown';\n  }\n} \n", "import fs from 'fs/promises';\nimport path from 'path';\nimport { fileURLToPath } from 'url';\n\nconst __filename = fileURLToPath(import.meta.url);\nconst __dirname = path.dirname(__filename);\n\n/**\n * Escape HTML special characters to prevent XSS\n */\nexport function escapeHtml(text: string): string {\n  const htmlEscapes: Record<string, string> = {\n    '&': '&amp;',\n    '<': '&lt;',\n    '>': '&gt;',\n    '\"': '&quot;',\n    \"'\": '&#39;'\n  };\n  return text.replace(/[&<>\"']/g, char => htmlEscapes[char]);\n}\n\n/**\n * Load a file from the web directory (handles build vs source paths)\n *\n * When running from bundled code (build/index.js), __dirname is \"build/\"\n * and web files are in \"build/web/\". When running from source, __dirname\n * is \"src/web/\" and files are in the same directory.\n */\nexport async function loadWebFile(fileName: string): Promise<string> {\n  // Possible locations for web files:\n  // 1. Same directory as this file (source: src/web/)\n  // 2. \"web\" subdirectory (bundled: build/web/)\n  const locations = [\n    path.join(__dirname, fileName),         // src/web/file.html (source)\n    path.join(__dirname, 'web', fileName),  // build/web/file.html (bundled)\n  ];\n\n  for (const filePath of locations) {\n    try {\n      await fs.access(filePath);\n      return fs.readFile(filePath, 'utf-8');\n    } catch {\n      // Try next location\n    }\n  }\n\n  throw new Error(`Web file not found: ${fileName}. Tried: ${locations.join(', ')}`);\n}\n\n/**\n * Load a template file\n */\nasync function loadTemplate(templateName: string): Promise<string> {\n  return loadWebFile(templateName);\n}\n\nexport interface AuthSuccessParams {\n  accountId: string;\n  email?: string;\n  tokenPath?: string;\n  showCloseButton?: boolean;\n  postMessageOrigin?: string;\n}\n\n/**\n * Render the authentication success page\n */\nexport async function renderAuthSuccess(params: AuthSuccessParams): Promise<string> {\n  const template = await loadTemplate('auth-success.html');\n  const safeAccountId = escapeHtml(params.accountId);\n\n  // Build account info section - email is prominent, account ID is secondary\n  let accountInfoSection: string;\n  if (params.email) {\n    accountInfoSection = `\n      <p class=\"account-email\">${escapeHtml(params.email)}</p>\n      <p class=\"account-label\">Saved as <code>${safeAccountId}</code></p>`;\n  } else {\n    accountInfoSection = `\n      <p class=\"account-email\">Account connected</p>\n      <p class=\"account-label\">Saved as <code>${safeAccountId}</code></p>`;\n  }\n\n  const closeButtonSection = params.showCloseButton\n    ? `<button onclick=\"window.close()\">Close Window</button>`\n    : '';\n\n  const scriptSection = params.postMessageOrigin\n    ? `<script>\n        if (window.opener) {\n          window.opener.postMessage({ type: 'auth-success', accountId: '${safeAccountId}' }, '${escapeHtml(params.postMessageOrigin)}');\n        }\n        setTimeout(() => window.close(), 3000);\n      </script>`\n    : '';\n\n  return template\n    .replace('{{accountInfo}}', accountInfoSection)\n    .replace('{{closeButton}}', closeButtonSection)\n    .replace('{{script}}', scriptSection);\n}\n\nexport interface AuthErrorParams {\n  errorMessage: string;\n  showCloseButton?: boolean;\n}\n\n/**\n * Render the authentication error page\n */\nexport async function renderAuthError(params: AuthErrorParams): Promise<string> {\n  const template = await loadTemplate('auth-error.html');\n  const safeError = escapeHtml(params.errorMessage);\n\n  const closeButtonSection = params.showCloseButton\n    ? `<button onclick=\"window.close()\">Close Window</button>`\n    : '';\n\n  return template\n    .replace('{{errorMessage}}', safeError)\n    .replace('{{closeButton}}', closeButtonSection);\n}\n\nexport interface AuthLandingParams {\n  accountId: string;\n  authUrl: string;\n}\n\n/**\n * Render the authentication landing page (click to authenticate)\n */\nexport async function renderAuthLanding(params: AuthLandingParams): Promise<string> {\n  const template = await loadTemplate('auth-landing.html');\n  const safeAccountId = escapeHtml(params.accountId);\n  const safeAuthUrl = escapeHtml(params.authUrl);\n\n  return template\n    .replace(/\\{\\{accountId\\}\\}/g, safeAccountId)\n    .replace('{{authUrl}}', safeAuthUrl);\n}\n", "import { McpServer } from \"@modelcontextprotocol/sdk/server/mcp.js\";\nimport { z } from \"zod\";\nimport { zodToJsonSchema } from \"zod-to-json-schema\";\nimport { BaseToolHandler } from \"../handlers/core/BaseToolHandler.js\";\nimport { ALLOWED_EVENT_FIELDS } from \"../utils/field-mask-builder.js\";\nimport { ServerConfig } from \"../config/TransportConfig.js\";\n\n// Import all handlers\nimport { ListCalendarsHandler } from \"../handlers/core/ListCalendarsHandler.js\";\nimport { ListEventsHandler } from \"../handlers/core/ListEventsHandler.js\";\nimport { SearchEventsHandler } from \"../handlers/core/SearchEventsHandler.js\";\nimport { GetEventHandler } from \"../handlers/core/GetEventHandler.js\";\nimport { ListColorsHandler } from \"../handlers/core/ListColorsHandler.js\";\nimport { CreateEventHandler } from \"../handlers/core/CreateEventHandler.js\";\nimport { UpdateEventHandler } from \"../handlers/core/UpdateEventHandler.js\";\nimport { DeleteEventHandler } from \"../handlers/core/DeleteEventHandler.js\";\nimport { FreeBusyEventHandler } from \"../handlers/core/FreeBusyEventHandler.js\";\nimport { GetCurrentTimeHandler } from \"../handlers/core/GetCurrentTimeHandler.js\";\nimport { RespondToEventHandler } from \"../handlers/core/RespondToEventHandler.js\";\n\n// ============================================================================\n// SHARED VALIDATION PATTERNS\n// ============================================================================\n// Note: We use validation functions instead of shared schemas to avoid $ref\n// generation in JSON schema output, which can cause issues with some MCP clients.\n\n// ISO 8601 datetime regex patterns\nconst ISO_DATETIME_WITH_TZ = /^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(Z|[+-]\\d{2}:\\d{2})$/;\nconst ISO_DATETIME_WITHOUT_TZ = /^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}$/;\nconst ISO_DATE_ONLY = /^\\d{4}-\\d{2}-\\d{2}$/;\n\n// Validation functions\nconst isValidIsoDateTime = (val: string): boolean =>\n  ISO_DATETIME_WITH_TZ.test(val) || ISO_DATETIME_WITHOUT_TZ.test(val);\n\nconst isValidIsoDateOrDateTime = (val: string): boolean =>\n  ISO_DATE_ONLY.test(val) || isValidIsoDateTime(val);\n\n// ============================================================================\n// SHARED ENUMS\n// ============================================================================\n\nconst SEND_UPDATES_VALUES = [\"all\", \"externalOnly\", \"none\"] as const;\nconst VISIBILITY_VALUES = [\"default\", \"public\", \"private\", \"confidential\"] as const;\nconst TRANSPARENCY_VALUES = [\"opaque\", \"transparent\"] as const;\nconst AUTO_DECLINE_MODE_VALUES = [\n  \"declineNone\",\n  \"declineAllConflictingInvitations\",\n  \"declineOnlyNewConflictingInvitations\"\n] as const;\nconst RESPONSE_STATUS_VALUES = [\"needsAction\", \"declined\", \"tentative\", \"accepted\"] as const;\nconst CONFERENCE_TYPE_VALUES = [\"hangoutsMeet\", \"eventHangout\", \"eventNamedHangout\", \"addOn\"] as const;\n\n// ============================================================================\n// SHARED NESTED SCHEMAS\n// ============================================================================\n\nconst remindersSchema = z.object({\n  useDefault: z.boolean().describe(\"Whether to use the default reminders\"),\n  overrides: z.array(z.object({\n    method: z.enum([\"email\", \"popup\"]).default(\"popup\").describe(\"Reminder method\"),\n    minutes: z.number().describe(\"Minutes before the event to trigger the reminder\")\n  }).partial({ method: true })).optional().describe(\"Custom reminders\")\n}).describe(\"Reminder settings for the event\").optional();\n\nconst conferenceDataSchema = z.object({\n  createRequest: z.object({\n    requestId: z.string().describe(\"Client-generated unique ID for this request to ensure idempotency\"),\n    conferenceSolutionKey: z.object({\n      type: z.enum(CONFERENCE_TYPE_VALUES).describe(\"Conference solution type\")\n    }).describe(\"Conference solution to create\")\n  }).describe(\"Request to generate a new conference\")\n}).optional();\n\nconst extendedPropertiesSchema = z.object({\n  private: z.record(z.string()).optional().describe(\n    \"Properties private to the application. Keys can have max 44 chars, values max 1024 chars.\"\n  ),\n  shared: z.record(z.string()).optional().describe(\n    \"Properties visible to all attendees. Keys can have max 44 chars, values max 1024 chars.\"\n  )\n}).optional().describe(\n  \"Extended properties for storing application-specific data. Max 300 properties totaling 32KB.\"\n);\n\n// ============================================================================\n// FIELD-LEVEL SCHEMAS\n// ============================================================================\n\nconst timeMinSchema = z.string()\n  .refine(isValidIsoDateTime, \"Must be ISO 8601 format: '2026-01-01T00:00:00'\")\n  .describe(\"Start of time range (ISO 8601, e.g., '2024-01-01T00:00:00').\")\n  .optional();\n\nconst timeMaxSchema = z.string()\n  .refine(isValidIsoDateTime, \"Must be ISO 8601 format: '2026-01-01T00:00:00'\")\n  .describe(\"End of time range (ISO 8601, e.g., '2024-01-31T23:59:59').\")\n  .optional();\n\nconst timeZoneSchema = z.string().optional().describe(\n  \"IANA timezone (e.g., 'America/Los_Angeles'). Defaults to calendar's timezone.\"\n);\n\n/**\n * Helper to parse JSON string arrays (handles Python/shell-style single quotes)\n * Used by multiple schemas to accept both native arrays and JSON string arrays\n */\nconst parseJsonStringArray = (val: unknown): unknown => {\n  if (typeof val !== 'string') return val;\n  const trimmed = val.trim();\n  if (!trimmed.startsWith('[') || !trimmed.endsWith(']')) return val;\n\n  try {\n    // Handle single-quoted JSON-like strings (Python/shell style)\n    let jsonString = trimmed;\n    if (jsonString.includes(\"'\")) {\n      jsonString = jsonString\n        .replace(/\\[\\s*'/g, '[\"')\n        .replace(/'\\s*,\\s*'/g, '\", \"')\n        .replace(/'\\s*\\]/g, '\"]');\n    }\n    const parsed = JSON.parse(jsonString);\n    if (Array.isArray(parsed) && parsed.every(item => typeof item === 'string')) {\n      return parsed;\n    }\n  } catch {\n    // Fall through to return original value\n  }\n  return val;\n};\n\nconst fieldsSchema = z.preprocess(\n  parseJsonStringArray,\n  z.array(z.enum(ALLOWED_EVENT_FIELDS))\n).optional().describe(\n  \"Additional fields to include beyond defaults (id, summary, start, end, status, htmlLink, location, attendees).\"\n);\n\nconst calendarsToCheckSchema = z.preprocess(\n  parseJsonStringArray,\n  z.array(z.string())\n).optional().describe(\n  \"List of calendar IDs to check for conflicts (defaults to just the target calendar)\"\n);\n\nconst recurrenceSchema = z.preprocess(\n  parseJsonStringArray,\n  z.array(z.string())\n).optional().describe(\n  \"Recurrence rules in RFC5545 format (e.g., [\\\"RRULE:FREQ=WEEKLY;COUNT=5\\\"])\"\n);\n\nconst privateExtendedPropertySchema = z\n  .array(z.string().regex(/^[^=]+=[^=]+$/, \"Must be in key=value format\"))\n  .optional()\n  .describe(\n    \"Filter by private extended properties (key=value). Matches events that have all specified properties.\"\n  );\n\nconst sharedExtendedPropertySchema = z\n  .array(z.string().regex(/^[^=]+=[^=]+$/, \"Must be in key=value format\"))\n  .optional()\n  .describe(\n    \"Filter by shared extended properties (key=value). Matches events that have all specified properties.\"\n  );\n\n// Single account schema - for write operations (create, update, delete)\nconst singleAccountSchema = z.string()\n  .regex(/^[a-z0-9_-]{1,64}$/, \"Account nickname must be 1-64 characters: lowercase letters, numbers, dashes, underscores only\")\n  .optional()\n  .describe(\n    \"Account nickname (e.g., 'work'). Optional if only one account connected.\"\n  );\n\n// Account ID validation regex\nconst accountIdRegex = /^[a-z0-9_-]{1,64}$/;\n\n// Multi-account schema - for read operations (list, search, get)\nconst multiAccountSchema = z.preprocess(\n  parseJsonStringArray,\n  z.union([\n    z.string()\n      .regex(accountIdRegex, \"Account nickname must be 1-64 characters: lowercase letters, numbers, dashes, underscores only\"),\n    z.array(z.string()\n      .regex(accountIdRegex, \"Account nickname must be 1-64 characters: lowercase letters, numbers, dashes, underscores only\"))\n      .min(1, \"At least one account nickname is required\")\n      .max(10, \"Maximum 10 accounts allowed per request\")\n  ])\n)\n  .optional()\n  .describe(\n    \"Account nickname(s) to query (e.g., 'work' or ['work', 'personal']). Omit to query all accounts.\"\n  );\n\n// Define all tool schemas with TypeScript inference\nexport const ToolSchemas = {\n  'list-calendars': z.object({\n    account: multiAccountSchema\n  }),\n\n  'list-events': z.object({\n    account: multiAccountSchema,\n    calendarId: z.union([\n      z.string().describe(\n        \"Calendar identifier(s) to query. Accepts calendar IDs (e.g., 'primary', 'user@gmail.com') OR calendar names (e.g., 'Work', 'Personal'). Single calendar: 'primary'. Multiple calendars: array ['Work', 'Personal'] or JSON string '[\\\"Work\\\", \\\"Personal\\\"]'\"\n      ),\n      z.array(z.string().min(1))\n        .min(1, \"At least one calendar ID is required\")\n        .max(50, \"Maximum 50 calendars allowed per request\")\n        .refine(\n          (arr) => new Set(arr).size === arr.length,\n          \"Duplicate calendar IDs are not allowed\"\n        )\n        .describe(\"Array of calendar IDs to query events from (max 50, no duplicates)\")\n    ]),\n    timeMin: timeMinSchema,\n    timeMax: timeMaxSchema,\n    timeZone: timeZoneSchema,\n    fields: fieldsSchema,\n    privateExtendedProperty: privateExtendedPropertySchema,\n    sharedExtendedProperty: sharedExtendedPropertySchema\n  }),\n  \n  'search-events': z.object({\n    account: multiAccountSchema,\n    calendarId: z.union([\n      z.string().describe(\n        \"Calendar identifier(s) to search. Accepts calendar IDs (e.g., 'primary', 'user@gmail.com') OR calendar names (e.g., 'Work', 'Personal'). Single calendar: 'primary'. Multiple calendars: array ['Work', 'Personal'] or JSON string '[\\\"Work\\\", \\\"Personal\\\"]'\"\n      ),\n      z.array(z.string())\n    ]).transform((val) => {\n      if (typeof val === 'string') {\n        // Try to parse JSON array if it looks like one\n        if (val.startsWith('[')) {\n          try {\n            const parsed = JSON.parse(val);\n            if (Array.isArray(parsed)) return parsed;\n          } catch { /* ignore */ }\n        }\n        return val;\n      }\n      return val;\n    }).describe(\"Calendar identifier(s) to search. Accepts calendar IDs or names. Single or multiple calendars supported.\"),\n    query: z.string().describe(\n      \"Free text search query (searches summary, description, location, attendees, etc.)\"\n    ),\n    timeMin: z.string()\n      .refine(isValidIsoDateTime, \"Must be ISO 8601 format: '2026-01-01T00:00:00'\")\n      .describe(\"Start of time range (ISO 8601, e.g., '2024-01-01T00:00:00').\"),\n    timeMax: z.string()\n      .refine(isValidIsoDateTime, \"Must be ISO 8601 format: '2026-01-01T00:00:00'\")\n      .describe(\"End of time range (ISO 8601, e.g., '2024-01-31T23:59:59').\"),\n    timeZone: timeZoneSchema,\n    fields: z.array(z.enum(ALLOWED_EVENT_FIELDS)).optional().describe(\n      \"Additional fields to include beyond defaults (id, summary, start, end, status, htmlLink, location, attendees).\"\n    ),\n    privateExtendedProperty: z\n      .array(z.string().regex(/^[^=]+=[^=]+$/, \"Must be in key=value format\"))\n      .optional()\n      .describe(\n        \"Filter by private extended properties (key=value). Matches events that have all specified properties.\"\n      ),\n    sharedExtendedProperty: z\n      .array(z.string().regex(/^[^=]+=[^=]+$/, \"Must be in key=value format\"))\n      .optional()\n      .describe(\n        \"Filter by shared extended properties (key=value). Matches events that have all specified properties.\"\n      )\n  }),\n  \n  'get-event': z.object({\n    account: singleAccountSchema,\n    calendarId: z.string().describe(\"ID of the calendar (use 'primary' for the main calendar)\"),\n    eventId: z.string().describe(\"ID of the event to retrieve\"),\n    fields: z.array(z.enum(ALLOWED_EVENT_FIELDS)).optional().describe(\n      \"Optional array of additional event fields to retrieve. Available fields are strictly validated. Default fields (id, summary, start, end, status, htmlLink, location, attendees) are always included.\"\n    )\n  }),\n\n  'list-colors': z.object({\n    account: singleAccountSchema,\n  }),\n\n  'create-event': z.object({\n    account: singleAccountSchema,\n    calendarId: z.string().describe(\"ID of the calendar (use 'primary' for the main calendar)\"),\n    eventId: z.string().optional().describe(\"Optional custom event ID (5-1024 characters, base32hex encoding: lowercase letters a-v and digits 0-9 only). If not provided, Google Calendar will generate one.\"),\n    summary: z.string().describe(\"Title of the event\"),\n    description: z.string().optional().describe(\"Description/notes for the event\"),\n    start: z.string()\n      .refine(isValidIsoDateOrDateTime, \"Must be ISO 8601 format: '2025-01-01T10:00:00' for timed events or '2025-01-01' for all-day events\")\n      .describe(\"Event start time: '2025-01-01T10:00:00' for timed events or '2025-01-01' for all-day events. Also accepts Google Calendar API object format: {date: '2025-01-01'} or {dateTime: '2025-01-01T10:00:00', timeZone: 'America/Los_Angeles'}\"),\n    end: z.string()\n      .refine(isValidIsoDateOrDateTime, \"Must be ISO 8601 format: '2025-01-01T11:00:00' for timed events or '2025-01-02' for all-day events\")\n      .describe(\"Event end time: '2025-01-01T11:00:00' for timed events or '2025-01-02' for all-day events (exclusive). Also accepts Google Calendar API object format: {date: '2025-01-02'} or {dateTime: '2025-01-01T11:00:00', timeZone: 'America/Los_Angeles'}\"),\n    timeZone: z.string().optional().describe(\n      \"Timezone as IANA Time Zone Database name (e.g., America/Los_Angeles). Takes priority over calendar's default timezone. Only used for timezone-naive datetime strings.\"\n    ),\n    location: z.string().optional().describe(\"Location of the event\"),\n    attendees: z.array(z.object({\n      email: z.string().email().describe(\"Email address of the attendee\"),\n      displayName: z.string().optional().describe(\"Display name of the attendee\"),\n      optional: z.boolean().optional().describe(\"Whether this is an optional attendee\"),\n      responseStatus: z.enum(RESPONSE_STATUS_VALUES).optional().describe(\"Attendee's response status\"),\n      comment: z.string().optional().describe(\"Attendee's response comment\"),\n      additionalGuests: z.number().int().min(0).optional().describe(\"Number of additional guests the attendee is bringing\")\n    })).optional().describe(\"List of event attendees with their details\"),\n    colorId: z.string().optional().describe(\n      \"Color ID for the event (use list-colors to see available IDs)\"\n    ),\n    reminders: remindersSchema,\n    recurrence: recurrenceSchema,\n    transparency: z.enum(TRANSPARENCY_VALUES).optional().describe(\n      \"Whether the event blocks time on the calendar. 'opaque' means busy, 'transparent' means free.\"\n    ),\n    visibility: z.enum(VISIBILITY_VALUES).optional().describe(\n      \"Visibility of the event. Use 'public' for public events, 'private' for private events visible to attendees.\"\n    ),\n    guestsCanInviteOthers: z.boolean().optional().describe(\n      \"Whether attendees can invite others to the event. Default is true.\"\n    ),\n    guestsCanModify: z.boolean().optional().describe(\n      \"Whether attendees can modify the event. Default is false.\"\n    ),\n    guestsCanSeeOtherGuests: z.boolean().optional().describe(\n      \"Whether attendees can see the list of other attendees. Default is true.\"\n    ),\n    anyoneCanAddSelf: z.boolean().optional().describe(\n      \"Whether anyone can add themselves to the event. Default is false.\"\n    ),\n    sendUpdates: z.enum(SEND_UPDATES_VALUES).optional().describe(\n      \"Whether to send notifications about the event creation. 'all' sends to all guests, 'externalOnly' to non-Google Calendar users only, 'none' sends no notifications.\"\n    ),\n    conferenceData: conferenceDataSchema.describe(\n      \"Conference properties for the event. Use createRequest to add a new conference.\"\n    ),\n    extendedProperties: extendedPropertiesSchema,\n    attachments: z.array(z.object({\n      fileUrl: z.string().describe(\"URL of the attached file\"),\n      title: z.string().optional().describe(\"Title of the attachment\"),\n      mimeType: z.string().optional().describe(\"MIME type of the attachment\"),\n      iconLink: z.string().optional().describe(\"URL of the icon for the attachment\"),\n      fileId: z.string().optional().describe(\"ID of the attached file in Google Drive\")\n    })).optional().describe(\n      \"File attachments for the event. Requires calendar to support attachments.\"\n    ),\n    source: z.object({\n      url: z.string().describe(\"URL of the source\"),\n      title: z.string().describe(\"Title of the source\")\n    }).optional().describe(\n      \"Source of the event, such as a web page or email message.\"\n    ),\n    calendarsToCheck: calendarsToCheckSchema,\n    duplicateSimilarityThreshold: z.number().min(0).max(1).optional().describe(\n      \"Threshold for duplicate detection (0-1, default: 0.7). Events with similarity above this are flagged as potential duplicates\"\n    ),\n    allowDuplicates: z.boolean().optional().describe(\n      \"If true, allows creation even when exact duplicates are detected (similarity >= 0.95). Default is false which blocks duplicate creation\"\n    ),\n    eventType: z.enum([\"default\", \"focusTime\", \"outOfOffice\", \"workingLocation\"]).optional().describe(\n      \"Type of the event. 'default' for regular events, 'focusTime' for Focus Time blocks, 'outOfOffice' for Out of Office events, 'workingLocation' for Working Location events. Note: outOfOffice and workingLocation require Google Workspace and only work on primary calendar.\"\n    ),\n    focusTimeProperties: z.object({\n      autoDeclineMode: z.enum(AUTO_DECLINE_MODE_VALUES).optional().describe(\"Whether to auto-decline conflicting meetings\"),\n      chatStatus: z.enum([\"available\", \"doNotDisturb\"]).optional()\n        .describe(\"Chat status during focus time\"),\n      declineMessage: z.string().optional()\n        .describe(\"Message sent when declining invitations\")\n    }).optional().describe(\n      \"Focus Time properties. Only used when eventType is 'focusTime'. Requires Google Workspace.\"\n    ),\n    outOfOfficeProperties: z.object({\n      autoDeclineMode: z.enum(AUTO_DECLINE_MODE_VALUES).optional().default(\"declineAllConflictingInvitations\")\n        .describe(\"How to handle conflicting meetings. Default is to decline all conflicts.\"),\n      declineMessage: z.string().optional()\n        .describe(\"Message sent when declining invitations (e.g., 'I'm out of office, will respond when I return')\")\n    }).optional().describe(\n      \"Out of Office properties. Only used when eventType is 'outOfOffice'. Requires Google Workspace.\"\n    ),\n    workingLocationProperties: z.object({\n      type: z.enum([\"homeOffice\", \"officeLocation\", \"customLocation\"])\n        .describe(\"Type of working location\"),\n      homeOffice: z.object({}).optional()\n        .describe(\"Empty object for home office type\"),\n      officeLocation: z.object({\n        label: z.string().optional().describe(\"Office name shown in Calendar (e.g., 'HQ Building', 'NYC Office')\"),\n        buildingId: z.string().optional().describe(\"Building identifier from organization's Resources\"),\n        floorId: z.string().optional().describe(\"Floor identifier\"),\n        floorSectionId: z.string().optional().describe(\"Floor section identifier\"),\n        deskId: z.string().optional().describe(\"Desk identifier\")\n      }).optional().describe(\"Office location details\"),\n      customLocation: z.object({\n        label: z.string().optional().describe(\"Label for custom location (e.g., 'Coffee Shop', 'Client Site')\")\n      }).optional().describe(\"Custom location details\")\n    }).optional().describe(\n      \"Working Location properties. Only used when eventType is 'workingLocation'. Requires Google Workspace.\"\n    )\n  }).refine(\n    (data) => {\n      // Validate that focusTime and outOfOffice events use dateTime (not all-day date format)\n      if (data.eventType === 'focusTime' || data.eventType === 'outOfOffice') {\n        if (ISO_DATE_ONLY.test(data.start) || ISO_DATE_ONLY.test(data.end)) {\n          return false;\n        }\n      }\n      return true;\n    },\n    {\n      message: \"Focus Time and Out of Office events cannot be all-day events. Use dateTime format (e.g., '2025-01-01T10:00:00') instead of date format.\",\n      path: [\"eventType\"]\n    }\n  ),\n\n  'update-event': z.object({\n    account: singleAccountSchema,\n    calendarId: z.string().describe(\"ID of the calendar (use 'primary' for the main calendar)\"),\n    eventId: z.string().describe(\"ID of the event to update\"),\n    summary: z.string().optional().describe(\"Updated title of the event\"),\n    description: z.string().optional().describe(\"Updated description/notes\"),\n    start: z.string()\n      .refine(isValidIsoDateOrDateTime, \"Must be ISO 8601 format: '2025-01-01T10:00:00' for timed events or '2025-01-01' for all-day events\")\n      .describe(\"Updated start time: '2025-01-01T10:00:00' for timed events or '2025-01-01' for all-day events. Also accepts Google Calendar API object format: {date: '2025-01-01'} or {dateTime: '2025-01-01T10:00:00', timeZone: 'America/Los_Angeles'}\")\n      .optional(),\n    end: z.string()\n      .refine(isValidIsoDateOrDateTime, \"Must be ISO 8601 format: '2025-01-01T11:00:00' for timed events or '2025-01-02' for all-day events\")\n      .describe(\"Updated end time: '2025-01-01T11:00:00' for timed events or '2025-01-02' for all-day events (exclusive). Also accepts Google Calendar API object format: {date: '2025-01-02'} or {dateTime: '2025-01-01T11:00:00', timeZone: 'America/Los_Angeles'}\")\n      .optional(),\n    timeZone: z.string().optional().describe(\"Updated timezone as IANA Time Zone Database name. If not provided, uses the calendar's default timezone.\"),\n    location: z.string().optional().describe(\"Updated location\"),\n    attendees: z.array(z.object({\n      email: z.string().email().describe(\"Email address of the attendee\")\n    })).optional().describe(\"Updated attendee list\"),\n    colorId: z.string().optional().describe(\"Updated color ID\"),\n    reminders: remindersSchema,\n    recurrence: recurrenceSchema,\n    sendUpdates: z.enum(SEND_UPDATES_VALUES).default(\"all\").describe(\n      \"Whether to send update notifications\"\n    ),\n    modificationScope: z.enum([\"thisAndFollowing\", \"all\", \"thisEventOnly\"]).optional().describe(\n      \"Scope for recurring event modifications\"\n    ),\n    originalStartTime: z.string()\n      .refine(isValidIsoDateTime, \"Must be ISO 8601 format: '2026-01-01T00:00:00'\")\n      .describe(\"Original start time in the ISO 8601 format '2024-01-01T10:00:00'\")\n      .optional(),\n    futureStartDate: z.string()\n      .refine(isValidIsoDateTime, \"Must be ISO 8601 format: '2026-01-01T00:00:00'\")\n      .describe(\"Start date for future instances in the ISO 8601 format '2024-01-01T10:00:00'\")\n      .optional(),\n    checkConflicts: z.boolean().optional().describe(\n      \"Whether to check for conflicts when updating (default: true when changing time)\"\n    ),\n    calendarsToCheck: calendarsToCheckSchema,\n    conferenceData: conferenceDataSchema.describe(\"Conference properties for the event. Used to add or update Google Meet links.\"),\n    transparency: z.enum(TRANSPARENCY_VALUES).optional().describe(\n      \"Whether the event blocks time on the calendar. 'opaque' means busy, 'transparent' means available\"\n    ),\n    visibility: z.enum(VISIBILITY_VALUES).optional().describe(\n      \"Visibility of the event\"\n    ),\n    guestsCanInviteOthers: z.boolean().optional().describe(\n      \"Whether attendees other than the organizer can invite others\"\n    ),\n    guestsCanModify: z.boolean().optional().describe(\n      \"Whether attendees other than the organizer can modify the event\"\n    ),\n    guestsCanSeeOtherGuests: z.boolean().optional().describe(\n      \"Whether attendees other than the organizer can see who the event's attendees are\"\n    ),\n    anyoneCanAddSelf: z.boolean().optional().describe(\n      \"Whether anyone can add themselves to the event\"\n    ),\n    extendedProperties: extendedPropertiesSchema,\n    attachments: z.array(z.object({\n      fileUrl: z.string().url().describe(\"URL link to the attachment\"),\n      title: z.string().describe(\"Title of the attachment\"),\n      mimeType: z.string().optional().describe(\"MIME type of the attachment\"),\n      iconLink: z.string().optional().describe(\"URL link to the attachment's icon\"),\n      fileId: z.string().optional().describe(\"ID of the attached Google Drive file\")\n    })).optional().describe(\"File attachments for the event\")\n    // Note: eventType is intentionally not included - Google Calendar API does not allow changing event type after creation\n  }).refine(\n    (data) => {\n      // Require originalStartTime when modificationScope is 'thisEventOnly'\n      if (data.modificationScope === 'thisEventOnly' && !data.originalStartTime) {\n        return false;\n      }\n      return true;\n    },\n    {\n      message: \"originalStartTime is required when modificationScope is 'thisEventOnly'\",\n      path: [\"originalStartTime\"]\n    }\n  ).refine(\n    (data) => {\n      // Require futureStartDate when modificationScope is 'thisAndFollowing'\n      if (data.modificationScope === 'thisAndFollowing' && !data.futureStartDate) {\n        return false;\n      }\n      return true;\n    },\n    {\n      message: \"futureStartDate is required when modificationScope is 'thisAndFollowing'\",\n      path: [\"futureStartDate\"]\n    }\n  ).refine(\n    (data) => {\n      // Ensure futureStartDate is in the future when provided\n      if (data.futureStartDate) {\n        const futureDate = new Date(data.futureStartDate);\n        const now = new Date();\n        return futureDate > now;\n      }\n      return true;\n    },\n    {\n      message: \"futureStartDate must be in the future\",\n      path: [\"futureStartDate\"]\n    }\n  ),\n  \n  'delete-event': z.object({\n    account: singleAccountSchema,\n    calendarId: z.string().describe(\"ID of the calendar (use 'primary' for the main calendar)\"),\n    eventId: z.string().describe(\"ID of the event to delete\"),\n    sendUpdates: z.enum(SEND_UPDATES_VALUES).default(\"all\").describe(\n      \"Whether to send cancellation notifications\"\n    )\n  }),\n\n  'get-freebusy': z.object({\n    account: multiAccountSchema.describe(\n      \"Account nickname(s) to query (e.g., 'work' or ['work', 'personal']). Omit to query all accounts.\"\n    ),\n    calendars: z.array(z.object({\n      id: z.string().describe(\"ID of the calendar (use 'primary' for the main calendar)\")\n    })).describe(\n      \"List of calendars and/or groups to query for free/busy information\"\n    ),\n    timeMin: z.string()\n      .refine(isValidIsoDateTime, \"Must be ISO 8601 format: '2026-01-01T00:00:00'\")\n      .describe(\"Start of time range (ISO 8601, e.g., '2024-01-01T00:00:00').\"),\n    timeMax: z.string()\n      .refine(isValidIsoDateTime, \"Must be ISO 8601 format: '2026-01-01T00:00:00'\")\n      .describe(\"End of time range (ISO 8601, e.g., '2024-01-31T23:59:59').\"),\n    timeZone: z.string().optional().describe(\"IANA timezone for the query.\"),\n    groupExpansionMax: z.number().int().max(100).optional().describe(\n      \"Maximum number of calendars to expand per group (max 100)\"\n    ),\n    calendarExpansionMax: z.number().int().max(50).optional().describe(\n      \"Maximum number of calendars to expand (max 50)\"\n    )\n  }),\n  \n  'get-current-time': z.object({\n    account: singleAccountSchema,\n    timeZone: z.string().optional().describe(\n      \"IANA timezone (e.g., 'America/Los_Angeles'). Defaults to calendar's timezone.\"\n    )\n  }),\n\n  'respond-to-event': z.object({\n    calendarId: z.string().describe(\"ID of the calendar (use 'primary' for the main calendar)\"),\n    eventId: z.string().describe(\"ID of the event to respond to\"),\n    account: z.string().optional().describe(\n      \"Account nickname to use for this operation (e.g., 'work', 'personal'). Optional when only one account is connected - will auto-select the account with appropriate permissions. Use 'list-calendars' to see available accounts.\"\n    ),\n    response: z.enum(RESPONSE_STATUS_VALUES).describe(\n      \"Your response to the event invitation: 'accepted' (accept), 'declined' (decline), 'tentative' (maybe), 'needsAction' (no response)\"\n    ),\n    comment: z.string().optional().describe(\n      \"Optional message/note to include with your response (e.g., 'I have a conflict' when declining)\"\n    ),\n    modificationScope: z.enum([\"thisEventOnly\", \"all\"]).optional().describe(\n      \"For recurring events: 'thisEventOnly' responds to just this instance, 'all' responds to all instances. Default is 'all'.\"\n    ),\n    originalStartTime: z.string()\n      .refine(isValidIsoDateTime, \"Must be ISO 8601 format: '2025-01-01T10:00:00'\")\n      .describe(\"Original start time of the specific instance (required when modificationScope is 'thisEventOnly')\")\n      .optional(),\n    sendUpdates: z.enum(SEND_UPDATES_VALUES).optional().describe(\n      \"Whether to send response notifications. 'all' sends to all guests, 'externalOnly' to non-Google Calendar users only, 'none' sends no notifications. Default is 'none'.\"\n    )\n  }).refine(\n    (data) => {\n      // Require originalStartTime when modificationScope is 'thisEventOnly'\n      if (data.modificationScope === 'thisEventOnly' && !data.originalStartTime) {\n        return false;\n      }\n      return true;\n    },\n    {\n      message: \"originalStartTime is required when modificationScope is 'thisEventOnly'\",\n      path: [\"originalStartTime\"]\n    }\n  )\n} as const;\n\n// Generate TypeScript types from schemas\nexport type ToolInputs = {\n  [K in keyof typeof ToolSchemas]: z.infer<typeof ToolSchemas[K]>\n};\n\n// Export individual types for convenience\nexport type ListCalendarsInput = ToolInputs['list-calendars'];\nexport type ListEventsInput = ToolInputs['list-events'];\nexport type SearchEventsInput = ToolInputs['search-events'];\nexport type GetEventInput = ToolInputs['get-event'];\nexport type ListColorsInput = ToolInputs['list-colors'];\nexport type CreateEventInput = ToolInputs['create-event'];\nexport type UpdateEventInput = ToolInputs['update-event'];\nexport type DeleteEventInput = ToolInputs['delete-event'];\nexport type GetFreeBusyInput = ToolInputs['get-freebusy'];\nexport type GetCurrentTimeInput = ToolInputs['get-current-time'];\nexport type RespondToEventInput = ToolInputs['respond-to-event'];\n\ninterface ToolDefinition {\n  name: keyof typeof ToolSchemas;\n  description: string;\n  schema: z.ZodType<any>;\n  handler: new () => BaseToolHandler;\n  handlerFunction?: (args: any) => Promise<any>;\n  customInputSchema?: any; // Custom schema shape for MCP registration (overrides extractSchemaShape)\n}\n\n\nexport class ToolRegistry {\n  private static extractSchemaShape(schema: z.ZodType<any>): any {\n    const schemaAny = schema as any;\n    \n    // Handle ZodEffects (schemas with .refine())\n    if (schemaAny._def && schemaAny._def.typeName === 'ZodEffects') {\n      return this.extractSchemaShape(schemaAny._def.schema);\n    }\n    \n    // Handle regular ZodObject\n    if ('shape' in schemaAny) {\n      return schemaAny.shape;\n    }\n    \n    // Handle other nested structures\n    if (schemaAny._def && schemaAny._def.schema) {\n      return this.extractSchemaShape(schemaAny._def.schema);\n    }\n    \n    // Fallback to the original approach\n    return schemaAny._def?.schema?.shape || schemaAny.shape;\n  }\n\n  private static tools: ToolDefinition[] = [\n    {\n      name: \"list-calendars\",\n      description: \"List all available calendars\",\n      schema: ToolSchemas['list-calendars'],\n      handler: ListCalendarsHandler\n    },\n    {\n      name: \"list-events\",\n      description: \"List events from one or more calendars. Supports both calendar IDs and calendar names.\",\n      schema: ToolSchemas['list-events'],\n      handler: ListEventsHandler,\n      handlerFunction: async (args: ListEventsInput & { calendarId: string | string[] }) => {\n        let processedCalendarId: string | string[] = args.calendarId;\n\n        // If it's already an array (native array format), keep as-is (already validated by schema)\n        if (Array.isArray(args.calendarId)) {\n          processedCalendarId = args.calendarId;\n        }\n        // Handle JSON string format (double or single-quoted)\n        else if (typeof args.calendarId === 'string' && args.calendarId.trim().startsWith('[') && args.calendarId.trim().endsWith(']')) {\n          try {\n            let jsonString = args.calendarId.trim();\n\n            // Normalize single-quoted JSON-like strings to valid JSON (Python/shell style)\n            // Only replace single quotes that are string delimiters (after '[', ',', or before ']', ',')\n            // This avoids breaking calendar IDs with apostrophes like \"John's Calendar\"\n            if (jsonString.includes(\"'\")) {\n              jsonString = jsonString\n                .replace(/\\[\\s*'/g, '[\"')           // [' -> [\"\n                .replace(/'\\s*,\\s*'/g, '\", \"')      // ', ' -> \", \"\n                .replace(/'\\s*\\]/g, '\"]');          // '] -> \"]\n            }\n\n            const parsed = JSON.parse(jsonString);\n\n            // Validate parsed result\n            if (!Array.isArray(parsed)) {\n              throw new Error('JSON string must contain an array');\n            }\n            if (!parsed.every(id => typeof id === 'string' && id.length > 0)) {\n              throw new Error('Array must contain only non-empty strings');\n            }\n            if (parsed.length === 0) {\n              throw new Error(\"At least one calendar ID is required\");\n            }\n            if (parsed.length > 50) {\n              throw new Error(\"Maximum 50 calendars allowed\");\n            }\n            if (new Set(parsed).size !== parsed.length) {\n              throw new Error(\"Duplicate calendar IDs are not allowed\");\n            }\n\n            processedCalendarId = parsed;\n          } catch (error) {\n            throw new Error(\n              `Invalid JSON format for calendarId: ${error instanceof Error ? error.message : 'Unknown parsing error'}`\n            );\n          }\n        }\n        // Otherwise it's a single string calendar ID - keep as-is\n\n        return {\n          account: args.account,\n          calendarId: processedCalendarId,\n          timeMin: args.timeMin,\n          timeMax: args.timeMax,\n          timeZone: args.timeZone,\n          fields: args.fields,\n          privateExtendedProperty: args.privateExtendedProperty,\n          sharedExtendedProperty: args.sharedExtendedProperty\n        };\n      }\n    },\n    {\n      name: \"search-events\",\n      description: \"Search for events in a calendar by text query.\",\n      schema: ToolSchemas['search-events'],\n      handler: SearchEventsHandler\n    },\n    {\n      name: \"get-event\",\n      description: \"Get details of a specific event by ID.\",\n      schema: ToolSchemas['get-event'],\n      handler: GetEventHandler\n    },\n    {\n      name: \"list-colors\",\n      description: \"List available color IDs and their meanings for calendar events\",\n      schema: ToolSchemas['list-colors'],\n      handler: ListColorsHandler\n    },\n    {\n      name: \"create-event\",\n      description: \"Create a new calendar event.\",\n      schema: ToolSchemas['create-event'],\n      handler: CreateEventHandler\n    },\n    {\n      name: \"update-event\",\n      description: \"Update an existing calendar event with recurring event modification scope support.\",\n      schema: ToolSchemas['update-event'],\n      handler: UpdateEventHandler\n    },\n    {\n      name: \"delete-event\",\n      description: \"Delete a calendar event.\",\n      schema: ToolSchemas['delete-event'],\n      handler: DeleteEventHandler\n    },\n    {\n      name: \"get-freebusy\",\n      description: \"Query free/busy information for calendars. Note: Time range is limited to a maximum of 3 months between timeMin and timeMax.\",\n      schema: ToolSchemas['get-freebusy'],\n      handler: FreeBusyEventHandler\n    },\n    {\n      name: \"get-current-time\",\n      description: \"Get the current date and time. Call this FIRST before creating, updating, or searching for events to ensure you have accurate date context for scheduling.\",\n      schema: ToolSchemas['get-current-time'],\n      handler: GetCurrentTimeHandler\n    },\n    {\n      name: \"respond-to-event\",\n      description: \"Respond to a calendar event invitation with Accept, Decline, Maybe (Tentative), or No Response.\",\n      schema: ToolSchemas['respond-to-event'],\n      handler: RespondToEventHandler\n    }\n  ];\n\n  static getToolsWithSchemas() {\n    return this.tools.map(tool => {\n      const jsonSchema = tool.customInputSchema\n        ? zodToJsonSchema(z.object(tool.customInputSchema))\n        : zodToJsonSchema(tool.schema);\n      return {\n        name: tool.name,\n        description: tool.description,\n        inputSchema: jsonSchema\n      };\n    });\n  }\n\n  /**\n   * Normalizes datetime fields from object format to string format\n   * Converts { date: \"2025-01-01\" } or { dateTime: \"...\", timeZone: \"...\" } to simple strings\n   * This allows accepting both Google Calendar API format and our simplified format\n   */\n  private static normalizeDateTimeFields(toolName: string, args: any): any {\n    // Only normalize for tools that have datetime fields\n    const toolsWithDateTime = ['create-event', 'update-event'];\n    if (!toolsWithDateTime.includes(toolName)) {\n      return args;\n    }\n\n    const normalized = { ...args };\n    const dateTimeFields = ['start', 'end', 'originalStartTime', 'futureStartDate'];\n\n    for (const field of dateTimeFields) {\n      if (normalized[field] && typeof normalized[field] === 'object') {\n        const obj = normalized[field];\n        // Convert object format to string format\n        if (obj.date) {\n          normalized[field] = obj.date;\n        } else if (obj.dateTime) {\n          normalized[field] = obj.dateTime;\n        }\n      }\n    }\n\n    return normalized;\n  }\n\n  /**\n   * Get all available tool names for validation\n   */\n  static getAvailableToolNames(): string[] {\n    return this.tools.map(t => t.name);\n  }\n\n  /**\n   * Validate that all tool names in a list exist\n   * @throws Error if any tool name is invalid\n   */\n  static validateToolNames(toolNames: string[]): void {\n    const availableTools = new Set([...this.getAvailableToolNames(), 'manage-accounts']);\n    const invalidTools = toolNames.filter(name => !availableTools.has(name));\n\n    if (invalidTools.length > 0) {\n      const available = [...this.getAvailableToolNames(), 'manage-accounts'].join(', ');\n      throw new Error(\n        `Invalid tool name(s): ${invalidTools.join(', ')}. ` +\n        `Available tools: ${available}`\n      );\n    }\n  }\n\n  static async registerAll(\n    server: McpServer,\n    executeWithHandler: (\n      handler: any,\n      args: any\n    ) => Promise<{ content: Array<{ type: \"text\"; text: string }> }>,\n    config?: ServerConfig\n  ) {\n    // Validate enabledTools if provided\n    if (config?.enabledTools) {\n      if (config.enabledTools.length === 0) {\n        throw new Error('Enabled tools list is empty. Provide at least one tool name.');\n      }\n      this.validateToolNames(config.enabledTools);\n      const enabledSet = new Set(config.enabledTools);\n      process.stderr.write(`Tool filtering enabled: ${config.enabledTools.join(', ')}\\n`);\n\n      // Filter and register only enabled tools\n      for (const tool of this.tools) {\n        if (!enabledSet.has(tool.name)) {\n          continue;\n        }\n        this.registerSingleTool(server, tool, executeWithHandler);\n      }\n      return;\n    }\n\n    // No filtering - register all tools\n    for (const tool of this.tools) {\n      this.registerSingleTool(server, tool, executeWithHandler);\n    }\n  }\n\n  private static registerSingleTool(\n    server: McpServer,\n    tool: ToolDefinition,\n    executeWithHandler: (\n      handler: any,\n      args: any\n    ) => Promise<{ content: Array<{ type: \"text\"; text: string }> }>\n  ) {\n    // Use the existing registerTool method which handles schema conversion properly\n    server.registerTool(\n        tool.name,\n        {\n          description: tool.description,\n          inputSchema: tool.customInputSchema || this.extractSchemaShape(tool.schema)\n        },\n        async (args: any) => {\n          // Preprocess: Normalize datetime fields (convert object format to string format)\n          // This allows accepting both formats while keeping schemas simple\n          const normalizedArgs = this.normalizeDateTimeFields(tool.name, args);\n\n          // Validate input using our Zod schema\n          const validatedArgs = tool.schema.parse(normalizedArgs);\n\n          // Apply any custom handler function preprocessing\n          const processedArgs = tool.handlerFunction ? await tool.handlerFunction(validatedArgs) : validatedArgs;\n\n          // Create handler instance and execute\n          const handler = new tool.handler();\n          return executeWithHandler(handler, processedArgs);\n        }\n      );\n  }\n}\n", "/**\n * Field mask builder for Google Calendar API partial response\n */\n\n// Allowed fields that can be requested from Google Calendar API\nexport const ALLOWED_EVENT_FIELDS = [\n  'id',\n  'summary',\n  'description',\n  'start',\n  'end',\n  'location',\n  'attendees',\n  'colorId',\n  'transparency',\n  'extendedProperties',\n  'reminders',\n  'conferenceData',\n  'attachments',\n  'status',\n  'htmlLink',\n  'created',\n  'updated',\n  'creator',\n  'organizer',\n  'recurrence',\n  'recurringEventId',\n  'originalStartTime',\n  'visibility',\n  'iCalUID',\n  'sequence',\n  'hangoutLink',\n  'anyoneCanAddSelf',\n  'guestsCanInviteOthers',\n  'guestsCanModify',\n  'guestsCanSeeOtherGuests',\n  'privateCopy',\n  'locked',\n  'source',\n  'eventType'\n] as const;\n\nexport type AllowedEventField = typeof ALLOWED_EVENT_FIELDS[number];\n\n// Default fields always included\nexport const DEFAULT_EVENT_FIELDS: AllowedEventField[] = [\n  'id',\n  'summary',\n  'start',\n  'end',\n  'status',\n  'htmlLink',\n  'location',\n  'attendees',\n  'reminders',\n  'recurrence'\n];\n\n/**\n * Validates that requested fields are allowed\n */\nexport function validateFields(fields: string[]): AllowedEventField[] {\n  const validFields: AllowedEventField[] = [];\n  const invalidFields: string[] = [];\n  \n  for (const field of fields) {\n    if (ALLOWED_EVENT_FIELDS.includes(field as AllowedEventField)) {\n      validFields.push(field as AllowedEventField);\n    } else {\n      invalidFields.push(field);\n    }\n  }\n  \n  if (invalidFields.length > 0) {\n    throw new Error(`Invalid fields requested: ${invalidFields.join(', ')}. Allowed fields: ${ALLOWED_EVENT_FIELDS.join(', ')}`);\n  }\n  \n  return validFields;\n}\n\n/**\n * Prepares and validates fields, combining with defaults if needed.\n * Returns undefined if no fields should be requested.\n */\nfunction prepareFields(\n  requestedFields?: string[],\n  includeDefaults: boolean = true\n): AllowedEventField[] | undefined {\n  if (!requestedFields || requestedFields.length === 0) {\n    return undefined;\n  }\n\n  const validFields = validateFields(requestedFields);\n\n  return includeDefaults\n    ? [...new Set([...DEFAULT_EVENT_FIELDS, ...validFields])]\n    : validFields;\n}\n\n/**\n * Builds a Google Calendar API field mask for partial response\n * @param requestedFields Optional array of additional fields to include\n * @param includeDefaults Whether to include default fields (default: true)\n * @returns Field mask string for Google Calendar API\n */\nexport function buildEventFieldMask(\n  requestedFields?: string[],\n  includeDefaults: boolean = true\n): string | undefined {\n  const fields = prepareFields(requestedFields, includeDefaults);\n  if (!fields) return undefined;\n\n  // Build the field mask for events.list: items(field1,field2,field3)\n  return `items(${fields.join(',')})`;\n}\n\n/**\n * Builds a field mask for a single event (events.get)\n */\nexport function buildSingleEventFieldMask(\n  requestedFields?: string[],\n  includeDefaults: boolean = true\n): string | undefined {\n  const fields = prepareFields(requestedFields, includeDefaults);\n  if (!fields) return undefined;\n\n  // For single event, just return comma-separated fields\n  return fields.join(',');\n}\n\n/**\n * Builds the full field mask parameter for list operations\n * Includes nextPageToken, nextSyncToken, etc.\n */\nexport function buildListFieldMask(\n  requestedFields?: string[],\n  includeDefaults: boolean = true\n): string | undefined {\n  // If no custom fields requested, return undefined for default response\n  if (!requestedFields || requestedFields.length === 0) {\n    return undefined;\n  }\n  \n  const eventFieldMask = buildEventFieldMask(requestedFields, includeDefaults);\n  if (!eventFieldMask) {\n    return undefined;\n  }\n  \n  // Include pagination tokens and other list metadata\n  return `${eventFieldMask},nextPageToken,nextSyncToken,kind,etag,summary,updated,timeZone,accessRole,defaultReminders`;\n}", "import { CallToolResult } from \"@modelcontextprotocol/sdk/types.js\";\nimport { McpError, ErrorCode } from \"@modelcontextprotocol/sdk/types.js\";\nimport { OAuth2Client } from \"google-auth-library\";\nimport { GaxiosError } from 'gaxios';\nimport { calendar_v3, google } from \"googleapis\";\nimport { getCredentialsProjectId } from \"../../auth/utils.js\";\nimport { CalendarRegistry } from \"../../services/CalendarRegistry.js\";\nimport { validateAccountId } from \"../../auth/paths.js\";\nimport { convertToRFC3339 } from \"../../utils/datetime.js\";\n\n\nexport abstract class BaseToolHandler<TArgs = any> {\n    protected calendarRegistry: CalendarRegistry = CalendarRegistry.getInstance();\n\n    abstract runTool(args: TArgs, accounts: Map<string, OAuth2Client>): Promise<CallToolResult>;\n\n    /**\n     * Normalize account ID to lowercase for case-insensitive matching\n     * @param accountId Account ID to normalize\n     * @returns Lowercase account ID\n     */\n    private normalizeAccountId(accountId: string): string {\n        return accountId.toLowerCase();\n    }\n\n    /**\n     * Get OAuth2Client for a specific account, or the first available account if none specified.\n     * Use this for read-only operations where any authenticated account will work.\n     * @param accountId Optional account ID. If not provided, uses first available account.\n     * @param accounts Map of available accounts\n     * @returns OAuth2Client for the specified or first account\n     * @throws McpError if account is invalid or not found\n     */\n    protected getClientForAccountOrFirst(accountId: string | undefined, accounts: Map<string, OAuth2Client>): OAuth2Client {\n        // No accounts available\n        if (accounts.size === 0) {\n            throw new McpError(\n                ErrorCode.InvalidRequest,\n                'No authenticated accounts available. Please run authentication first.'\n            );\n        }\n\n        // Account ID specified - validate and retrieve\n        if (accountId) {\n            const normalizedId = this.normalizeAccountId(accountId);\n            try {\n                validateAccountId(normalizedId);\n            } catch (error) {\n                throw new McpError(\n                    ErrorCode.InvalidRequest,\n                    error instanceof Error ? error.message : 'Invalid account ID'\n                );\n            }\n\n            const client = accounts.get(normalizedId);\n            if (!client) {\n                const availableAccounts = Array.from(accounts.keys()).join(', ');\n                throw new McpError(\n                    ErrorCode.InvalidRequest,\n                    `Account \"${normalizedId}\" not found. Available accounts: ${availableAccounts}`\n                );\n            }\n            return client;\n        }\n\n        // No account specified - use first available (sorted for consistency)\n        const sortedAccountIds = Array.from(accounts.keys()).sort();\n        const firstAccountId = sortedAccountIds[0];\n        const client = accounts.get(firstAccountId);\n        if (!client) {\n            throw new McpError(\n                ErrorCode.InternalError,\n                'Failed to retrieve OAuth client'\n            );\n        }\n        return client;\n    }\n\n    /**\n     * Get OAuth2Client for a specific account or determine default account\n     * @param accountId Optional account ID. If not provided, uses single account if available.\n     * @param accounts Map of available accounts\n     * @returns OAuth2Client for the specified or default account\n     * @throws McpError if account is invalid or not found\n     */\n    protected getClientForAccount(accountId: string | undefined, accounts: Map<string, OAuth2Client>): OAuth2Client {\n        // No accounts available\n        if (accounts.size === 0) {\n            throw new McpError(\n                ErrorCode.InvalidRequest,\n                'No authenticated accounts available. Please run authentication first.'\n            );\n        }\n\n        // Account ID specified - validate and retrieve\n        if (accountId) {\n            // Normalize to lowercase for case-insensitive matching\n            const normalizedId = this.normalizeAccountId(accountId);\n\n            // Validate account ID format (after normalization)\n            try {\n                validateAccountId(normalizedId);\n            } catch (error) {\n                throw new McpError(\n                    ErrorCode.InvalidRequest,\n                    error instanceof Error ? error.message : 'Invalid account ID'\n                );\n            }\n\n            // Get client for specified account\n            const client = accounts.get(normalizedId);\n            if (!client) {\n                const availableAccounts = Array.from(accounts.keys()).join(', ');\n                throw new McpError(\n                    ErrorCode.InvalidRequest,\n                    `Account \"${normalizedId}\" not found. Available accounts: ${availableAccounts}`\n                );\n            }\n\n            return client;\n        }\n\n        // No account specified - use default behavior\n        if (accounts.size === 1) {\n            // Single account - use it automatically\n            const firstClient = accounts.values().next().value;\n            if (!firstClient) {\n                throw new McpError(\n                    ErrorCode.InternalError,\n                    'Failed to retrieve OAuth client'\n                );\n            }\n            return firstClient;\n        }\n\n        // Multiple accounts but no account specified - error\n        const availableAccounts = Array.from(accounts.keys()).join(', ');\n        throw new McpError(\n            ErrorCode.InvalidRequest,\n            `Multiple accounts available (${availableAccounts}). You must specify the 'account' parameter to indicate which account to use.`\n        );\n    }\n\n    /**\n     * Get multiple OAuth2Clients for multi-account operations (e.g., list-events across accounts)\n     * @param accountIds Account ID(s) - string, string[], or undefined\n     * @param accounts Map of available accounts\n     * @returns Map of accountId to OAuth2Client for the specified accounts\n     * @throws McpError if any account is invalid or not found\n     */\n    protected getClientsForAccounts(\n        accountIds: string | string[] | undefined,\n        accounts: Map<string, OAuth2Client>\n    ): Map<string, OAuth2Client> {\n        // No accounts available\n        if (accounts.size === 0) {\n            throw new McpError(\n                ErrorCode.InvalidRequest,\n                'No authenticated accounts available. Please run authentication first.'\n            );\n        }\n\n        // Normalize to array\n        const ids = this.normalizeAccountIds(accountIds);\n\n        // If no specific accounts requested, use all available accounts\n        if (ids.length === 0) {\n            if (accounts.size === 1) {\n                // Single account - use it\n                return accounts;\n            }\n            // Multiple accounts - return all\n            return accounts;\n        }\n\n        // Validate and retrieve specified accounts\n        const result = new Map<string, OAuth2Client>();\n\n        for (const id of ids) {\n            // Normalize to lowercase for case-insensitive matching\n            const normalizedId = this.normalizeAccountId(id);\n\n            try {\n                validateAccountId(normalizedId);\n            } catch (error) {\n                throw new McpError(\n                    ErrorCode.InvalidRequest,\n                    error instanceof Error ? error.message : 'Invalid account ID'\n                );\n            }\n\n            const client = accounts.get(normalizedId);\n            if (!client) {\n                const availableAccounts = Array.from(accounts.keys()).join(', ');\n                throw new McpError(\n                    ErrorCode.InvalidRequest,\n                    `Account \"${normalizedId}\" not found. Available accounts: ${availableAccounts}`\n                );\n            }\n\n            result.set(normalizedId, client);\n        }\n\n        return result;\n    }\n\n    /**\n     * Get the best account to use for writing to a specific calendar\n     * Uses CalendarRegistry to find account with highest permissions\n     * @param calendarId Calendar ID\n     * @param accounts All available accounts\n     * @returns Account ID and client for the calendar, or null if no write access\n     */\n    protected async getAccountForCalendarWrite(\n        calendarId: string,\n        accounts: Map<string, OAuth2Client>\n    ): Promise<{ accountId: string; client: OAuth2Client } | null> {\n        return this.getAccountForCalendarAccess(calendarId, accounts, 'write');\n    }\n\n    /**\n     * Get the best account for a calendar depending on operation type\n     * @param calendarId Calendar ID\n     * @param accounts Available accounts\n     * @param operation 'read' or 'write'\n     */\n    protected async getAccountForCalendarAccess(\n        calendarId: string,\n        accounts: Map<string, OAuth2Client>,\n        operation: 'read' | 'write'\n    ): Promise<{ accountId: string; client: OAuth2Client } | null> {\n        // Fast path for single account - skip calendar registry lookup\n        if (accounts.size === 1) {\n            const entry = accounts.entries().next().value;\n            if (entry) {\n                const [accountId, client] = entry;\n                return { accountId, client };\n            }\n        }\n\n        // Multi-account case - use calendar registry for permission-based selection\n        const result = await this.calendarRegistry.getAccountForCalendar(\n            calendarId,\n            accounts,\n            operation\n        );\n\n        if (!result) {\n            return null;\n        }\n\n        const client = accounts.get(result.accountId);\n        if (!client) {\n            return null;\n        }\n\n        return {\n            accountId: result.accountId,\n            client\n        };\n    }\n\n    /**\n     * Convenience method to get a single OAuth2Client with automatic account selection.\n     * Handles the common pattern where:\n     * - If account is specified, use it\n     * - If no account specified, auto-select based on calendar permissions\n     *\n     * This eliminates repetitive boilerplate in handler implementations.\n     * Supports both calendar IDs and calendar names for resolution.\n     *\n     * @param accountId Optional account ID from args\n     * @param calendarNameOrId Calendar name or ID to check permissions for (if auto-selecting)\n     * @param accounts Map of available accounts\n     * @param operation 'read' or 'write' operation type\n     * @returns OAuth2Client, selected account ID, resolved calendar ID, and whether it was auto-selected\n     * @throws McpError if account not found or no suitable account available\n     */\n    protected async getClientWithAutoSelection(\n        accountId: string | undefined,\n        calendarNameOrId: string,\n        accounts: Map<string, OAuth2Client>,\n        operation: 'read' | 'write'\n    ): Promise<{ client: OAuth2Client; accountId: string; calendarId: string; wasAutoSelected: boolean }> {\n        // Account explicitly specified - use it\n        if (accountId) {\n            // Normalize account ID to lowercase\n            const normalizedAccountId = this.normalizeAccountId(accountId);\n            const client = this.getClientForAccount(normalizedAccountId, accounts);\n\n            // If calendar looks like a name (not ID), resolve it using this account\n            let resolvedCalendarId = calendarNameOrId;\n            if (calendarNameOrId !== 'primary' && !calendarNameOrId.includes('@')) {\n                resolvedCalendarId = await this.resolveCalendarId(client, calendarNameOrId);\n            }\n\n            return { client, accountId: normalizedAccountId, calendarId: resolvedCalendarId, wasAutoSelected: false };\n        }\n\n        // No account specified - use CalendarRegistry to resolve name and find best account\n        const resolution = await this.calendarRegistry.resolveCalendarNameToId(\n            calendarNameOrId,\n            accounts,\n            operation\n        );\n\n        if (!resolution) {\n            const availableAccounts = Array.from(accounts.keys()).join(', ');\n            const accessType = operation === 'write' ? 'write' : 'read';\n            throw new McpError(\n                ErrorCode.InvalidRequest,\n                `No account has ${accessType} access to calendar \"${calendarNameOrId}\". ` +\n                `Available accounts: ${availableAccounts}. Please ensure the calendar exists and ` +\n                `you have the necessary permissions, or specify the 'account' parameter explicitly.`\n            );\n        }\n\n        const client = accounts.get(resolution.accountId);\n        if (!client) {\n            throw new McpError(\n                ErrorCode.InternalError,\n                `Failed to retrieve client for account \"${resolution.accountId}\"`\n            );\n        }\n\n        return {\n            client,\n            accountId: resolution.accountId,\n            calendarId: resolution.calendarId,\n            wasAutoSelected: true\n        };\n    }\n\n    /**\n     * Normalize account parameter to array of account IDs\n     * @param accountIds string, string[], or undefined\n     * @returns Array of account IDs (empty array if undefined)\n     */\n    protected normalizeAccountIds(accountIds: string | string[] | undefined): string[] {\n        if (!accountIds) {\n            return [];\n        }\n        return Array.isArray(accountIds) ? accountIds : [accountIds];\n    }\n\n    protected handleGoogleApiError(error: unknown): never {\n        if (error instanceof GaxiosError) {\n            const status = error.response?.status;\n            const errorData = error.response?.data;\n\n            // Handle specific Google API errors with appropriate MCP error codes\n            if (errorData?.error === 'invalid_grant') {\n                throw new McpError(\n                    ErrorCode.InvalidRequest,\n                    'Authentication token is invalid or expired. Please re-run the authentication process (e.g., `npm run auth`).'\n                );\n            }\n\n            if (status === 400) {\n                // Extract detailed error information for Bad Request\n                const errorMessage = errorData?.error?.message;\n                const errorDetails = errorData?.error?.errors?.map((e: any) =>\n                    `${e.message || e.reason}${e.location ? ` (${e.location})` : ''}`\n                ).join('; ');\n\n                // Also include raw error data for debugging if details are missing\n                let fullMessage: string;\n                if (errorDetails) {\n                    fullMessage = `Bad Request: ${errorMessage || 'Invalid request parameters'}. Details: ${errorDetails}`;\n                } else if (errorMessage) {\n                    fullMessage = `Bad Request: ${errorMessage}`;\n                } else {\n                    // Include stringified error data for debugging\n                    const errorStr = JSON.stringify(errorData, null, 2);\n                    fullMessage = `Bad Request: Invalid request parameters. Raw error: ${errorStr}`;\n                }\n\n                throw new McpError(\n                    ErrorCode.InvalidRequest,\n                    fullMessage\n                );\n            }\n\n            if (status === 403) {\n                throw new McpError(\n                    ErrorCode.InvalidRequest,\n                    `Access denied: ${errorData?.error?.message || 'Insufficient permissions'}`\n                );\n            }\n\n            if (status === 404) {\n                throw new McpError(\n                    ErrorCode.InvalidRequest,\n                    `Resource not found: ${errorData?.error?.message || 'The requested calendar or event does not exist'}`\n                );\n            }\n\n            if (status === 429) {\n                const errorMessage = errorData?.error?.message || '';\n\n                // Provide specific guidance for quota-related rate limits\n                if (errorMessage.includes('User Rate Limit Exceeded')) {\n                    throw new McpError(\n                        ErrorCode.InvalidRequest,\n                        `Rate limit exceeded. This may be due to missing quota project configuration.\n\nEnsure your OAuth credentials include project_id information:\n1. Check that your gcp-oauth.keys.json file contains project_id\n2. Re-download credentials from Google Cloud Console if needed\n3. The file should have format: {\"installed\": {\"project_id\": \"your-project-id\", ...}}\n\nOriginal error: ${errorMessage}`\n                    );\n                }\n\n                throw new McpError(\n                    ErrorCode.InternalError,\n                    `Rate limit exceeded. Please try again later. ${errorMessage}`\n                );\n            }\n\n            if (status && status >= 500) {\n                throw new McpError(\n                    ErrorCode.InternalError,\n                    `Google API server error: ${errorData?.error?.message || error.message}`\n                );\n            }\n\n            // Generic Google API error with detailed information\n            const errorMessage = errorData?.error?.message || error.message;\n            const errorDetails = errorData?.error?.errors?.map((e: any) =>\n                `${e.message || e.reason}${e.location ? ` (${e.location})` : ''}`\n            ).join('; ');\n\n            const fullMessage = errorDetails\n                ? `Google API error: ${errorMessage}. Details: ${errorDetails}`\n                : `Google API error: ${errorMessage}`;\n\n            throw new McpError(\n                ErrorCode.InvalidRequest,\n                fullMessage\n            );\n        }\n\n        // Handle non-Google API errors\n        if (error instanceof Error) {\n            throw new McpError(\n                ErrorCode.InternalError,\n                `Internal error: ${error.message}`\n            );\n        }\n\n        throw new McpError(\n            ErrorCode.InternalError,\n            'An unknown error occurred'\n        );\n    }\n\n    protected getCalendar(auth: OAuth2Client): calendar_v3.Calendar {\n        // Try to get project ID from credentials file for quota project header\n        const quotaProjectId = getCredentialsProjectId();\n\n        const config: any = {\n            version: 'v3',\n            auth,\n            timeout: 3000 // 3 second timeout for API calls\n        };\n\n        // Add quota project ID if available\n        if (quotaProjectId) {\n            config.quotaProjectId = quotaProjectId;\n        }\n\n        return google.calendar(config);\n    }\n\n    protected async withTimeout<T>(promise: Promise<T>, timeoutMs: number = 30000): Promise<T> {\n        const timeoutPromise = new Promise<never>((_, reject) => {\n            setTimeout(() => reject(new Error(`Operation timed out after ${timeoutMs}ms`)), timeoutMs);\n        });\n\n        return Promise.race([promise, timeoutPromise]);\n    }\n\n    /**\n     * Combined setup for calendar operations that need both OAuth2Client and Calendar API.\n     * Returns the client, calendar instance, resolved calendar ID, and account ID in one call.\n     * Use this when you need immediate access to the calendar API in your handler.\n     *\n     * @param accountId Optional account ID from args\n     * @param calendarNameOrId Calendar name or ID\n     * @param accounts Map of available accounts\n     * @param operation 'read' or 'write' operation type\n     * @returns Object with client, calendar, accountId, and resolved calendarId\n     */\n    protected async setupOperation(\n        accountId: string | undefined,\n        calendarNameOrId: string,\n        accounts: Map<string, OAuth2Client>,\n        operation: 'read' | 'write'\n    ): Promise<{\n        client: OAuth2Client;\n        calendar: calendar_v3.Calendar;\n        accountId: string;\n        calendarId: string;\n    }> {\n        const { client, accountId: selectedAccountId, calendarId: resolvedCalendarId } =\n            await this.getClientWithAutoSelection(accountId, calendarNameOrId, accounts, operation);\n        const calendar = this.getCalendar(client);\n\n        return {\n            client,\n            calendar,\n            accountId: selectedAccountId,\n            calendarId: resolvedCalendarId\n        };\n    }\n\n    /**\n     * Gets calendar details including default timezone\n     * @param client OAuth2Client\n     * @param calendarId Calendar ID to fetch details for\n     * @returns Calendar details with timezone\n     */\n    protected async getCalendarDetails(client: OAuth2Client, calendarId: string): Promise<calendar_v3.Schema$CalendarListEntry> {\n        try {\n            const calendar = this.getCalendar(client);\n            const response = await calendar.calendarList.get({ calendarId });\n            if (!response.data) {\n                throw new Error(`Calendar ${calendarId} not found`);\n            }\n            return response.data;\n        } catch (error) {\n            throw this.handleGoogleApiError(error);\n        }\n    }\n\n    /**\n     * Gets the default timezone for a calendar, falling back to UTC if not available\n     * @param client OAuth2Client\n     * @param calendarId Calendar ID\n     * @returns Timezone string (IANA format)\n     */\n    protected async getCalendarTimezone(client: OAuth2Client, calendarId: string): Promise<string> {\n        try {\n            const calendarDetails = await this.getCalendarDetails(client, calendarId);\n            return calendarDetails.timeZone || 'UTC';\n        } catch (error) {\n            // If we can't get calendar details, fall back to UTC\n            return 'UTC';\n        }\n    }\n\n    /**\n     * Normalizes time range parameters to RFC3339 format for Google Calendar API.\n     * Determines timezone with precedence: explicit timeZone > calendar's default > UTC.\n     *\n     * @param client OAuth2Client\n     * @param calendarId Calendar ID (used to get default timezone if needed)\n     * @param timeMin Optional start of time range\n     * @param timeMax Optional end of time range\n     * @param timeZone Optional explicit timezone override\n     * @returns Normalized time range with resolved timezone\n     */\n    protected async normalizeTimeRange(\n        client: OAuth2Client,\n        calendarId: string,\n        timeMin?: string,\n        timeMax?: string,\n        timeZone?: string\n    ): Promise<{ timeMin?: string; timeMax?: string; timezone: string }> {\n        const timezone = timeZone || await this.getCalendarTimezone(client, calendarId);\n        return {\n            timeMin: timeMin ? convertToRFC3339(timeMin, timezone) : undefined,\n            timeMax: timeMax ? convertToRFC3339(timeMax, timezone) : undefined,\n            timezone\n        };\n    }\n\n    /**\n     * Resolves calendar name to calendar ID. If the input is already an ID, returns it unchanged.\n     * Supports both exact and case-insensitive name matching.\n     *\n     * Per Google Calendar API documentation:\n     * - Calendar IDs are typically email addresses (e.g., \"user@gmail.com\") or \"primary\" keyword\n     * - Calendar names are stored in \"summary\" field (calendar title) and \"summaryOverride\" field (user's personal override)\n     *\n     * Matching priority (user's personal override name takes precedence):\n     * 1. Exact match on summaryOverride\n     * 2. Case-insensitive match on summaryOverride\n     * 3. Exact match on summary\n     * 4. Case-insensitive match on summary\n     *\n     * This ensures if a user has set a personal override, it's always checked first (both exact and fuzzy),\n     * before falling back to the calendar's actual title.\n     *\n     * @param client OAuth2Client\n     * @param nameOrId Calendar name (summary/summaryOverride) or ID\n     * @returns Calendar ID\n     * @throws McpError if calendar name cannot be resolved\n     */\n    protected async resolveCalendarId(client: OAuth2Client, nameOrId: string): Promise<string> {\n        // If it looks like an ID (contains @ or is 'primary'), return as-is\n        if (nameOrId === 'primary' || nameOrId.includes('@')) {\n            return nameOrId;\n        }\n\n        // Try to resolve as a calendar name by fetching calendar list\n        try {\n            const calendar = this.getCalendar(client);\n            const response = await calendar.calendarList.list();\n            const calendars = response.data.items || [];\n\n            const lowerName = nameOrId.toLowerCase();\n\n            // Priority 1: Exact match on summaryOverride (user's personal name)\n            let match = calendars.find(cal => cal.summaryOverride === nameOrId);\n\n            // Priority 2: Case-insensitive match on summaryOverride\n            if (!match) {\n                match = calendars.find(cal =>\n                    cal.summaryOverride?.toLowerCase() === lowerName\n                );\n            }\n\n            // Priority 3: Exact match on summary (calendar's actual title)\n            if (!match) {\n                match = calendars.find(cal => cal.summary === nameOrId);\n            }\n\n            // Priority 4: Case-insensitive match on summary\n            if (!match) {\n                match = calendars.find(cal =>\n                    cal.summary?.toLowerCase() === lowerName\n                );\n            }\n\n            if (match && match.id) {\n                return match.id;\n            }\n\n            // Calendar name not found - provide helpful error message showing both summary and override\n            const availableCalendars = calendars\n                .map(cal => {\n                    if (cal.summaryOverride && cal.summaryOverride !== cal.summary) {\n                        return `\"${cal.summaryOverride}\" / \"${cal.summary}\" (${cal.id})`;\n                    }\n                    return `\"${cal.summary}\" (${cal.id})`;\n                })\n                .join(', ');\n\n            throw new McpError(\n                ErrorCode.InvalidRequest,\n                `Calendar \"${nameOrId}\" not found. Available calendars: ${availableCalendars || 'none'}. Use 'list-calendars' tool to see all available calendars.`\n            );\n        } catch (error) {\n            if (error instanceof McpError) {\n                throw error;\n            }\n            throw this.handleGoogleApiError(error);\n        }\n    }\n\n    /**\n     * Sorts events by start time (chronological order).\n     * Works with both regular events and extended events.\n     * Mutates the array in place and returns it for chaining.\n     */\n    protected sortEventsByStartTime<T extends calendar_v3.Schema$Event>(events: T[]): T[] {\n        return events.sort((a, b) => {\n            const aStart = a.start?.dateTime || a.start?.date || '';\n            const bStart = b.start?.dateTime || b.start?.date || '';\n            return aStart.localeCompare(bStart);\n        });\n    }\n\n    /**\n     * Throws an error when no calendars could be resolved from multi-account resolution.\n     * Provides a helpful error message listing available calendars.\n     */\n    protected async throwNoCalendarsFoundError(\n        requestedCalendars: string[],\n        selectedAccounts: Map<string, OAuth2Client>\n    ): Promise<never> {\n        const allCalendars = await this.calendarRegistry.getUnifiedCalendars(selectedAccounts);\n        const calendarList = allCalendars.map(c => `\"${c.displayName}\" (${c.calendarId})`).join(', ');\n        throw new McpError(\n            ErrorCode.InvalidRequest,\n            `None of the requested calendars could be found: ${requestedCalendars.map(c => `\"${c}\"`).join(', ')}. ` +\n            `Available calendars: ${calendarList || 'none'}. Use 'list-calendars' to see all available calendars.`\n        );\n    }\n\n    /**\n     * Resolves multiple calendar names/IDs to calendar IDs in batch.\n     * Fetches calendar list once for efficiency when resolving multiple calendars.\n     * Optimized to skip API call if all inputs are already IDs.\n     *\n     * Matching priority (user's personal override name takes precedence):\n     * 1. Exact match on summaryOverride\n     * 2. Case-insensitive match on summaryOverride\n     * 3. Exact match on summary\n     * 4. Case-insensitive match on summary\n     *\n     * @param client OAuth2Client\n     * @param namesOrIds Array of calendar names (summary/summaryOverride) or IDs\n     * @returns Array of resolved calendar IDs\n     * @throws McpError if any calendar name cannot be resolved\n     */\n    protected async resolveCalendarIds(client: OAuth2Client, namesOrIds: string[]): Promise<string[]> {\n        // Filter out empty/whitespace-only strings\n        const validInputs = namesOrIds.filter(item => item && item.trim().length > 0);\n\n        if (validInputs.length === 0) {\n            throw new McpError(\n                ErrorCode.InvalidRequest,\n                'At least one valid calendar identifier is required'\n            );\n        }\n\n        // Quick check: if all inputs look like IDs, skip the API call\n        const needsResolution = validInputs.some(item =>\n            item !== 'primary' && !item.includes('@')\n        );\n\n        if (!needsResolution) {\n            // All inputs are already IDs, return as-is\n            return validInputs;\n        }\n\n        // Batch resolve all calendars at once by fetching calendar list once\n        const calendar = this.getCalendar(client);\n        const response = await calendar.calendarList.list();\n        const calendars = response.data.items || [];\n\n        // Build name-to-ID mappings for efficient lookup\n        // Priority: summaryOverride takes precedence over summary\n        const overrideToIdMap = new Map<string, string>();\n        const summaryToIdMap = new Map<string, string>();\n        const lowerOverrideToIdMap = new Map<string, string>();\n        const lowerSummaryToIdMap = new Map<string, string>();\n\n        for (const cal of calendars) {\n            if (cal.id) {\n                if (cal.summaryOverride) {\n                    overrideToIdMap.set(cal.summaryOverride, cal.id);\n                    lowerOverrideToIdMap.set(cal.summaryOverride.toLowerCase(), cal.id);\n                }\n                if (cal.summary) {\n                    summaryToIdMap.set(cal.summary, cal.id);\n                    lowerSummaryToIdMap.set(cal.summary.toLowerCase(), cal.id);\n                }\n            }\n        }\n\n        const resolvedIds: string[] = [];\n        const errors: string[] = [];\n\n        for (const nameOrId of validInputs) {\n            // If it looks like an ID (contains @ or is 'primary'), use as-is\n            if (nameOrId === 'primary' || nameOrId.includes('@')) {\n                resolvedIds.push(nameOrId);\n                continue;\n            }\n\n            const lowerName = nameOrId.toLowerCase();\n\n            // Priority 1: Exact match on summaryOverride\n            let id = overrideToIdMap.get(nameOrId);\n\n            // Priority 2: Case-insensitive match on summaryOverride\n            if (!id) {\n                id = lowerOverrideToIdMap.get(lowerName);\n            }\n\n            // Priority 3: Exact match on summary\n            if (!id) {\n                id = summaryToIdMap.get(nameOrId);\n            }\n\n            // Priority 4: Case-insensitive match on summary\n            if (!id) {\n                id = lowerSummaryToIdMap.get(lowerName);\n            }\n\n            if (id) {\n                resolvedIds.push(id);\n            } else {\n                errors.push(nameOrId);\n            }\n        }\n\n        // If any calendars couldn't be resolved, throw error with helpful message\n        if (errors.length > 0) {\n            const availableCalendars = calendars\n                .map(cal => {\n                    if (cal.summaryOverride && cal.summaryOverride !== cal.summary) {\n                        return `\"${cal.summaryOverride}\" / \"${cal.summary}\" (${cal.id})`;\n                    }\n                    return `\"${cal.summary}\" (${cal.id})`;\n                })\n                .join(', ');\n\n            const errorMessage = `Calendar(s) not found: ${errors.map(e => `\"${e}\"`).join(', ')}. Available calendars: ${availableCalendars || 'none'}. Use 'list-calendars' tool to see all available calendars.`;\n\n            throw new McpError(\n                ErrorCode.InvalidRequest,\n                errorMessage\n            );\n        }\n\n        return resolvedIds;\n    }\n\n}\n", "import { OAuth2Client } from 'google-auth-library';\nimport { calendar_v3, google } from 'googleapis';\nimport { getCredentialsProjectId } from '../auth/utils.js';\n\n/**\n * Represents a calendar accessible from a specific account\n */\nexport interface CalendarAccess {\n  accountId: string;\n  accessRole: 'owner' | 'writer' | 'reader' | 'freeBusyReader';\n  primary: boolean;\n  summary: string;\n  summaryOverride?: string;\n}\n\n/**\n * Represents a unified view of a calendar across multiple accounts\n */\nexport interface UnifiedCalendar {\n  calendarId: string;\n  accounts: CalendarAccess[];\n  preferredAccount: string; // Account with highest permission\n  displayName: string; // Primary account's name (summaryOverride > summary)\n}\n\n/**\n * Permission ranking for calendar access\n */\nconst PERMISSION_RANK: Record<string, number> = {\n  'owner': 4,\n  'writer': 3,\n  'reader': 2,\n  'freeBusyReader': 1,\n};\n\n/**\n * CalendarRegistry service for managing calendar deduplication and permission-based account selection.\n * Implemented as a singleton to ensure cache is shared across all handlers\n * and can be properly invalidated when accounts change.\n */\nexport class CalendarRegistry {\n  private static instance: CalendarRegistry | null = null;\n\n  private cache: Map<string, { data: UnifiedCalendar[]; timestamp: number }> = new Map();\n  private readonly CACHE_TTL = 5 * 60 * 1000; // 5 minutes\n\n  // Track in-flight requests to prevent duplicate API calls during concurrent access\n  private inFlightRequests: Map<string, Promise<UnifiedCalendar[]>> = new Map();\n\n  /**\n   * Get the singleton instance of CalendarRegistry\n   */\n  static getInstance(): CalendarRegistry {\n    if (!CalendarRegistry.instance) {\n      CalendarRegistry.instance = new CalendarRegistry();\n    }\n    return CalendarRegistry.instance;\n  }\n\n  /**\n   * Reset the singleton instance (useful for testing or when accounts change)\n   * Clears the cache and resets the instance\n   */\n  static resetInstance(): void {\n    if (CalendarRegistry.instance) {\n      CalendarRegistry.instance.clearCache();\n    }\n    CalendarRegistry.instance = null;\n  }\n\n  /**\n   * Get calendar client for a specific account\n   */\n  private getCalendar(auth: OAuth2Client): calendar_v3.Calendar {\n    const quotaProjectId = getCredentialsProjectId();\n    const config: any = {\n      version: 'v3',\n      auth,\n      timeout: 3000\n    };\n    if (quotaProjectId) {\n      config.quotaProjectId = quotaProjectId;\n    }\n    return google.calendar(config);\n  }\n\n  /**\n   * Fetch all calendars from all accounts and build unified registry.\n   * Uses in-flight request tracking to prevent duplicate API calls during concurrent access.\n   */\n  async getUnifiedCalendars(accounts: Map<string, OAuth2Client>): Promise<UnifiedCalendar[]> {\n    const cacheKey = Array.from(accounts.keys()).sort().join(',');\n\n    // Check if there's already an in-flight request for this cache key\n    const inFlight = this.inFlightRequests.get(cacheKey);\n    if (inFlight) {\n      return inFlight;\n    }\n\n    // Check cache\n    const cached = this.cache.get(cacheKey);\n    if (cached && Date.now() - cached.timestamp < this.CACHE_TTL) {\n      return cached.data;\n    }\n\n    // Create new request and track it\n    const requestPromise = this.fetchAndBuildUnifiedCalendars(accounts, cacheKey);\n    this.inFlightRequests.set(cacheKey, requestPromise);\n\n    try {\n      return await requestPromise;\n    } finally {\n      // Remove from in-flight tracking once complete\n      this.inFlightRequests.delete(cacheKey);\n    }\n  }\n\n  /**\n   * Internal method to fetch calendars and build the unified registry\n   */\n  private async fetchAndBuildUnifiedCalendars(\n    accounts: Map<string, OAuth2Client>,\n    cacheKey: string\n  ): Promise<UnifiedCalendar[]> {\n    // Fetch calendars from all accounts in parallel\n    const calendarsByAccount = await Promise.all(\n      Array.from(accounts.entries()).map(async ([accountId, client]) => {\n        try {\n          const calendar = this.getCalendar(client);\n          const response = await calendar.calendarList.list();\n          return {\n            accountId,\n            calendars: response.data.items || []\n          };\n        } catch (error) {\n          // If one account fails, continue with others\n          return {\n            accountId,\n            calendars: [] as calendar_v3.Schema$CalendarListEntry[]\n          };\n        }\n      })\n    );\n\n    // Build calendar map: calendarId -> CalendarAccess[]\n    const calendarMap = new Map<string, CalendarAccess[]>();\n\n    for (const { accountId, calendars } of calendarsByAccount) {\n      for (const cal of calendars) {\n        if (!cal.id) continue;\n\n        const access: CalendarAccess = {\n          accountId,\n          accessRole: (cal.accessRole as CalendarAccess['accessRole']) || 'reader',\n          primary: cal.primary || false,\n          summary: cal.summary || cal.id,\n          summaryOverride: cal.summaryOverride ?? undefined\n        };\n\n        const existing = calendarMap.get(cal.id) || [];\n        existing.push(access);\n        calendarMap.set(cal.id, existing);\n      }\n    }\n\n    // Convert to UnifiedCalendar[]\n    const unified: UnifiedCalendar[] = Array.from(calendarMap.entries()).map(([calendarId, accounts]) => {\n      // Find preferred account (highest permission)\n      const sortedAccounts = [...accounts].sort((a, b) => {\n        const rankA = PERMISSION_RANK[a.accessRole] || 0;\n        const rankB = PERMISSION_RANK[b.accessRole] || 0;\n        return rankB - rankA; // Descending order\n      });\n\n      const preferredAccount = sortedAccounts[0].accountId;\n\n      // Determine display name (prefer primary account's override, then summary)\n      const primaryAccess = accounts.find(a => a.primary);\n      const preferredAccess = sortedAccounts[0];\n      const displayName =\n        primaryAccess?.summaryOverride ||\n        preferredAccess.summaryOverride ||\n        preferredAccess.summary;\n\n      return {\n        calendarId,\n        accounts,\n        preferredAccount,\n        displayName\n      };\n    });\n\n    // Cache results\n    this.cache.set(cacheKey, {\n      data: unified,\n      timestamp: Date.now()\n    });\n\n    return unified;\n  }\n\n  /**\n   * Find which account to use for a specific calendar\n   * For write operations, returns account with highest permission\n   * For read operations, returns any account with access (prefers higher permission)\n   */\n  async getAccountForCalendar(\n    calendarId: string,\n    accounts: Map<string, OAuth2Client>,\n    operationType: 'read' | 'write' = 'read'\n  ): Promise<{ accountId: string; accessRole: string } | null> {\n    const unified = await this.getUnifiedCalendars(accounts);\n    const calendar = unified.find(c => c.calendarId === calendarId);\n\n    if (!calendar) {\n      return null;\n    }\n\n    if (operationType === 'write') {\n      // For write operations, use account with highest permission\n      const preferredAccess = calendar.accounts.find(a => a.accountId === calendar.preferredAccount);\n      if (!preferredAccess) return null;\n\n      // Check if account has write permission\n      if (preferredAccess.accessRole === 'owner' || preferredAccess.accessRole === 'writer') {\n        return {\n          accountId: preferredAccess.accountId,\n          accessRole: preferredAccess.accessRole\n        };\n      }\n      return null; // No write access available\n    }\n\n    // For read operations, use preferred account (highest permission)\n    const preferredAccess = calendar.accounts.find(a => a.accountId === calendar.preferredAccount);\n    if (!preferredAccess) return null;\n\n    return {\n      accountId: preferredAccess.accountId,\n      accessRole: preferredAccess.accessRole\n    };\n  }\n\n  /**\n   * Get all accounts that have access to a specific calendar\n   */\n  async getAccountsForCalendar(\n    calendarId: string,\n    accounts: Map<string, OAuth2Client>\n  ): Promise<CalendarAccess[]> {\n    const unified = await this.getUnifiedCalendars(accounts);\n    const calendar = unified.find(c => c.calendarId === calendarId);\n    return calendar?.accounts || [];\n  }\n\n  /**\n   * Clear cache and in-flight requests (useful for testing or when accounts change)\n   */\n  clearCache(): void {\n    this.cache.clear();\n    this.inFlightRequests.clear();\n  }\n\n  /**\n   * Resolve a calendar name or ID to a calendar ID and preferred account\n   * Searches across all accounts for matching calendars by name\n   * Returns the account with highest permissions for the matched calendar\n   *\n   * @param nameOrId Calendar name (summary/summaryOverride) or ID\n   * @param accounts Map of available accounts\n   * @param operationType 'read' or 'write' operation type\n   * @returns Calendar ID and account info, or null if not found\n   */\n  async resolveCalendarNameToId(\n    nameOrId: string,\n    accounts: Map<string, OAuth2Client>,\n    operationType: 'read' | 'write' = 'read'\n  ): Promise<{ calendarId: string; accountId: string; accessRole: string } | null> {\n    // Special case: \"primary\" is an alias for each account's primary calendar\n    // When only one account exists, use it directly without registry lookup\n    if (nameOrId === 'primary') {\n      if (accounts.size === 1) {\n        const [accountId] = accounts.keys();\n        // Primary calendar always has owner access for the account owner\n        return { calendarId: 'primary', accountId, accessRole: 'owner' };\n      }\n      // Multiple accounts: try to find best match via registry\n      // Each account's primary calendar ID is typically the account email\n      const result = await this.getAccountForCalendar(nameOrId, accounts, operationType);\n      if (result) {\n        return { calendarId: nameOrId, ...result };\n      }\n      // If registry lookup fails with multiple accounts, use first account as fallback\n      // This maintains backwards compatibility while still working\n      const [firstAccountId] = accounts.keys();\n      return { calendarId: 'primary', accountId: firstAccountId, accessRole: 'owner' };\n    }\n\n    // If it looks like an ID (contains @), use getAccountForCalendar\n    if (nameOrId.includes('@')) {\n      const result = await this.getAccountForCalendar(nameOrId, accounts, operationType);\n      if (result) {\n        return { calendarId: nameOrId, ...result };\n      }\n      return null;\n    }\n\n    // It's a name - search across all calendars\n    const unified = await this.getUnifiedCalendars(accounts);\n    const lowerName = nameOrId.toLowerCase();\n\n    // Search for matching calendar by name\n    // Priority: exact summaryOverride > case-insensitive summaryOverride > exact summary > case-insensitive summary\n    let match: UnifiedCalendar | undefined;\n\n    // Priority 1: Exact match on any account's summaryOverride\n    match = unified.find(cal =>\n      cal.accounts.some(a => a.summaryOverride === nameOrId)\n    );\n\n    // Priority 2: Case-insensitive match on summaryOverride\n    if (!match) {\n      match = unified.find(cal =>\n        cal.accounts.some(a => a.summaryOverride?.toLowerCase() === lowerName)\n      );\n    }\n\n    // Priority 3: Exact match on displayName (primary account's name)\n    if (!match) {\n      match = unified.find(cal => cal.displayName === nameOrId);\n    }\n\n    // Priority 4: Case-insensitive match on displayName\n    if (!match) {\n      match = unified.find(cal => cal.displayName.toLowerCase() === lowerName);\n    }\n\n    // Priority 5: Exact match on any account's summary\n    if (!match) {\n      match = unified.find(cal =>\n        cal.accounts.some(a => a.summary === nameOrId)\n      );\n    }\n\n    // Priority 6: Case-insensitive match on summary\n    if (!match) {\n      match = unified.find(cal =>\n        cal.accounts.some(a => a.summary.toLowerCase() === lowerName)\n      );\n    }\n\n    if (!match) {\n      return null;\n    }\n\n    // Check write access if needed\n    if (operationType === 'write') {\n      const preferredAccess = match.accounts.find(a => a.accountId === match!.preferredAccount);\n      if (!preferredAccess || (preferredAccess.accessRole !== 'owner' && preferredAccess.accessRole !== 'writer')) {\n        return null; // No write access available\n      }\n      return {\n        calendarId: match.calendarId,\n        accountId: preferredAccess.accountId,\n        accessRole: preferredAccess.accessRole\n      };\n    }\n\n    // For read operations, return preferred account\n    const preferredAccess = match.accounts.find(a => a.accountId === match!.preferredAccount);\n    if (!preferredAccess) {\n      return null;\n    }\n\n    return {\n      calendarId: match.calendarId,\n      accountId: preferredAccess.accountId,\n      accessRole: preferredAccess.accessRole\n    };\n  }\n\n  /**\n   * Resolve multiple calendar names/IDs to their owning accounts.\n   * For each calendar, determines which account has access (using highest permission).\n   * Returns a routing map of accountId -> calendarIds for efficient multi-account queries.\n   *\n   * @param namesOrIds Array of calendar names or IDs to resolve\n   * @param accounts Map of available accounts\n   * @param options.restrictToAccounts Only resolve on these specific accounts (for strict mode)\n   * @returns Routing map and warnings for calendars not found\n   */\n  async resolveCalendarsToAccounts(\n    namesOrIds: string[],\n    accounts: Map<string, OAuth2Client>,\n    options?: { restrictToAccounts?: string[] }\n  ): Promise<{\n    resolved: Map<string, string[]>;  // accountId -> calendarIds for that account\n    warnings: string[];               // calendars not found on any account\n  }> {\n    const resolved = new Map<string, string[]>();\n    const warnings: string[] = [];\n\n    // Filter accounts if restricted\n    const availableAccounts = options?.restrictToAccounts\n      ? new Map(Array.from(accounts.entries()).filter(([id]) => options.restrictToAccounts!.includes(id)))\n      : accounts;\n\n    for (const nameOrId of namesOrIds) {\n      // Use existing resolution logic which finds the preferred (highest permission) account\n      const resolution = await this.resolveCalendarNameToId(nameOrId, availableAccounts, 'read');\n\n      if (!resolution) {\n        warnings.push(`Calendar \"${nameOrId}\" not found on any account`);\n        continue;\n      }\n\n      const { calendarId, accountId } = resolution;\n\n      // Add to routing map\n      const accountCalendars = resolved.get(accountId) || [];\n      if (!accountCalendars.includes(calendarId)) {\n        accountCalendars.push(calendarId);\n      }\n      resolved.set(accountId, accountCalendars);\n    }\n\n    return { resolved, warnings };\n  }\n}\n", "/**\n * Datetime utilities for Google Calendar MCP Server\n * Provides timezone handling and datetime conversion utilities\n */\n\n/**\n * Checks if a datetime string includes timezone information\n * @param datetime ISO 8601 datetime string\n * @returns True if timezone is included, false if timezone-naive\n */\nexport function hasTimezoneInDatetime(datetime: string): boolean {\n    return /^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(Z|[+-]\\d{2}:\\d{2})$/.test(datetime);\n}\n\n/**\n * Converts a flexible datetime string to RFC3339 format required by Google Calendar API\n * \n * Precedence rules:\n * 1. If datetime already has timezone info (Z or \u00B1HH:MM), use as-is\n * 2. If datetime is timezone-naive, interpret it as local time in fallbackTimezone and convert to UTC\n * \n * @param datetime ISO 8601 datetime string (with or without timezone)\n * @param fallbackTimezone Timezone to use if datetime is timezone-naive (IANA format)\n * @returns RFC3339 formatted datetime string in UTC\n */\nexport function convertToRFC3339(datetime: string, fallbackTimezone: string): string {\n    if (hasTimezoneInDatetime(datetime)) {\n        // Already has timezone, use as-is\n        return datetime;\n    } else {\n        // Timezone-naive, interpret as local time in fallbackTimezone and convert to UTC\n        try {\n            // Parse the datetime components\n            const match = datetime.match(/^(\\d{4})-(\\d{2})-(\\d{2})T(\\d{2}):(\\d{2}):(\\d{2})$/);\n            if (!match) {\n                throw new Error('Invalid datetime format');\n            }\n            \n            const [, year, month, day, hour, minute, second] = match.map(Number);\n            \n            // Create a temporary date in UTC to get the baseline\n            const utcDate = new Date(Date.UTC(year, month - 1, day, hour, minute, second));\n            \n            // Find what UTC time corresponds to the desired local time in the target timezone\n            // We do this by binary search approach or by using the timezone offset\n            const targetDate = convertLocalTimeToUTC(year, month - 1, day, hour, minute, second, fallbackTimezone);\n            \n            return targetDate.toISOString().replace(/\\.000Z$/, 'Z');\n        } catch (error) {\n            // Fallback: if timezone conversion fails, append Z for UTC\n            return datetime + 'Z';\n        }\n    }\n}\n\n/**\n * Convert a local time in a specific timezone to UTC\n */\nfunction convertLocalTimeToUTC(year: number, month: number, day: number, hour: number, minute: number, second: number, timezone: string): Date {\n    // Create a date that we'll use to find the correct UTC time\n    // Start with the assumption that it's in UTC\n    let testDate = new Date(Date.UTC(year, month, day, hour, minute, second));\n    \n    // Get what this UTC time looks like in the target timezone\n    const options: Intl.DateTimeFormatOptions = {\n        timeZone: timezone,\n        year: 'numeric',\n        month: '2-digit',\n        day: '2-digit',\n        hour: '2-digit',\n        minute: '2-digit',\n        second: '2-digit',\n        hour12: false\n    };\n    \n    // Format the test date in the target timezone\n    const formatter = new Intl.DateTimeFormat('sv-SE', options);\n    const formattedInTargetTZ = formatter.format(testDate);\n    \n    // Parse the formatted result to see what time it shows\n    const [datePart, timePart] = formattedInTargetTZ.split(' ');\n    const [targetYear, targetMonth, targetDay] = datePart.split('-').map(Number);\n    const [targetHour, targetMinute, targetSecond] = timePart.split(':').map(Number);\n    \n    // Calculate the difference between what we want and what we got\n    const wantedTime = new Date(year, month, day, hour, minute, second).getTime();\n    const actualTime = new Date(targetYear, targetMonth - 1, targetDay, targetHour, targetMinute, targetSecond).getTime();\n    const offsetMs = wantedTime - actualTime;\n    \n    // Adjust the UTC time by the offset\n    return new Date(testDate.getTime() + offsetMs);\n}\n\n/**\n * Creates a time object for Google Calendar API, handling both timezone-aware and timezone-naive datetime strings\n * Also handles all-day events by using 'date' field instead of 'dateTime'\n * @param datetime ISO 8601 datetime string (with or without timezone)\n * @param fallbackTimezone Timezone to use if datetime is timezone-naive (IANA format)\n * @returns Google Calendar API time object\n */\nexport function createTimeObject(datetime: string, fallbackTimezone: string): { dateTime?: string; date?: string; timeZone?: string } {\n    // Check if this is a date-only string (all-day event)\n    // Date-only format: YYYY-MM-DD (no time component)\n    if (!/T/.test(datetime)) {\n        // This is a date-only string, use the 'date' field for all-day event\n        return { date: datetime };\n    }\n    \n    // This is a datetime string with time component\n    if (hasTimezoneInDatetime(datetime)) {\n        // Timezone included in datetime - use as-is, no separate timeZone property needed\n        return { dateTime: datetime };\n    } else {\n        // Timezone-naive datetime - use fallback timezone\n        return { dateTime: datetime, timeZone: fallbackTimezone };\n    }\n}", "import { calendar_v3 } from 'googleapis';\n\n/**\n * Extended event type to include calendar ID and account ID for tracking source.\n * Used by handlers that need to track which calendar/account an event came from.\n */\nexport interface ExtendedEvent extends calendar_v3.Schema$Event {\n  calendarId: string;\n  accountId?: string;\n}\n\n/**\n * Represents a date/time value in Google Calendar API format\n */\nexport interface DateTime {\n  dateTime?: string;\n  date?: string;\n  timeZone?: string;\n}\n\n/**\n * Represents an event attendee with their response status and details\n */\nexport interface Attendee {\n  email: string;\n  displayName?: string;\n  responseStatus?: 'needsAction' | 'declined' | 'tentative' | 'accepted';\n  optional?: boolean;\n  organizer?: boolean;\n  self?: boolean;\n  resource?: boolean;\n  comment?: string;\n  additionalGuests?: number;\n}\n\n/**\n * Conference/meeting information for an event (e.g., Google Meet, Zoom)\n */\nexport interface ConferenceData {\n  conferenceId?: string;\n  conferenceSolution?: {\n    key?: { type?: string };\n    name?: string;\n    iconUri?: string;\n  };\n  entryPoints?: Array<{\n    entryPointType?: string;\n    uri?: string;\n    label?: string;\n    pin?: string;\n    accessCode?: string;\n    meetingCode?: string;\n    passcode?: string;\n    password?: string;\n  }>;\n  createRequest?: {\n    requestId?: string;\n    conferenceSolutionKey?: { type?: string };\n    status?: { statusCode?: string };\n  };\n  parameters?: {\n    addOnParameters?: {\n      parameters?: Record<string, string>;\n    };\n  };\n}\n\n/**\n * Custom key-value pairs for storing additional event metadata\n */\nexport interface ExtendedProperties {\n  private?: Record<string, string>;\n  shared?: Record<string, string>;\n}\n\n/**\n * Event reminder configuration\n */\nexport interface Reminder {\n  method: 'email' | 'popup';\n  minutes: number;\n}\n\n/**\n * Focus Time event properties (Google Workspace feature)\n */\nexport interface FocusTimeProperties {\n  autoDeclineMode?: 'declineNone' | 'declineAllConflictingInvitations' | 'declineOnlyNewConflictingInvitations';\n  chatStatus?: 'available' | 'doNotDisturb';\n  declineMessage?: string;\n}\n\n/**\n * Out of Office event properties (Google Workspace feature)\n */\nexport interface OutOfOfficeProperties {\n  autoDeclineMode?: 'declineNone' | 'declineAllConflictingInvitations' | 'declineOnlyNewConflictingInvitations';\n  declineMessage?: string;\n}\n\n/**\n * Working Location event properties (Google Workspace feature)\n */\nexport interface WorkingLocationProperties {\n  type?: 'homeOffice' | 'officeLocation' | 'customLocation';\n  homeOffice?: Record<string, unknown>;\n  officeLocation?: {\n    label?: string;\n    buildingId?: string;\n    floorId?: string;\n    floorSectionId?: string;\n    deskId?: string;\n  };\n  customLocation?: {\n    label?: string;\n  };\n}\n\n/**\n * Complete structured representation of a Google Calendar event\n */\nexport interface StructuredEvent {\n  id: string;\n  summary?: string;\n  description?: string;\n  location?: string;\n  start: DateTime;\n  end: DateTime;\n  /** Day of week for the start date/time (e.g., \"Monday\", \"Tuesday\") */\n  startDayOfWeek?: string;\n  /** Day of week for the end date/time (e.g., \"Monday\", \"Tuesday\") */\n  endDayOfWeek?: string;\n  status?: string;\n  htmlLink?: string;\n  created?: string;\n  updated?: string;\n  colorId?: string;\n  creator?: {\n    email?: string;\n    displayName?: string;\n    self?: boolean;\n  };\n  organizer?: {\n    email?: string;\n    displayName?: string;\n    self?: boolean;\n  };\n  attendees?: Attendee[];\n  recurrence?: string[];\n  recurringEventId?: string;\n  originalStartTime?: DateTime;\n  transparency?: 'opaque' | 'transparent';\n  visibility?: 'default' | 'public' | 'private' | 'confidential';\n  iCalUID?: string;\n  sequence?: number;\n  reminders?: {\n    useDefault?: boolean;\n    overrides?: Reminder[];\n  };\n  source?: {\n    url?: string;\n    title?: string;\n  };\n  attachments?: Array<{\n    fileUrl?: string;\n    title?: string;\n    mimeType?: string;\n    iconLink?: string;\n    fileId?: string;\n  }>;\n  eventType?: 'default' | 'outOfOffice' | 'focusTime' | 'workingLocation';\n  focusTimeProperties?: FocusTimeProperties;\n  outOfOfficeProperties?: OutOfOfficeProperties;\n  workingLocationProperties?: WorkingLocationProperties;\n  conferenceData?: ConferenceData;\n  extendedProperties?: ExtendedProperties;\n  hangoutLink?: string;\n  anyoneCanAddSelf?: boolean;\n  guestsCanInviteOthers?: boolean;\n  guestsCanModify?: boolean;\n  guestsCanSeeOtherGuests?: boolean;\n  privateCopy?: boolean;\n  locked?: boolean;\n  calendarId?: string;\n  accountId?: string;\n}\n\n/**\n * Information about a scheduling conflict with another event\n */\nexport interface ConflictInfo {\n  event: {\n    id: string;\n    title: string;\n    start: string;\n    end: string;\n    url?: string;\n    similarity?: number;\n  };\n  calendar: string;\n  overlap?: {\n    duration: string;\n    percentage: string;\n  };\n  suggestion?: string;\n}\n\n/**\n * Information about a potential duplicate event\n */\nexport interface DuplicateInfo {\n  event: {\n    id: string;\n    title: string;\n    start: string;\n    end: string;\n    url?: string;\n    similarity: number;\n  };\n  calendarId: string;\n  suggestion: string;\n}\n\n/**\n * Response format for listing calendar events\n */\nexport interface ListEventsResponse {\n  events: StructuredEvent[];\n  totalCount: number;\n  calendars?: string[];\n  accounts?: string[];\n  note?: string;\n  warnings?: string[];\n  partialFailures?: Array<{\n    accountId: string;\n    reason: string;\n  }>;\n}\n\n/**\n * Response format for searching calendar events\n */\nexport interface SearchEventsResponse {\n  events: StructuredEvent[];\n  totalCount: number;\n  query: string;\n  calendarId?: string;\n  calendars?: string[];\n  accounts?: string[];\n  timeRange?: {\n    start: string;\n    end: string;\n  };\n  warnings?: string[];\n}\n\n/**\n * Response format for getting a single event by ID\n */\nexport interface GetEventResponse {\n  event: StructuredEvent;\n}\n\n/**\n * Response format for creating a new event\n */\nexport interface CreateEventResponse {\n  event: StructuredEvent;\n  conflicts?: ConflictInfo[];\n  duplicates?: DuplicateInfo[];\n  warnings?: string[];\n}\n\n/**\n * Response format for updating an existing event\n */\nexport interface UpdateEventResponse {\n  event: StructuredEvent;\n  conflicts?: ConflictInfo[];\n  warnings?: string[];\n}\n\n/**\n * Response format for deleting an event\n */\nexport interface DeleteEventResponse {\n  success: boolean;\n  eventId: string;\n  calendarId: string;\n  message?: string;\n}\n\n/**\n * Response format for responding to an event invitation\n */\nexport interface RespondToEventResponse {\n  event: StructuredEvent;\n  responseStatus: 'accepted' | 'declined' | 'tentative' | 'needsAction';\n  sendUpdates: 'all' | 'externalOnly' | 'none';\n  message: string;\n}\n\n/**\n * Detailed information about a calendar\n */\nexport interface CalendarInfo {\n  id: string;\n  summary?: string;\n  description?: string;\n  location?: string;\n  timeZone?: string;\n  summaryOverride?: string;\n  colorId?: string;\n  backgroundColor?: string;\n  foregroundColor?: string;\n  hidden?: boolean;\n  selected?: boolean;\n  accessRole?: string;\n  defaultReminders?: Reminder[];\n  notificationSettings?: {\n    notifications?: Array<{\n      type?: string;\n      method?: string;\n    }>;\n  };\n  primary?: boolean;\n  deleted?: boolean;\n  conferenceProperties?: {\n    allowedConferenceSolutionTypes?: string[];\n  };\n  accountAccess?: Array<{\n    accountId: string;\n    accessRole: string;\n    primary: boolean;\n  }>;\n}\n\n/**\n * Response format for listing available calendars\n */\nexport interface ListCalendarsResponse {\n  calendars: CalendarInfo[];\n  totalCount: number;\n  note?: string;\n}\n\n/**\n * Color scheme definition with background and foreground colors\n */\nexport interface ColorDefinition {\n  background: string;\n  foreground: string;\n}\n\n/**\n * Response format for available calendar and event colors\n */\nexport interface ListColorsResponse {\n  event: Record<string, ColorDefinition>;\n  calendar: Record<string, ColorDefinition>;\n}\n\n/**\n * Represents a busy time period in free/busy queries\n */\nexport interface BusySlot {\n  start: string;\n  end: string;\n}\n\n/**\n * Response format for free/busy time queries\n */\nexport interface FreeBusyResponse {\n  timeMin: string;\n  timeMax: string;\n  calendars: Record<string, {\n    busy: BusySlot[];\n    errors?: Array<{\n      domain?: string;\n      reason?: string;\n    }>;\n  }>;\n}\n\n/**\n * Response format for getting the current time in a specific timezone\n */\nexport interface GetCurrentTimeResponse {\n  currentTime: string;\n  timezone: string;\n  offset: string;\n  isDST?: boolean;\n  /** Day of week for the current time (e.g., \"Monday\", \"Tuesday\") */\n  dayOfWeek: string;\n}\n\n/**\n * Response format for adding a new account via OAuth\n */\nexport interface AddAccountResponse {\n  status: 'awaiting_authentication' | 'already_authenticated' | 'error';\n  account_id: string;\n  auth_url?: string;\n  callback_url?: string;\n  instructions?: string;\n  expires_in_minutes?: number;\n  next_step?: string;\n  message?: string;\n  error?: string;\n}\n\n/**\n * Information about a single authenticated account\n */\nexport interface AccountInfo {\n  account_id: string;\n  status: 'active' | 'expired' | 'invalid' | 'error';\n  email?: string;\n  calendar_count?: number;\n  primary_calendar?: {\n    id: string;\n    name: string;\n    timezone: string;\n  };\n  token_expiry?: string;\n  error?: string;\n}\n\n/**\n * Response format for account status queries\n */\nexport interface AccountStatusResponse {\n  accounts: AccountInfo[];\n  total_accounts: number;\n  message?: string;\n}\n\n/**\n * Response format for removing an account\n */\nexport interface RemoveAccountResponse {\n  success: boolean;\n  account_id: string;\n  message: string;\n  remaining_accounts: string[];\n}\n\n/**\n * Derives the day of week from a date/time string.\n * Uses Intl.DateTimeFormat for reliable timezone-aware day-of-week calculation.\n * This prevents LLM hallucination of date-to-day mappings.\n *\n * Handles edge case where timeZone field is absent but dateTime contains an offset:\n * When dateTime is like \"2026-01-19T23:00:00-08:00\" without explicit timeZone,\n * we extract the local date directly from the ISO string to get the correct day.\n *\n * @param dateTimeOrDate - ISO 8601 dateTime string or YYYY-MM-DD date string\n * @param timeZone - Optional timezone for the calculation (defaults to UTC)\n * @returns Day of week name (e.g., \"Monday\", \"Tuesday\") or undefined if parsing fails\n */\nfunction getDayOfWeek(dateTimeOrDate: string | undefined | null, timeZone?: string | null): string | undefined {\n  if (!dateTimeOrDate) return undefined;\n\n  try {\n    // If no explicit timezone but the dateTime has an offset (e.g., -08:00, +05:30),\n    // extract the local date directly from the ISO string to derive correct day-of-week.\n    // This handles the edge case where Google returns dateTime with offset but no timeZone field.\n    if (!timeZone && /[+-]\\d{2}:\\d{2}$/.test(dateTimeOrDate)) {\n      const dateMatch = dateTimeOrDate.match(/^(\\d{4})-(\\d{2})-(\\d{2})/);\n      if (dateMatch) {\n        const [, year, month, day] = dateMatch;\n        // Create a date at noon UTC for the extracted date to avoid any DST edge cases\n        const localDate = new Date(Date.UTC(parseInt(year), parseInt(month) - 1, parseInt(day), 12, 0, 0));\n        if (!isNaN(localDate.getTime())) {\n          return new Intl.DateTimeFormat('en-US', {\n            weekday: 'long',\n            timeZone: 'UTC'\n          }).format(localDate);\n        }\n      }\n    }\n\n    const date = new Date(dateTimeOrDate);\n    if (isNaN(date.getTime())) return undefined;\n\n    return new Intl.DateTimeFormat('en-US', {\n      weekday: 'long',\n      timeZone: timeZone || 'UTC'\n    }).format(date);\n  } catch {\n    return undefined;\n  }\n}\n\n/**\n * Converts a Google Calendar API event to our structured format\n * @param event - The Google Calendar API event object\n * @param calendarId - Optional calendar ID to include in the response\n * @param accountId - Optional account ID to include in the response (for multi-account queries)\n * @returns Structured event representation\n */\nexport function convertGoogleEventToStructured(\n  event: calendar_v3.Schema$Event,\n  calendarId?: string,\n  accountId?: string\n): StructuredEvent {\n  return {\n    id: event.id || '',\n    summary: event.summary ?? undefined,\n    description: event.description ?? undefined,\n    location: event.location ?? undefined,\n    start: {\n      dateTime: event.start?.dateTime ?? undefined,\n      date: event.start?.date ?? undefined,\n      timeZone: event.start?.timeZone ?? undefined,\n    },\n    end: {\n      dateTime: event.end?.dateTime ?? undefined,\n      date: event.end?.date ?? undefined,\n      timeZone: event.end?.timeZone ?? undefined,\n    },\n    startDayOfWeek: getDayOfWeek(\n      event.start?.dateTime || event.start?.date,\n      event.start?.timeZone\n    ),\n    endDayOfWeek: getDayOfWeek(\n      event.end?.dateTime || event.end?.date,\n      event.end?.timeZone\n    ),\n    status: event.status ?? undefined,\n    htmlLink: event.htmlLink ?? undefined,\n    created: event.created ?? undefined,\n    updated: event.updated ?? undefined,\n    colorId: event.colorId ?? undefined,\n    creator: event.creator ? {\n      email: event.creator.email ?? '',\n      displayName: event.creator.displayName ?? undefined,\n      self: event.creator.self ?? undefined,\n    } : undefined,\n    organizer: event.organizer ? {\n      email: event.organizer.email ?? '',\n      displayName: event.organizer.displayName ?? undefined,\n      self: event.organizer.self ?? undefined,\n    } : undefined,\n    attendees: event.attendees?.map(a => ({\n      email: a.email || '',\n      displayName: a.displayName ?? undefined,\n      responseStatus: a.responseStatus as any,\n      optional: a.optional ?? undefined,\n      organizer: a.organizer ?? undefined,\n      self: a.self ?? undefined,\n      resource: a.resource ?? undefined,\n      comment: a.comment ?? undefined,\n      additionalGuests: a.additionalGuests ?? undefined,\n    })),\n    recurrence: event.recurrence ?? undefined,\n    recurringEventId: event.recurringEventId ?? undefined,\n    originalStartTime: event.originalStartTime ? {\n      dateTime: event.originalStartTime.dateTime ?? undefined,\n      date: event.originalStartTime.date ?? undefined,\n      timeZone: event.originalStartTime.timeZone ?? undefined,\n    } : undefined,\n    transparency: event.transparency as any,\n    visibility: event.visibility as any,\n    iCalUID: event.iCalUID ?? undefined,\n    sequence: event.sequence ?? undefined,\n    reminders: event.reminders ? {\n      useDefault: event.reminders.useDefault ?? undefined,\n      overrides: event.reminders.overrides?.map(r => ({\n        method: (r.method as any) || 'popup',\n        minutes: r.minutes || 0,\n      })),\n    } : undefined,\n    source: event.source ? {\n      url: event.source.url ?? undefined,\n      title: event.source.title ?? undefined,\n    } : undefined,\n    attachments: event.attachments?.map(a => ({\n      fileUrl: a.fileUrl ?? undefined,\n      title: a.title ?? undefined,\n      mimeType: a.mimeType ?? undefined,\n      iconLink: a.iconLink ?? undefined,\n      fileId: a.fileId ?? undefined,\n    })),\n    eventType: event.eventType as any,\n    focusTimeProperties: event.focusTimeProperties as FocusTimeProperties,\n    outOfOfficeProperties: event.outOfOfficeProperties as OutOfOfficeProperties,\n    workingLocationProperties: event.workingLocationProperties as WorkingLocationProperties,\n    conferenceData: event.conferenceData as ConferenceData,\n    extendedProperties: event.extendedProperties as ExtendedProperties,\n    hangoutLink: event.hangoutLink ?? undefined,\n    anyoneCanAddSelf: event.anyoneCanAddSelf ?? undefined,\n    guestsCanInviteOthers: event.guestsCanInviteOthers ?? undefined,\n    guestsCanModify: event.guestsCanModify ?? undefined,\n    guestsCanSeeOtherGuests: event.guestsCanSeeOtherGuests ?? undefined,\n    privateCopy: event.privateCopy ?? undefined,\n    locked: event.locked ?? undefined,\n    calendarId: calendarId,\n    accountId: accountId,\n  };\n}\n", "import { CallToolResult } from \"@modelcontextprotocol/sdk/types.js\";\nimport { ConflictCheckResult } from \"../services/conflict-detection/types.js\";\nimport {\n  ConflictInfo,\n  DuplicateInfo,\n  convertGoogleEventToStructured,\n  StructuredEvent\n} from \"../types/structured-responses.js\";\nimport { calendar_v3 } from \"googleapis\";\n\n/**\n * Creates a structured JSON response for MCP tools\n *\n * Note: We use compact JSON (no pretty-printing) because MCP clients\n * are expected to parse and display the JSON themselves. Pretty-printing\n * with escaped newlines (\\n) creates poor display in clients that show\n * the raw text.\n */\nexport function createStructuredResponse<T>(data: T): CallToolResult {\n  return {\n    content: [{\n      type: \"text\",\n      text: JSON.stringify(data)\n    }]\n  };\n}\n\n/**\n * Converts conflict check results to structured format\n */\nexport function convertConflictsToStructured(\n  conflicts: ConflictCheckResult\n): { conflicts?: ConflictInfo[]; duplicates?: DuplicateInfo[] } {\n  const result: { conflicts?: ConflictInfo[]; duplicates?: DuplicateInfo[] } = {};\n  \n  if (conflicts.duplicates.length > 0) {\n    result.duplicates = conflicts.duplicates.map(dup => {\n      // Get start and end from fullEvent if available\n      let start = '';\n      let end = '';\n      if (dup.fullEvent) {\n        start = dup.fullEvent.start?.dateTime || dup.fullEvent.start?.date || '';\n        end = dup.fullEvent.end?.dateTime || dup.fullEvent.end?.date || '';\n      }\n      \n      return {\n        event: {\n          id: dup.event.id || '',\n          title: dup.event.title,\n          start,\n          end,\n          url: dup.event.url,\n          similarity: dup.event.similarity\n        },\n        calendarId: dup.calendarId || '',\n        suggestion: dup.suggestion\n      };\n    });\n  }\n  \n  if (conflicts.conflicts.length > 0) {\n    result.conflicts = conflicts.conflicts.map(conflict => {\n      // Get start and end from either the event object or fullEvent\n      let start = conflict.event.start || '';\n      let end = conflict.event.end || '';\n      if (!start && conflict.fullEvent) {\n        start = conflict.fullEvent.start?.dateTime || conflict.fullEvent.start?.date || '';\n      }\n      if (!end && conflict.fullEvent) {\n        end = conflict.fullEvent.end?.dateTime || conflict.fullEvent.end?.date || '';\n      }\n      \n      return {\n        event: {\n          id: conflict.event.id || '',\n          title: conflict.event.title,\n          start,\n          end,\n          url: conflict.event.url,\n          similarity: conflict.similarity\n        },\n        calendar: conflict.calendar,\n        overlap: conflict.overlap ? {\n          duration: conflict.overlap.duration,\n          percentage: `${conflict.overlap.percentage}%`\n        } : undefined\n      };\n    });\n  }\n  \n  return result;\n}\n\n/**\n * Converts an array of Google Calendar events to structured format\n */\nexport function convertEventsToStructured(\n  events: calendar_v3.Schema$Event[],\n  calendarId?: string,\n  accountId?: string\n): StructuredEvent[] {\n  return events.map(event => convertGoogleEventToStructured(event, calendarId, accountId));\n}\n\n/**\n * Helper to add calendar ID to events\n */\nexport function addCalendarIdToEvents(\n  events: calendar_v3.Schema$Event[],\n  calendarId: string\n): StructuredEvent[] {\n  return events.map(event => ({\n    ...convertGoogleEventToStructured(event),\n    calendarId\n  }));\n}\n\n/**\n * Formats free/busy information into structured format\n */\nexport function formatFreeBusyStructured(\n  freeBusy: any,\n  timeMin: string,\n  timeMax: string\n): {\n  timeMin: string;\n  timeMax: string;\n  calendars: Record<string, {\n    busy: Array<{ start: string; end: string }>;\n    errors?: Array<{ domain?: string; reason?: string }>;\n  }>;\n} {\n  const calendars: Record<string, any> = {};\n  \n  if (freeBusy.calendars) {\n    for (const [calId, calData] of Object.entries(freeBusy.calendars) as [string, any][]) {\n      calendars[calId] = {\n        busy: calData.busy?.map((slot: any) => ({\n          start: slot.start,\n          end: slot.end\n        })) || []\n      };\n      \n      if (calData.errors?.length > 0) {\n        calendars[calId].errors = calData.errors;\n      }\n    }\n  }\n  \n  return {\n    timeMin,\n    timeMax,\n    calendars\n  };\n}\n\n/**\n * Converts calendar list to structured format\n */\nexport function convertCalendarsToStructured(\n  calendars: calendar_v3.Schema$CalendarListEntry[]\n): Array<{\n  id: string;\n  summary?: string;\n  description?: string;\n  location?: string;\n  timeZone?: string;\n  summaryOverride?: string;\n  colorId?: string;\n  backgroundColor?: string;\n  foregroundColor?: string;\n  hidden?: boolean;\n  selected?: boolean;\n  accessRole?: string;\n  defaultReminders?: Array<{ method: 'email' | 'popup'; minutes: number }>;\n  notificationSettings?: {\n    notifications?: Array<{ type?: string; method?: string }>;\n  };\n  primary?: boolean;\n  deleted?: boolean;\n  conferenceProperties?: {\n    allowedConferenceSolutionTypes?: string[];\n  };\n}> {\n  return calendars.map(cal => ({\n    id: cal.id || '',\n    summary: cal.summary ?? undefined,\n    description: cal.description ?? undefined,\n    location: cal.location ?? undefined,\n    timeZone: cal.timeZone ?? undefined,\n    summaryOverride: cal.summaryOverride ?? undefined,\n    colorId: cal.colorId ?? undefined,\n    backgroundColor: cal.backgroundColor ?? undefined,\n    foregroundColor: cal.foregroundColor ?? undefined,\n    hidden: cal.hidden ?? undefined,\n    selected: cal.selected ?? undefined,\n    accessRole: cal.accessRole ?? undefined,\n    defaultReminders: cal.defaultReminders?.map(r => ({\n      method: (r.method as 'email' | 'popup') || 'popup',\n      minutes: r.minutes || 0\n    })),\n    notificationSettings: cal.notificationSettings ? {\n      notifications: cal.notificationSettings.notifications?.map(n => ({\n        type: n.type ?? undefined,\n        method: n.method ?? undefined\n      }))\n    } : undefined,\n    primary: cal.primary ?? undefined,\n    deleted: cal.deleted ?? undefined,\n    conferenceProperties: cal.conferenceProperties ? {\n      allowedConferenceSolutionTypes: cal.conferenceProperties.allowedConferenceSolutionTypes ?? undefined\n    } : undefined\n  }));\n}\n\n/**\n * Creates a warning message for conflicts/duplicates\n */\nexport function createWarningsArray(conflicts?: ConflictCheckResult): string[] | undefined {\n  if (!conflicts || !conflicts.hasConflicts) {\n    return undefined;\n  }\n  \n  const warnings: string[] = [];\n  \n  if (conflicts.duplicates.length > 0) {\n    warnings.push(`Found ${conflicts.duplicates.length} potential duplicate(s)`);\n  }\n  \n  if (conflicts.conflicts.length > 0) {\n    warnings.push(`Found ${conflicts.conflicts.length} scheduling conflict(s)`);\n  }\n  \n  return warnings.length > 0 ? warnings : undefined;\n}", "import { CallToolResult } from \"@modelcontextprotocol/sdk/types.js\";\nimport { OAuth2Client } from \"google-auth-library\";\nimport { BaseToolHandler } from \"./BaseToolHandler.js\";\nimport { calendar_v3 } from \"googleapis\";\nimport { ListCalendarsResponse } from \"../../types/structured-responses.js\";\nimport { createStructuredResponse } from \"../../utils/response-builder.js\";\n\nexport class ListCalendarsHandler extends BaseToolHandler {\n    async runTool(args: any, accounts: Map<string, OAuth2Client>): Promise<CallToolResult> {\n        // Get clients for specified accounts (or all if not specified)\n        const selectedAccounts = this.getClientsForAccounts(args.account, accounts);\n\n        // Fetch full calendar details from each account\n        const calendarsPerAccount = await Promise.all(\n            Array.from(selectedAccounts.entries()).map(async ([accountId, client]) => {\n                const calendars = await this.listCalendars(client);\n                return calendars.map(cal => ({ ...cal, _accountId: accountId }));\n            })\n        );\n\n        const allCalendars = calendarsPerAccount.flat();\n\n        // Use CalendarRegistry for deduplication if multiple accounts\n        if (selectedAccounts.size > 1) {\n            const unifiedCalendars = await this.calendarRegistry.getUnifiedCalendars(selectedAccounts);\n\n            const response: ListCalendarsResponse = {\n                calendars: unifiedCalendars.map(unified => {\n                    // Find the full calendar entry from preferred account\n                    const preferredCal = allCalendars.find(\n                        cal => cal.id === unified.calendarId && (cal as any)._accountId === unified.preferredAccount\n                    )!;\n\n                    return {\n                        ...this.convertCalendarToStructured(preferredCal, unified.calendarId),\n                        accountAccess: unified.accounts.map(a => ({\n                            accountId: a.accountId,\n                            accessRole: a.accessRole,\n                            primary: a.primary\n                        }))\n                    };\n                }),\n                totalCount: unifiedCalendars.length,\n                note: `Showing deduplicated calendars across ${selectedAccounts.size} account(s). Calendars accessible from multiple accounts show all access levels in 'accountAccess' field.`\n            };\n\n            return createStructuredResponse(response);\n        }\n\n        // Single account - no deduplication needed\n        const response: ListCalendarsResponse = {\n            calendars: allCalendars.map(cal => this.convertCalendarToStructured(cal)),\n            totalCount: allCalendars.length\n        };\n\n        return createStructuredResponse(response);\n    }\n\n    private convertCalendarToStructured(cal: calendar_v3.Schema$CalendarListEntry, idOverride?: string) {\n        return {\n            id: idOverride || cal.id || '',\n            summary: cal.summary ?? undefined,\n            description: cal.description ?? undefined,\n            location: cal.location ?? undefined,\n            timeZone: cal.timeZone ?? undefined,\n            summaryOverride: cal.summaryOverride ?? undefined,\n            colorId: cal.colorId ?? undefined,\n            backgroundColor: cal.backgroundColor ?? undefined,\n            foregroundColor: cal.foregroundColor ?? undefined,\n            hidden: cal.hidden ?? undefined,\n            selected: cal.selected ?? undefined,\n            accessRole: cal.accessRole ?? undefined,\n            defaultReminders: cal.defaultReminders?.map(r => ({\n                method: (r.method as 'email' | 'popup') || 'popup',\n                minutes: r.minutes || 0\n            })),\n            notificationSettings: cal.notificationSettings ? {\n                notifications: cal.notificationSettings.notifications?.map(n => ({\n                    type: n.type ?? undefined,\n                    method: n.method ?? undefined\n                }))\n            } : undefined,\n            primary: cal.primary ?? undefined,\n            deleted: cal.deleted ?? undefined,\n            conferenceProperties: cal.conferenceProperties ? {\n                allowedConferenceSolutionTypes: cal.conferenceProperties.allowedConferenceSolutionTypes ?? undefined\n            } : undefined\n        };\n    }\n\n    private async listCalendars(client: OAuth2Client): Promise<calendar_v3.Schema$CalendarListEntry[]> {\n        try {\n            const calendar = this.getCalendar(client);\n            const response = await calendar.calendarList.list();\n            return response.data.items || [];\n        } catch (error) {\n            throw this.handleGoogleApiError(error);\n        }\n    }\n}\n", "import { OAuth2Client } from \"google-auth-library\";\n\nexport interface BatchRequest {\n  method: string;\n  path: string;\n  headers?: Record<string, string>;\n  body?: any;\n}\n\nexport interface BatchResponse {\n  statusCode: number;\n  headers: Record<string, string>;\n  body: any;\n  error?: any;\n}\n\nexport interface BatchError {\n  calendarId?: string;\n  statusCode: number;\n  message: string;\n  details?: any;\n}\n\nexport class BatchRequestError extends Error {\n  constructor(\n    message: string,\n    public errors: BatchError[],\n    public partial: boolean = false\n  ) {\n    super(message);\n    this.name = 'BatchRequestError';\n  }\n}\n\nexport class BatchRequestHandler {\n  private readonly batchEndpoint = \"https://www.googleapis.com/batch/calendar/v3\";\n  private readonly boundary: string;\n  private readonly maxRetries = 3;\n  private readonly baseDelay = 1000; // 1 second\n\n  constructor(private auth: OAuth2Client) {\n    this.boundary = \"batch_boundary_\" + Date.now();\n  }\n\n  async executeBatch(requests: BatchRequest[]): Promise<BatchResponse[]> {\n    if (requests.length === 0) {\n      return [];\n    }\n\n    if (requests.length > 50) {\n      throw new Error('Batch requests cannot exceed 50 requests per batch');\n    }\n\n    return this.executeBatchWithRetry(requests, 0);\n  }\n\n  private async executeBatchWithRetry(requests: BatchRequest[], attempt: number): Promise<BatchResponse[]> {\n    try {\n      const batchBody = this.createBatchBody(requests);\n      const token = await this.auth.getAccessToken();\n      \n      const response = await fetch(this.batchEndpoint, {\n        method: \"POST\",\n        headers: {\n          \"Authorization\": `Bearer ${token.token}`,\n          \"Content-Type\": `multipart/mixed; boundary=${this.boundary}`\n        },\n        body: batchBody\n      });\n\n      const responseText = await response.text();\n\n      // Handle rate limiting with retry\n      if (response.status === 429 && attempt < this.maxRetries) {\n        const retryAfter = response.headers.get('Retry-After');\n        const delay = retryAfter ? parseInt(retryAfter) * 1000 : this.baseDelay * Math.pow(2, attempt);\n        \n        process.stderr.write(`Rate limited, retrying after ${delay}ms (attempt ${attempt + 1}/${this.maxRetries})\\n`);\n        await this.sleep(delay);\n        return this.executeBatchWithRetry(requests, attempt + 1);\n      }\n\n      if (!response.ok) {\n        throw new BatchRequestError(\n          `Batch request failed: ${response.status} ${response.statusText}`,\n          [{\n            statusCode: response.status,\n            message: `HTTP ${response.status}: ${response.statusText}`,\n            details: responseText\n          }]\n        );\n      }\n\n      return this.parseBatchResponse(responseText);\n    } catch (error) {\n      if (error instanceof BatchRequestError) {\n        throw error;\n      }\n      \n      // Retry on network errors\n      if (attempt < this.maxRetries && this.isRetryableError(error)) {\n        const delay = this.baseDelay * Math.pow(2, attempt);\n        process.stderr.write(`Network error, retrying after ${delay}ms (attempt ${attempt + 1}/${this.maxRetries}): ${error instanceof Error ? error.message : 'Unknown error'}\\n`);\n        await this.sleep(delay);\n        return this.executeBatchWithRetry(requests, attempt + 1);\n      }\n      \n      // Handle network or auth errors\n      throw new BatchRequestError(\n        `Failed to execute batch request: ${error instanceof Error ? error.message : 'Unknown error'}`,\n        [{\n          statusCode: 0,\n          message: error instanceof Error ? error.message : 'Unknown error',\n          details: error\n        }]\n      );\n    }\n  }\n\n  private isRetryableError(error: any): boolean {\n    if (error instanceof Error) {\n      const message = error.message.toLowerCase();\n      return message.includes('network') || \n             message.includes('timeout') || \n             message.includes('econnreset') ||\n             message.includes('enotfound');\n    }\n    return false;\n  }\n\n  private sleep(ms: number): Promise<void> {\n    return new Promise(resolve => setTimeout(resolve, ms));\n  }\n\n  private createBatchBody(requests: BatchRequest[]): string {\n    return requests.map((req, index) => {\n      const parts = [\n        `--${this.boundary}`,\n        `Content-Type: application/http`,\n        `Content-ID: <item${index + 1}>`,\n        \"\",\n        `${req.method} ${req.path} HTTP/1.1`\n      ];\n\n      if (req.headers) {\n        Object.entries(req.headers).forEach(([key, value]) => {\n          parts.push(`${key}: ${value}`);\n        });\n      }\n\n      if (req.body) {\n        parts.push(\"Content-Type: application/json\");\n        parts.push(\"\");\n        parts.push(JSON.stringify(req.body));\n      }\n\n      return parts.join(\"\\r\\n\");\n    }).join(\"\\r\\n\\r\\n\") + `\\r\\n--${this.boundary}--`;\n  }\n\n  private parseBatchResponse(responseText: string): BatchResponse[] {\n    // First, try to find boundary from Content-Type header in the response\n    // Google's responses typically have boundary in the first few lines\n    const lines = responseText.split(/\\r?\\n/);\n    let boundary = null;\n    \n    // Look for Content-Type header with boundary in the first few lines\n    for (let i = 0; i < Math.min(10, lines.length); i++) {\n      const line = lines[i];\n      if (line.toLowerCase().includes('content-type:') && line.includes('boundary=')) {\n        const boundaryMatch = line.match(/boundary=([^\\s\\r\\n;]+)/);\n        if (boundaryMatch) {\n          boundary = boundaryMatch[1];\n          break;\n        }\n      }\n    }\n    \n    // If not found in headers, try to find boundary markers in the content\n    if (!boundary) {\n      const boundaryMatch = responseText.match(/--([a-zA-Z0-9_-]+)/);\n      if (boundaryMatch) {\n        boundary = boundaryMatch[1];\n      }\n    }\n    \n    if (!boundary) {\n      throw new Error('Could not find boundary in batch response');\n    }\n    \n    // Split by boundary markers\n    const parts = responseText.split(`--${boundary}`);\n    \n    const responses: BatchResponse[] = [];\n    \n    // Skip the first part (before the first boundary) and the last part (after final boundary with --)\n    for (let i = 1; i < parts.length; i++) {\n      const part = parts[i];\n      \n      // Skip empty parts or the final boundary marker\n      if (part.trim() === '' || part.trim() === '--' || part.trim().startsWith('--')) continue;\n      \n      const response = this.parseResponsePart(part);\n      if (response) {\n        responses.push(response);\n      }\n    }\n    \n    return responses;\n  }\n\n  private parseResponsePart(part: string): BatchResponse | null {\n    // Handle both \\r\\n and \\n line endings\n    const lines = part.split(/\\r?\\n/);\n    \n    // Find the HTTP response line (look for \"HTTP/1.1\")\n    let httpLineIndex = -1;\n    for (let i = 0; i < lines.length; i++) {\n      if (lines[i].startsWith('HTTP/1.1')) {\n        httpLineIndex = i;\n        break;\n      }\n    }\n\n    if (httpLineIndex === -1) return null;\n\n    // Parse status code from HTTP response line\n    const httpLine = lines[httpLineIndex];\n    const statusMatch = httpLine.match(/HTTP\\/1\\.1 (\\d+)/);\n    if (!statusMatch) return null;\n    \n    const statusCode = parseInt(statusMatch[1]);\n\n    // Parse response headers (start after HTTP line, stop at empty line)\n    const headers: Record<string, string> = {};\n    let bodyStartIndex = httpLineIndex + 1;\n    \n    for (let i = httpLineIndex + 1; i < lines.length; i++) {\n      const line = lines[i];\n      if (line.trim() === '') {\n        bodyStartIndex = i + 1;\n        break;\n      }\n      \n      const colonIndex = line.indexOf(':');\n      if (colonIndex > 0) {\n        const key = line.substring(0, colonIndex).trim();\n        const value = line.substring(colonIndex + 1).trim();\n        headers[key] = value;\n      }\n    }\n\n    // Parse body - everything after the empty line following headers\n    let body: any = null;\n    if (bodyStartIndex < lines.length) {\n      // Collect all body lines, filtering out empty lines at the end\n      const bodyLines = [];\n      for (let i = bodyStartIndex; i < lines.length; i++) {\n        bodyLines.push(lines[i]);\n      }\n      \n      // Remove trailing empty lines\n      while (bodyLines.length > 0 && bodyLines[bodyLines.length - 1].trim() === '') {\n        bodyLines.pop();\n      }\n      \n      if (bodyLines.length > 0) {\n        const bodyText = bodyLines.join('\\n');\n        if (bodyText.trim()) {\n          try {\n            body = JSON.parse(bodyText);\n          } catch {\n            // If JSON parsing fails, return the raw text\n            body = bodyText;\n          }\n        }\n      }\n    }\n\n    return {\n      statusCode,\n      headers,\n      body\n    };\n  }\n} ", "import { CallToolResult } from \"@modelcontextprotocol/sdk/types.js\";\nimport { OAuth2Client } from \"google-auth-library\";\nimport { BaseToolHandler } from \"./BaseToolHandler.js\";\nimport { calendar_v3 } from 'googleapis';\nimport { BatchRequestHandler } from \"./BatchRequestHandler.js\";\nimport { buildListFieldMask } from \"../../utils/field-mask-builder.js\";\nimport { createStructuredResponse } from \"../../utils/response-builder.js\";\nimport { ListEventsResponse, StructuredEvent, convertGoogleEventToStructured, ExtendedEvent } from \"../../types/structured-responses.js\";\n\ninterface ListEventsArgs {\n  calendarId: string | string[];\n  timeMin?: string;\n  timeMax?: string;\n  timeZone?: string;\n  fields?: string[];\n  privateExtendedProperty?: string[];\n  sharedExtendedProperty?: string[];\n  account?: string | string[];\n}\n\nexport class ListEventsHandler extends BaseToolHandler {\n    async runTool(args: ListEventsArgs, accounts: Map<string, OAuth2Client>): Promise<CallToolResult> {\n        // Get clients for specified accounts (supports single or multiple)\n        const selectedAccounts = this.getClientsForAccounts(args.account, accounts);\n        const partialFailures: Array<{ accountId: string; reason: string }> = [];\n        const resolutionWarnings: string[] = [];\n\n        // Normalize calendarId to always be an array for consistent processing\n        const calendarNamesOrIds = Array.isArray(args.calendarId)\n            ? args.calendarId\n            : [args.calendarId];\n\n        // For multi-account queries, pre-resolve calendars to their owning accounts\n        // This prevents \"calendar not found\" errors when a calendar only exists on some accounts\n        let accountCalendarMap: Map<string, string[]>;\n\n        if (selectedAccounts.size > 1) {\n            // Multi-account: route calendars to their owning accounts using CalendarRegistry\n            const { resolved, warnings } = await this.calendarRegistry.resolveCalendarsToAccounts(\n                calendarNamesOrIds,\n                selectedAccounts\n            );\n            accountCalendarMap = resolved;\n            resolutionWarnings.push(...warnings);\n\n            // If no calendars could be resolved on any account, throw error\n            if (accountCalendarMap.size === 0) {\n                await this.throwNoCalendarsFoundError(calendarNamesOrIds, selectedAccounts);\n            }\n        } else {\n            // Single account: use existing per-account resolution (strict mode)\n            // All calendars go to the single account - will error if not found\n            const [accountId] = selectedAccounts.keys();\n            accountCalendarMap = new Map([[accountId, calendarNamesOrIds]]);\n        }\n\n        // Fetch events from accounts that have matching calendars\n        const eventsPerAccount = await Promise.all(\n            Array.from(accountCalendarMap.entries()).map(async ([accountId, calendarsForAccount]) => {\n                const client = selectedAccounts.get(accountId)!;\n                try {\n                    // For single-account, resolve names to IDs (strict mode)\n                    // For multi-account, calendars are already resolved IDs\n                    const calendarIds = selectedAccounts.size === 1\n                        ? await this.resolveCalendarIds(client, calendarsForAccount)\n                        : calendarsForAccount;\n\n                    const events = await this.fetchEvents(client, calendarIds, {\n                        timeMin: args.timeMin,\n                        timeMax: args.timeMax,\n                        timeZone: args.timeZone,\n                        fields: args.fields,\n                        privateExtendedProperty: args.privateExtendedProperty,\n                        sharedExtendedProperty: args.sharedExtendedProperty\n                    });\n\n                    // Tag events with account ID and return metadata\n                    return {\n                        accountId,\n                        calendarIds,\n                        events: events.map(event => ({ ...event, accountId }))\n                    };\n                } catch (error) {\n                    // For single account, propagate error\n                    if (selectedAccounts.size === 1) {\n                        throw error;\n                    }\n                    const reason = error instanceof Error ? error.message : String(error);\n                    partialFailures.push({\n                        accountId,\n                        reason\n                    });\n                    process.stderr.write(`Warning: Failed to load events for account \"${accountId}\": ${reason}\\n`);\n                    // For multi-account, continue with other accounts\n                    return { accountId, calendarIds: [], events: [] };\n                }\n            })\n        );\n\n        // Flatten and merge all events and calendar IDs\n        const allEvents = eventsPerAccount.flatMap(result => result.events);\n        const allQueriedCalendarIds = [...new Set(eventsPerAccount.flatMap(result => result.calendarIds))];\n\n        // Sort events chronologically\n        this.sortEventsByStartTime(allEvents);\n\n        // Convert extended events to structured format\n        const structuredEvents: StructuredEvent[] = allEvents.map(event =>\n            convertGoogleEventToStructured(event, event.calendarId, event.accountId)\n        );\n        const warnings: string[] = [...resolutionWarnings];\n\n        // Build detailed warnings for partial failures\n        if (partialFailures.length > 0) {\n            for (const failure of partialFailures) {\n                warnings.push(`Account \"${failure.accountId}\" failed: ${failure.reason}`);\n            }\n        }\n\n        // Build note based on results\n        let note: string | undefined;\n        if (selectedAccounts.size > 1) {\n            const successfulAccounts = selectedAccounts.size - partialFailures.length;\n            if (partialFailures.length > 0) {\n                note = `\u26A0\uFE0F Partial results: Retrieved events from ${successfulAccounts} of ${selectedAccounts.size} account(s). ${partialFailures.length} account(s) failed - see warnings for details.`;\n            } else {\n                note = `Showing merged events from ${selectedAccounts.size} account(s), sorted chronologically`;\n            }\n        }\n\n        const response: ListEventsResponse = {\n            events: structuredEvents,\n            totalCount: allEvents.length,\n            calendars: allQueriedCalendarIds.length > 1 ? allQueriedCalendarIds : undefined,\n            ...(partialFailures.length > 0 && { partialFailures }),\n            ...(warnings.length > 0 && { warnings }),\n            ...(selectedAccounts.size > 1 && { accounts: Array.from(selectedAccounts.keys()) }),\n            ...(note && { note })\n        };\n\n        return createStructuredResponse(response);\n    }\n\n    private async fetchEvents(\n        client: OAuth2Client,\n        calendarIds: string[],\n        options: { timeMin?: string; timeMax?: string; timeZone?: string; fields?: string[]; privateExtendedProperty?: string[]; sharedExtendedProperty?: string[] }\n    ): Promise<ExtendedEvent[]> {\n        if (calendarIds.length === 1) {\n            return this.fetchSingleCalendarEvents(client, calendarIds[0], options);\n        }\n        \n        return this.fetchMultipleCalendarEvents(client, calendarIds, options);\n    }\n\n    private async fetchSingleCalendarEvents(\n        client: OAuth2Client,\n        calendarId: string,\n        options: { timeMin?: string; timeMax?: string; timeZone?: string; fields?: string[]; privateExtendedProperty?: string[]; sharedExtendedProperty?: string[] }\n    ): Promise<ExtendedEvent[]> {\n        try {\n            const calendar = this.getCalendar(client);\n\n            // Normalize time range to RFC3339 format using calendar's timezone as fallback\n            const { timeMin, timeMax } = await this.normalizeTimeRange(\n                client, calendarId, options.timeMin, options.timeMax, options.timeZone\n            );\n            \n            const fieldMask = buildListFieldMask(options.fields);\n            \n            const response = await calendar.events.list({\n                calendarId,\n                timeMin,\n                timeMax,\n                singleEvents: true,\n                orderBy: 'startTime',\n                ...(fieldMask && { fields: fieldMask }),\n                ...(options.privateExtendedProperty && { privateExtendedProperty: options.privateExtendedProperty as any }),\n                ...(options.sharedExtendedProperty && { sharedExtendedProperty: options.sharedExtendedProperty as any })\n            });\n            \n            // Add calendarId to events for consistent interface\n            return (response.data.items || []).map(event => ({\n                ...event,\n                calendarId\n            }));\n        } catch (error) {\n            throw this.handleGoogleApiError(error);\n        }\n    }\n\n    private async fetchMultipleCalendarEvents(\n        client: OAuth2Client,\n        calendarIds: string[],\n        options: { timeMin?: string; timeMax?: string; timeZone?: string; fields?: string[]; privateExtendedProperty?: string[]; sharedExtendedProperty?: string[] }\n    ): Promise<ExtendedEvent[]> {\n        const batchHandler = new BatchRequestHandler(client);\n        \n        const requests = await Promise.all(calendarIds.map(async (calendarId) => ({\n            method: \"GET\" as const,\n            path: await this.buildEventsPath(client, calendarId, options)\n        })));\n        \n        const responses = await batchHandler.executeBatch(requests);\n        \n        const { events, errors } = this.processBatchResponses(responses, calendarIds);\n        \n        if (errors.length > 0) {\n            process.stderr.write(`Some calendars had errors: ${errors.map(e => `${e.calendarId}: ${e.error}`).join(', ')}\\n`);\n        }\n        \n        return this.sortEventsByStartTime(events);\n    }\n\n    private async buildEventsPath(client: OAuth2Client, calendarId: string, options: { timeMin?: string; timeMax?: string; timeZone?: string; fields?: string[]; privateExtendedProperty?: string[]; sharedExtendedProperty?: string[] }): Promise<string> {\n        // Normalize time range to RFC3339 format using calendar's timezone as fallback\n        const { timeMin, timeMax } = await this.normalizeTimeRange(\n            client, calendarId, options.timeMin, options.timeMax, options.timeZone\n        );\n\n        const fieldMask = buildListFieldMask(options.fields);\n        \n        const params = new URLSearchParams({\n            singleEvents: \"true\",\n            orderBy: \"startTime\",\n        });\n        if (timeMin) params.set('timeMin', timeMin);\n        if (timeMax) params.set('timeMax', timeMax);\n        if (fieldMask) params.set('fields', fieldMask);\n        if (options.privateExtendedProperty) {\n            for (const kv of options.privateExtendedProperty) params.append('privateExtendedProperty', kv);\n        }\n        if (options.sharedExtendedProperty) {\n            for (const kv of options.sharedExtendedProperty) params.append('sharedExtendedProperty', kv);\n        }\n        \n        return `/calendar/v3/calendars/${encodeURIComponent(calendarId)}/events?${params.toString()}`;\n    }\n\n    private processBatchResponses(\n        responses: any[], \n        calendarIds: string[]\n    ): { events: ExtendedEvent[]; errors: Array<{ calendarId: string; error: string }> } {\n        const events: ExtendedEvent[] = [];\n        const errors: Array<{ calendarId: string; error: string }> = [];\n        \n        responses.forEach((response, index) => {\n            const calendarId = calendarIds[index];\n            \n            if (response.statusCode === 200 && response.body?.items) {\n                const calendarEvents: ExtendedEvent[] = response.body.items.map((event: any) => ({\n                    ...event,\n                    calendarId\n                }));\n                events.push(...calendarEvents);\n            } else {\n                const errorMessage = response.body?.error?.message || \n                                   response.body?.message || \n                                   `HTTP ${response.statusCode}`;\n                errors.push({ calendarId, error: errorMessage });\n            }\n        });\n        \n        return { events, errors };\n    }\n}\n", "import { CallToolResult } from \"@modelcontextprotocol/sdk/types.js\";\nimport { OAuth2Client } from \"google-auth-library\";\nimport { SearchEventsInput } from \"../../tools/registry.js\";\nimport { BaseToolHandler } from \"./BaseToolHandler.js\";\nimport { calendar_v3 } from 'googleapis';\nimport { buildListFieldMask } from \"../../utils/field-mask-builder.js\";\nimport { createStructuredResponse } from \"../../utils/response-builder.js\";\nimport { SearchEventsResponse, StructuredEvent, convertGoogleEventToStructured, ExtendedEvent } from \"../../types/structured-responses.js\";\n\n// Internal args type for searchEvents with single calendarId (after normalization)\ninterface SearchEventsArgs {\n    calendarId: string;\n    query: string;\n    timeMin: string;\n    timeMax: string;\n    timeZone?: string;\n    fields?: string[];\n    privateExtendedProperty?: string[];\n    sharedExtendedProperty?: string[];\n}\n\nexport class SearchEventsHandler extends BaseToolHandler {\n    async runTool(args: any, accounts: Map<string, OAuth2Client>): Promise<CallToolResult> {\n        const validArgs = args as SearchEventsInput;\n\n        // Normalize calendarId to always be an array for consistent processing\n        const calendarNamesOrIds = Array.isArray(validArgs.calendarId)\n            ? validArgs.calendarId\n            : [validArgs.calendarId];\n\n        // Get clients for specified accounts (supports single or multiple)\n        const selectedAccounts = this.getClientsForAccounts(args.account, accounts);\n\n        // For multi-account/multi-calendar queries, use CalendarRegistry routing\n        let accountCalendarMap: Map<string, string[]>;\n        const resolutionWarnings: string[] = [];\n\n        if (selectedAccounts.size > 1 || calendarNamesOrIds.length > 1) {\n            // Multi-account or multi-calendar: route calendars to their owning accounts\n            const { resolved, warnings } = await this.calendarRegistry.resolveCalendarsToAccounts(\n                calendarNamesOrIds,\n                selectedAccounts\n            );\n            accountCalendarMap = resolved;\n            resolutionWarnings.push(...warnings);\n\n            // If no calendars could be resolved, throw error\n            if (accountCalendarMap.size === 0) {\n                await this.throwNoCalendarsFoundError(calendarNamesOrIds, selectedAccounts);\n            }\n        } else {\n            // Single account + single calendar: use existing auto-selection for simplicity\n            const { accountId, calendarId } = await this.getClientWithAutoSelection(\n                args.account,\n                calendarNamesOrIds[0],  // Use normalized single-element array\n                accounts,\n                'read'\n            );\n            accountCalendarMap = new Map([[accountId, [calendarId]]]);\n        }\n\n        // Search events from all calendars across all accounts\n        const allEvents: ExtendedEvent[] = [];\n        const queriedCalendarIds: string[] = [];\n\n        await Promise.all(\n            Array.from(accountCalendarMap.entries()).map(async ([accountId, calendarIds]) => {\n                const client = selectedAccounts.get(accountId)!;\n                for (const calendarId of calendarIds) {\n                    try {\n                        const events = await this.searchEvents(client, {\n                            ...validArgs,\n                            calendarId\n                        });\n                        // Tag events with account ID and calendar ID\n                        for (const event of events) {\n                            allEvents.push({\n                                ...event,\n                                calendarId,\n                                accountId\n                            });\n                        }\n                        queriedCalendarIds.push(calendarId);\n                    } catch (error) {\n                        // For multi-calendar, log but continue\n                        if (accountCalendarMap.size > 1 || calendarIds.length > 1) {\n                            const message = error instanceof Error ? error.message : String(error);\n                            resolutionWarnings.push(`Failed to search calendar \"${calendarId}\" on account \"${accountId}\": ${message}`);\n                        } else {\n                            throw error;\n                        }\n                    }\n                }\n            })\n        );\n\n        // Sort events chronologically\n        this.sortEventsByStartTime(allEvents);\n\n        // Convert to structured format\n        const structuredEvents: StructuredEvent[] = allEvents.map(event =>\n            convertGoogleEventToStructured(event, event.calendarId, event.accountId)\n        );\n\n        const response: SearchEventsResponse = {\n            events: structuredEvents,\n            totalCount: allEvents.length,\n            query: validArgs.query,\n            // For single calendar, include calendarId; for multiple, include calendars array\n            ...(queriedCalendarIds.length === 1 && { calendarId: queriedCalendarIds[0] }),\n            ...(queriedCalendarIds.length > 1 && { calendars: queriedCalendarIds }),\n            ...(selectedAccounts.size > 1 && { accounts: Array.from(selectedAccounts.keys()) }),\n            ...(resolutionWarnings.length > 0 && { warnings: resolutionWarnings })\n        };\n\n        if (validArgs.timeMin || validArgs.timeMax) {\n            // Use first calendar's timezone as reference for response display\n            const firstAccountId = accountCalendarMap.keys().next().value as string;\n            const firstCalendarId = accountCalendarMap.get(firstAccountId)?.[0] || 'primary';\n            const client = selectedAccounts.get(firstAccountId)!;\n            const { timeMin, timeMax } = await this.normalizeTimeRange(\n                client, firstCalendarId, validArgs.timeMin, validArgs.timeMax, validArgs.timeZone\n            );\n            response.timeRange = {\n                start: timeMin || '',\n                end: timeMax || ''\n            };\n        }\n\n        return createStructuredResponse(response);\n    }\n\n    private async searchEvents(\n        client: OAuth2Client,\n        args: SearchEventsArgs\n    ): Promise<calendar_v3.Schema$Event[]> {\n        try {\n            const calendar = this.getCalendar(client);\n\n            // Normalize time range to RFC3339 format using calendar's timezone as fallback\n            const { timeMin, timeMax } = await this.normalizeTimeRange(\n                client, args.calendarId, args.timeMin, args.timeMax, args.timeZone\n            );\n            \n            const fieldMask = buildListFieldMask(args.fields);\n            \n            const response = await calendar.events.list({\n                calendarId: args.calendarId,\n                q: args.query,\n                timeMin,\n                timeMax,\n                singleEvents: true,\n                orderBy: 'startTime',\n                ...(fieldMask && { fields: fieldMask }),\n                ...(args.privateExtendedProperty && { privateExtendedProperty: args.privateExtendedProperty as any }),\n                ...(args.sharedExtendedProperty && { sharedExtendedProperty: args.sharedExtendedProperty as any })\n            });\n            return response.data.items || [];\n        } catch (error) {\n            throw this.handleGoogleApiError(error);\n        }\n    }\n\n}\n", "import { CallToolResult, McpError, ErrorCode } from \"@modelcontextprotocol/sdk/types.js\";\nimport { OAuth2Client } from \"google-auth-library\";\nimport { BaseToolHandler } from \"./BaseToolHandler.js\";\nimport { calendar_v3 } from 'googleapis';\nimport { buildSingleEventFieldMask } from \"../../utils/field-mask-builder.js\";\nimport { createStructuredResponse } from \"../../utils/response-builder.js\";\nimport { GetEventResponse, convertGoogleEventToStructured } from \"../../types/structured-responses.js\";\n\ninterface GetEventArgs {\n    calendarId: string;\n    eventId: string;\n    fields?: string[];\n    account?: string;\n}\n\nexport class GetEventHandler extends BaseToolHandler {\n    async runTool(args: GetEventArgs, accounts: Map<string, OAuth2Client>): Promise<CallToolResult> {\n        const validArgs = args;\n\n        // Get OAuth2Client with automatic account selection for read operations\n        // Also resolves calendar name to ID if a name was provided\n        const { client: oauth2Client, accountId: selectedAccountId, calendarId: resolvedCalendarId } = await this.getClientWithAutoSelection(\n            args.account,\n            validArgs.calendarId,\n            accounts,\n            'read'\n        );\n\n        try {\n            // Get the event with resolved calendar ID\n            const argsWithResolvedCalendar = { ...validArgs, calendarId: resolvedCalendarId };\n            const event = await this.getEvent(oauth2Client, argsWithResolvedCalendar);\n\n            if (!event) {\n                throw new Error(`Event with ID '${validArgs.eventId}' not found in calendar '${resolvedCalendarId}'.`);\n            }\n\n            const response: GetEventResponse = {\n                event: convertGoogleEventToStructured(event, resolvedCalendarId, selectedAccountId)\n            };\n\n            return createStructuredResponse(response);\n        } catch (error) {\n            throw this.handleGoogleApiError(error);\n        }\n    }\n\n    private async getEvent(\n        client: OAuth2Client,\n        args: GetEventArgs\n    ): Promise<calendar_v3.Schema$Event | null> {\n        const calendar = this.getCalendar(client);\n        \n        const fieldMask = buildSingleEventFieldMask(args.fields);\n        \n        try {\n            const response = await calendar.events.get({\n                calendarId: args.calendarId,\n                eventId: args.eventId,\n                ...(fieldMask && { fields: fieldMask })\n            });\n            \n            return response.data;\n        } catch (error: any) {\n            // Handle 404 as a not found case\n            if (error?.code === 404 || error?.response?.status === 404) {\n                return null;\n            }\n            throw error;\n        }\n    }\n}\n", "import { CallToolResult } from \"@modelcontextprotocol/sdk/types.js\";\nimport { OAuth2Client } from \"google-auth-library\";\nimport { BaseToolHandler } from \"./BaseToolHandler.js\";\nimport { calendar_v3 } from \"googleapis\";\nimport { createStructuredResponse } from \"../../utils/response-builder.js\";\nimport { ListColorsResponse } from \"../../types/structured-responses.js\";\n\nexport class ListColorsHandler extends BaseToolHandler {\n    async runTool(args: any, accounts: Map<string, OAuth2Client>): Promise<CallToolResult> {\n        // Use specified account or first available (colors API returns same data for all accounts)\n        const oauth2Client = this.getClientForAccountOrFirst(args.account, accounts);\n\n        const colors = await this.listColors(oauth2Client);\n        \n        const response: ListColorsResponse = {\n            event: {},\n            calendar: {}\n        };\n        \n        // Convert event colors\n        if (colors.event) {\n            for (const [id, color] of Object.entries(colors.event)) {\n                response.event[id] = {\n                    background: color.background || '',\n                    foreground: color.foreground || ''\n                };\n            }\n        }\n        \n        // Convert calendar colors\n        if (colors.calendar) {\n            for (const [id, color] of Object.entries(colors.calendar)) {\n                response.calendar[id] = {\n                    background: color.background || '',\n                    foreground: color.foreground || ''\n                };\n            }\n        }\n        \n        return createStructuredResponse(response);\n    }\n\n    private async listColors(client: OAuth2Client): Promise<calendar_v3.Schema$Colors> {\n        try {\n            const calendar = this.getCalendar(client);\n            const response = await calendar.colors.get();\n            if (!response.data) throw new Error('Failed to retrieve colors');\n            return response.data;\n        } catch (error) {\n            throw this.handleGoogleApiError(error);\n        }\n    }\n\n    /**\n     * Formats the color information into a user-friendly string.\n     */\n    private formatColorList(colors: calendar_v3.Schema$Colors): string {\n        const eventColors = colors.event || {};\n        return Object.entries(eventColors)\n            .map(([id, colorInfo]) => `Color ID: ${id} - ${colorInfo.background} (background) / ${colorInfo.foreground} (foreground)`)\n            .join(\"\\n\");\n    }\n}\n", "/**\n * Event ID validation utility for Google Calendar API\n */\n\n/**\n * Converts w-z characters to valid base32hex (a-d).\n * Google Calendar event IDs use base32hex encoding: only a-v and 0-9.\n */\nfunction toBase32Hex(char: string): string {\n  if (char >= 'w' && char <= 'z') {\n    return String.fromCharCode(char.charCodeAt(0) - 22); // w->a, x->b, y->c, z->d\n  }\n  return '';\n}\n\n/**\n * Converts a string to valid base32hex by mapping w-z to a-d.\n */\nfunction convertToBase32Hex(str: string): string {\n  return str.replace(/[w-z]/g, toBase32Hex);\n}\n\n/**\n * Validates a custom event ID according to Google Calendar requirements\n * @param eventId The event ID to validate\n * @returns true if valid, false otherwise\n */\nexport function isValidEventId(eventId: string): boolean {\n  // Check length constraints (5-1024 characters)\n  if (eventId.length < 5 || eventId.length > 1024) {\n    return false;\n  }\n  \n  // Check character constraints (base32hex encoding)\n  // Google Calendar allows only: lowercase letters a-v and digits 0-9\n  // Based on RFC2938 section 3.1.2\n  const validPattern = /^[a-v0-9]+$/;\n  return validPattern.test(eventId);\n}\n\n/**\n * Validates and throws an error if the event ID is invalid\n * @param eventId The event ID to validate\n * @throws Error if the event ID is invalid\n */\nexport function validateEventId(eventId: string): void {\n  if (!isValidEventId(eventId)) {\n    const errors: string[] = [];\n    \n    if (eventId.length < 5) {\n      errors.push(\"must be at least 5 characters long\");\n    }\n    \n    if (eventId.length > 1024) {\n      errors.push(\"must not exceed 1024 characters\");\n    }\n    \n    if (!/^[a-v0-9]+$/.test(eventId)) {\n      errors.push(\"can only contain lowercase letters a-v and digits 0-9 (base32hex encoding)\");\n    }\n    \n    throw new Error(`Invalid event ID: ${errors.join(\", \")}`);\n  }\n}\n\n/**\n * Sanitizes a string to make it a valid event ID\n * Converts to base32hex encoding (lowercase a-v and 0-9 only)\n * @param input The input string to sanitize\n * @returns A valid event ID\n */\nexport function sanitizeEventId(input: string): string {\n  // Convert to lowercase first\n  let sanitized = input.toLowerCase();\n  \n  // Replace invalid characters:\n  // - Keep digits 0-9 as is\n  // - Map letters w-z to a-d (shift back)\n  // - Remove other invalid characters\n  sanitized = sanitized.replace(/[^a-v0-9]/g, toBase32Hex);\n  \n  // Remove any empty spaces from the mapping\n  sanitized = sanitized.replace(/\\s+/g, '');\n  \n  // Ensure minimum length\n  if (sanitized.length < 5) {\n    // Generate a base32hex timestamp\n    const timestamp = convertToBase32Hex(Date.now().toString(32));\n\n    if (sanitized.length === 0) {\n      sanitized = `event${timestamp}`.substring(0, 26); // Match Google's 26-char format\n    } else {\n      sanitized = `${sanitized}${timestamp}`.substring(0, 26);\n    }\n  }\n  \n  // Ensure maximum length\n  if (sanitized.length > 1024) {\n    sanitized = sanitized.slice(0, 1024);\n  }\n  \n  // Final validation - ensure only valid characters\n  sanitized = sanitized.replace(/[^a-v0-9]/g, '');\n  \n  // If still too short after all operations, generate a default\n  if (sanitized.length < 5) {\n    const base32hex = convertToBase32Hex(Date.now().toString(32));\n    sanitized = `ev${base32hex}`.substring(0, 26);\n  }\n  \n  return sanitized;\n}", "import { OAuth2Client } from \"google-auth-library\";\nimport { google, calendar_v3 } from \"googleapis\";\nimport {\n  ConflictCheckResult,\n  InternalConflictInfo,\n  InternalDuplicateInfo,\n  ConflictDetectionOptions\n} from \"./types.js\";\nimport { EventSimilarityChecker } from \"./EventSimilarityChecker.js\";\nimport { CONFLICT_DETECTION_CONFIG } from \"./config.js\";\nimport { getEventUrl } from \"../../utils/event-url.js\";\nimport { convertToRFC3339, hasTimezoneInDatetime } from \"../../utils/datetime.js\";\n\n/**\n * Service for detecting event conflicts and duplicates.\n * \n * IMPORTANT: This service relies on Google Calendar's list API to find existing events.\n * Due to eventual consistency in Google Calendar, recently created events may not\n * immediately appear in list queries. This is a known limitation of the Google Calendar API\n * and affects duplicate detection for events created in quick succession.\n * \n * In real-world usage, this is rarely an issue as there's natural time between event creation.\n */\nexport class ConflictDetectionService {\n  private similarityChecker: EventSimilarityChecker;\n\n  constructor() {\n    this.similarityChecker = new EventSimilarityChecker();\n  }\n\n  /**\n   * Check for conflicts and duplicates when creating or updating an event\n   */\n  async checkConflicts(\n    oauth2Client: OAuth2Client,\n    event: calendar_v3.Schema$Event,\n    calendarId: string,\n    options: ConflictDetectionOptions = {}\n  ): Promise<ConflictCheckResult> {\n    const {\n      checkDuplicates = true,\n      checkConflicts = true,\n      calendarsToCheck = [calendarId],\n      duplicateSimilarityThreshold = CONFLICT_DETECTION_CONFIG.DEFAULT_DUPLICATE_THRESHOLD,\n      includeDeclinedEvents = false\n    } = options;\n\n    const result: ConflictCheckResult = {\n      hasConflicts: false,\n      conflicts: [],\n      duplicates: []\n    };\n\n    if (!event.start || !event.end) {\n      return result;\n    }\n\n    // Normalize the event we're checking so comparisons use timezone-aware datetimes\n    const normalizedEvent = this.normalizeEventForComparison(event);\n\n    // Get the time range for checking\n    let timeMin = normalizedEvent.start?.dateTime || normalizedEvent.start?.date;\n    let timeMax = normalizedEvent.end?.dateTime || normalizedEvent.end?.date;\n\n    if (!timeMin || !timeMax) {\n      return result;\n    }\n\n    // Extract timezone if present (prefer start time's timezone)\n    const timezone = normalizedEvent.start?.timeZone || normalizedEvent.end?.timeZone;\n    \n    \n    // The Google Calendar API requires RFC3339 format for timeMin/timeMax\n    // If we have timezone-naive datetimes with a timezone field, convert them to proper RFC3339\n    // Check for minus but exclude the date separator (e.g., 2025-09-05)\n    const needsConversion = timezone && timeMin && \n      !timeMin.includes('Z') && \n      !timeMin.includes('+') && \n      !timeMin.substring(10).includes('-'); // Only check for minus after the date part\n      \n    if (needsConversion) {\n      timeMin = convertToRFC3339(timeMin, timezone);\n      timeMax = convertToRFC3339(timeMax, timezone);\n    }\n    \n    \n    // Use the exact time range provided for searching\n    // This ensures duplicate detection only flags events that actually overlap\n    const searchTimeMin = timeMin;\n    const searchTimeMax = timeMax;\n\n    // Check each calendar\n    for (const checkCalendarId of calendarsToCheck) {\n      try {\n        // Get events in the search time range, passing timezone for proper interpretation\n        const events = await this.getEventsInTimeRange(\n          oauth2Client,\n          checkCalendarId,\n          searchTimeMin,\n          searchTimeMax,\n          timezone || undefined\n        );\n\n        // Check for duplicates\n        if (checkDuplicates) {\n          const duplicates = this.findDuplicates(\n            normalizedEvent,\n            events,\n            checkCalendarId,\n            duplicateSimilarityThreshold\n          );\n          result.duplicates.push(...duplicates);\n        }\n\n        // Check for conflicts\n        if (checkConflicts) {\n          const conflicts = this.findConflicts(\n            normalizedEvent,\n            events,\n            checkCalendarId,\n            includeDeclinedEvents\n          );\n          result.conflicts.push(...conflicts);\n        }\n      } catch (error) {\n        // If we can't access a calendar, skip it silently\n        // Errors are expected for calendars without access permissions\n      }\n    }\n\n    result.hasConflicts = result.conflicts.length > 0 || result.duplicates.length > 0;\n    return result;\n  }\n\n  /**\n   * Ensure the event used for comparison has timezone-aware datetimes so overlap/duplicate checks\n   * don't depend on the local machine timezone.\n   */\n  private normalizeEventForComparison(event: calendar_v3.Schema$Event): calendar_v3.Schema$Event {\n    const clone: calendar_v3.Schema$Event = JSON.parse(JSON.stringify(event));\n    const timezone = clone.start?.timeZone || clone.end?.timeZone;\n\n    if (clone.start?.dateTime && timezone && !hasTimezoneInDatetime(clone.start.dateTime)) {\n      clone.start.dateTime = convertToRFC3339(clone.start.dateTime, timezone);\n    }\n    if (clone.end?.dateTime && timezone && !hasTimezoneInDatetime(clone.end.dateTime)) {\n      clone.end.dateTime = convertToRFC3339(clone.end.dateTime, timezone);\n    }\n\n    return clone;\n  }\n\n  /**\n   * Get events in a specific time range from a calendar\n   */\n  private async getEventsInTimeRange(\n    oauth2Client: OAuth2Client,\n    calendarId: string,\n    timeMin: string,\n    timeMax: string,\n    timeZone?: string\n  ): Promise<calendar_v3.Schema$Event[]> {\n    // Fetch from API\n    const calendar = google.calendar({ version: \"v3\", auth: oauth2Client });\n    \n    // Build list parameters\n    const listParams: any = {\n      calendarId,\n      timeMin,\n      timeMax,\n      singleEvents: true,\n      orderBy: 'startTime',\n      maxResults: 250\n    };\n    \n    // The Google Calendar API accepts both:\n    // 1. Timezone-aware datetimes (with Z or offset)\n    // 2. Timezone-naive datetimes with a timeZone parameter\n    // We pass the timeZone parameter when available for consistency\n    if (timeZone) {\n      listParams.timeZone = timeZone;\n    }\n    \n    \n    // Use exact time range without extension to avoid false positives\n    const response = await calendar.events.list(listParams);\n\n    const events = response?.data?.items || [];\n    \n    return events;\n  }\n\n  /**\n   * Find duplicate events based on similarity\n   */\n  private findDuplicates(\n    newEvent: calendar_v3.Schema$Event,\n    existingEvents: calendar_v3.Schema$Event[],\n    calendarId: string,\n    threshold: number\n  ): InternalDuplicateInfo[] {\n    const duplicates: InternalDuplicateInfo[] = [];\n\n\n    for (const existingEvent of existingEvents) {\n      // Skip if it's the same event (for updates)\n      if (existingEvent.id === newEvent.id) continue;\n      \n      // Skip cancelled events\n      if (existingEvent.status === 'cancelled') continue;\n\n      const similarity = this.similarityChecker.checkSimilarity(newEvent, existingEvent);\n      \n      \n      if (similarity >= threshold) {\n        duplicates.push({\n          event: {\n            id: existingEvent.id!,\n            title: existingEvent.summary || 'Untitled Event',\n            url: getEventUrl(existingEvent, calendarId) || undefined,\n            similarity: Math.round(similarity * 100) / 100\n          },\n          fullEvent: existingEvent,\n          calendarId: calendarId,\n          suggestion: similarity >= CONFLICT_DETECTION_CONFIG.DUPLICATE_THRESHOLDS.BLOCKING\n            ? 'This appears to be a duplicate. Consider updating the existing event instead.'\n            : 'This event is very similar to an existing one. Is this intentional?'\n        });\n      }\n    }\n\n\n    return duplicates;\n  }\n\n  /**\n   * Find conflicting events based on time overlap\n   * Note: _includeDeclinedEvents is reserved for future declined event detection\n   */\n  private findConflicts(\n    newEvent: calendar_v3.Schema$Event,\n    existingEvents: calendar_v3.Schema$Event[],\n    calendarId: string,\n    _includeDeclinedEvents: boolean\n  ): InternalConflictInfo[] {\n    const conflicts: InternalConflictInfo[] = [];\n    const overlappingEvents = this.similarityChecker.findOverlappingEvents(existingEvents, newEvent);\n\n    for (const conflictingEvent of overlappingEvents) {\n      const overlap = this.similarityChecker.analyzeOverlap(newEvent, conflictingEvent);\n      \n      if (overlap.hasOverlap) {\n        conflicts.push({\n          type: 'overlap',\n          calendar: calendarId,\n          event: {\n            id: conflictingEvent.id!,\n            title: conflictingEvent.summary || 'Untitled Event',\n            url: getEventUrl(conflictingEvent, calendarId) || undefined,\n            start: conflictingEvent.start?.dateTime || conflictingEvent.start?.date || undefined,\n            end: conflictingEvent.end?.dateTime || conflictingEvent.end?.date || undefined\n          },\n          fullEvent: conflictingEvent,\n          overlap: {\n            duration: overlap.duration!,\n            percentage: overlap.percentage!,\n            startTime: overlap.startTime!,\n            endTime: overlap.endTime!\n          }\n        });\n      }\n    }\n\n    return conflicts;\n  }\n\n  /**\n   * Check for conflicts using free/busy data (alternative method)\n   */\n  async checkConflictsWithFreeBusy(\n    oauth2Client: OAuth2Client,\n    eventToCheck: calendar_v3.Schema$Event,\n    calendarsToCheck: string[]\n  ): Promise<InternalConflictInfo[]> {\n    const conflicts: InternalConflictInfo[] = [];\n    \n    if (!eventToCheck.start || !eventToCheck.end) return conflicts;\n    \n    const timeMin = eventToCheck.start.dateTime || eventToCheck.start.date;\n    const timeMax = eventToCheck.end.dateTime || eventToCheck.end.date;\n    \n    if (!timeMin || !timeMax) return conflicts;\n\n    const calendar = google.calendar({ version: \"v3\", auth: oauth2Client });\n    \n    try {\n      const freeBusyResponse = await calendar.freebusy.query({\n        requestBody: {\n          timeMin,\n          timeMax,\n          items: calendarsToCheck.map(id => ({ id }))\n        }\n      });\n\n      for (const [calendarId, calendarInfo] of Object.entries(freeBusyResponse.data.calendars || {})) {\n        if (calendarInfo.busy && calendarInfo.busy.length > 0) {\n          for (const busySlot of calendarInfo.busy) {\n            if (this.similarityChecker.checkBusyConflict(eventToCheck, busySlot)) {\n              conflicts.push({\n                type: 'overlap',\n                calendar: calendarId,\n                event: {\n                  id: 'busy-time',\n                  title: 'Busy (details unavailable)',\n                  start: busySlot.start || undefined,\n                  end: busySlot.end || undefined\n                }\n              });\n            }\n          }\n        }\n      }\n    } catch (error) {\n      console.error('Failed to check free/busy:', error);\n    }\n\n    return conflicts;\n  }\n}\n", "import { calendar_v3 } from \"googleapis\";\nimport { EventTimeRange } from \"./types.js\";\n\nexport class EventSimilarityChecker {\n  private readonly DEFAULT_SIMILARITY_THRESHOLD = 0.7;\n\n  /**\n   * Check if two events are potentially duplicates based on similarity\n   * Uses simplified rules-based approach instead of complex weighted calculations\n   */\n  checkSimilarity(event1: calendar_v3.Schema$Event, event2: calendar_v3.Schema$Event): number {\n    // Check if one is all-day and the other is timed\n    const event1IsAllDay = this.isAllDayEvent(event1);\n    const event2IsAllDay = this.isAllDayEvent(event2);\n    \n    if (event1IsAllDay !== event2IsAllDay) {\n      // Different event types - not duplicates\n      return 0.2; // Low similarity\n    }\n    \n    const titleMatch = this.titlesMatch(event1.summary, event2.summary);\n    const timeOverlap = this.eventsOverlap(event1, event2);\n    const sameDay = this.eventsOnSameDay(event1, event2);\n    \n    // Simple rules-based scoring\n    if (titleMatch.exact && timeOverlap) {\n      return 0.95; // Almost certainly a duplicate\n    }\n    \n    if (titleMatch.similar && timeOverlap) {\n      return 0.7; // Potential duplicate\n    }\n    \n    if (titleMatch.exact && sameDay) {\n      return 0.6; // Same title on same day but different times\n    }\n    \n    if (titleMatch.exact && !sameDay) {\n      return 0.4; // Same title but different day - likely recurring event\n    }\n    \n    if (titleMatch.similar) {\n      return 0.3; // Similar titles only\n    }\n    \n    return 0.1; // No significant similarity\n  }\n\n  /**\n   * Check if an event is an all-day event\n   */\n  private isAllDayEvent(event: calendar_v3.Schema$Event): boolean {\n    return !event.start?.dateTime && !!event.start?.date;\n  }\n\n  /**\n   * Check if two titles match (exact or similar)\n   * Simplified string matching without Levenshtein distance\n   */\n  private titlesMatch(title1?: string | null, title2?: string | null): { exact: boolean; similar: boolean } {\n    if (!title1 || !title2) {\n      return { exact: false, similar: false };\n    }\n    \n    const t1 = title1.toLowerCase().trim();\n    const t2 = title2.toLowerCase().trim();\n    \n    // Exact match\n    if (t1 === t2) {\n      return { exact: true, similar: true };\n    }\n    \n    // Check if one contains the other (for variations like \"Meeting\" vs \"Team Meeting\")\n    if (t1.includes(t2) || t2.includes(t1)) {\n      return { exact: false, similar: true };\n    }\n    \n    // Check for common significant words (more than 3 characters)\n    const words1 = t1.split(/\\s+/).filter(w => w.length > 3);\n    const words2 = t2.split(/\\s+/).filter(w => w.length > 3);\n    \n    if (words1.length > 0 && words2.length > 0) {\n      const commonWords = words1.filter(w => words2.includes(w));\n      const similarity = commonWords.length / Math.min(words1.length, words2.length);\n      \n      return { exact: false, similar: similarity >= 0.5 };\n    }\n    \n    return { exact: false, similar: false };\n  }\n\n  /**\n   * Check if two events are on the same day\n   */\n  private eventsOnSameDay(event1: calendar_v3.Schema$Event, event2: calendar_v3.Schema$Event): boolean {\n    const time1 = this.getEventTime(event1);\n    const time2 = this.getEventTime(event2);\n    \n    if (!time1 || !time2) return false;\n    \n    // Compare dates only (ignore time)\n    const date1 = new Date(time1.start);\n    const date2 = new Date(time2.start);\n    \n    return date1.getFullYear() === date2.getFullYear() &&\n           date1.getMonth() === date2.getMonth() &&\n           date1.getDate() === date2.getDate();\n  }\n\n  /**\n   * Extract event time information\n   * \n   * Note: This method handles both:\n   * - Events being created (may have timezone-naive datetimes with separate timeZone field)\n   * - Events from Google Calendar (have timezone-aware datetimes)\n   * \n   * The MCP trusts Google Calendar to return only relevant events in the queried time range.\n   * Any timezone conversions are handled by the Google Calendar API, not by this service.\n   */\n  private getEventTime(event: calendar_v3.Schema$Event): { start: Date; end: Date } | null {\n    const startTime = event.start?.dateTime || event.start?.date;\n    const endTime = event.end?.dateTime || event.end?.date;\n    \n    if (!startTime || !endTime) return null;\n    \n    // Parse the datetime strings as-is\n    // Google Calendar API ensures we only get events in the requested time range\n    return {\n      start: new Date(startTime),\n      end: new Date(endTime)\n    };\n  }\n\n  /**\n   * Check if two events overlap in time\n   * Consolidated overlap logic used throughout the service\n   */\n  eventsOverlap(event1: calendar_v3.Schema$Event, event2: calendar_v3.Schema$Event): boolean {\n    const time1 = this.getEventTime(event1);\n    const time2 = this.getEventTime(event2);\n    \n    if (!time1 || !time2) return false;\n    \n    return time1.start < time2.end && time2.start < time1.end;\n  }\n\n  /**\n   * Calculate overlap duration in milliseconds\n   * Used by ConflictAnalyzer for detailed overlap analysis\n   */\n  calculateOverlapDuration(event1: calendar_v3.Schema$Event, event2: calendar_v3.Schema$Event): number {\n    const time1 = this.getEventTime(event1);\n    const time2 = this.getEventTime(event2);\n    \n    if (!time1 || !time2) return 0;\n    \n    const overlapStart = Math.max(time1.start.getTime(), time2.start.getTime());\n    const overlapEnd = Math.min(time1.end.getTime(), time2.end.getTime());\n    return Math.max(0, overlapEnd - overlapStart);\n  }\n\n  /**\n   * Determine if events are likely duplicates\n   */\n  isDuplicate(event1: calendar_v3.Schema$Event, event2: calendar_v3.Schema$Event, threshold?: number): boolean {\n    const similarity = this.checkSimilarity(event1, event2);\n    return similarity >= (threshold || this.DEFAULT_SIMILARITY_THRESHOLD);\n  }\n\n  /**\n   * Analyze overlap between two events with detailed information\n   * (Merged from ConflictAnalyzer)\n   */\n  analyzeOverlap(event1: calendar_v3.Schema$Event, event2: calendar_v3.Schema$Event): {\n    hasOverlap: boolean;\n    duration?: string;\n    percentage?: number;\n    startTime?: string;\n    endTime?: string;\n  } {\n    const hasOverlap = this.eventsOverlap(event1, event2);\n\n    if (!hasOverlap) {\n      return { hasOverlap: false };\n    }\n\n    const time1 = this.getEventTimeRange(event1);\n    const time2 = this.getEventTimeRange(event2);\n\n    if (!time1 || !time2) {\n      return { hasOverlap: false };\n    }\n\n    const overlapDuration = this.calculateOverlapDuration(event1, event2);\n    const overlapStart = new Date(Math.max(time1.start.getTime(), time2.start.getTime()));\n    const overlapEnd = new Date(Math.min(time1.end.getTime(), time2.end.getTime()));\n\n    const event1Duration = time1.end.getTime() - time1.start.getTime();\n    const overlapPercentage = Math.round((overlapDuration / event1Duration) * 100);\n\n    return {\n      hasOverlap: true,\n      duration: this.formatDuration(overlapDuration),\n      percentage: overlapPercentage,\n      startTime: overlapStart.toISOString(),\n      endTime: overlapEnd.toISOString()\n    };\n  }\n\n  /**\n   * Get event time range with isAllDay flag\n   * (Merged from ConflictAnalyzer)\n   */\n  getEventTimeRange(event: calendar_v3.Schema$Event): EventTimeRange | null {\n    const startTime = event.start?.dateTime || event.start?.date;\n    const endTime = event.end?.dateTime || event.end?.date;\n\n    if (!startTime || !endTime) return null;\n\n    const start = new Date(startTime);\n    const end = new Date(endTime);\n    const isAllDay = !event.start?.dateTime && !!event.start?.date;\n\n    return { start, end, isAllDay };\n  }\n\n  /**\n   * Format duration in human-readable format\n   * (Merged from ConflictAnalyzer)\n   */\n  private formatDuration(milliseconds: number): string {\n    const minutes = Math.floor(milliseconds / (1000 * 60));\n    const hours = Math.floor(minutes / 60);\n    const days = Math.floor(hours / 24);\n\n    if (days > 0) {\n      const remainingHours = hours % 24;\n      return remainingHours > 0\n        ? `${days} day${days > 1 ? 's' : ''} ${remainingHours} hour${remainingHours > 1 ? 's' : ''}`\n        : `${days} day${days > 1 ? 's' : ''}`;\n    }\n\n    if (hours > 0) {\n      const remainingMinutes = minutes % 60;\n      return remainingMinutes > 0\n        ? `${hours} hour${hours > 1 ? 's' : ''} ${remainingMinutes} minute${remainingMinutes > 1 ? 's' : ''}`\n        : `${hours} hour${hours > 1 ? 's' : ''}`;\n    }\n\n    return `${minutes} minute${minutes > 1 ? 's' : ''}`;\n  }\n\n  /**\n   * Check if an event conflicts with a busy time slot\n   * (Merged from ConflictAnalyzer)\n   */\n  checkBusyConflict(event: calendar_v3.Schema$Event, busySlot: { start?: string | null; end?: string | null }): boolean {\n    const start = busySlot.start ?? undefined;\n    const end = busySlot.end ?? undefined;\n\n    if (!start || !end) return false;\n\n    const busyEvent: calendar_v3.Schema$Event = {\n      start: { dateTime: start },\n      end: { dateTime: end }\n    };\n\n    return this.eventsOverlap(event, busyEvent);\n  }\n\n  /**\n   * Filter events that overlap with a given target event\n   * (Merged from ConflictAnalyzer)\n   */\n  findOverlappingEvents(\n    events: calendar_v3.Schema$Event[],\n    targetEvent: calendar_v3.Schema$Event\n  ): calendar_v3.Schema$Event[] {\n    return events.filter(event => {\n      if (event.id === targetEvent.id) return false;\n      if (event.status === 'cancelled') return false;\n      return this.eventsOverlap(targetEvent, event);\n    });\n  }\n}", "/**\n * Centralized configuration for conflict detection thresholds\n */\n\nexport const CONFLICT_DETECTION_CONFIG = {\n  /**\n   * Thresholds for duplicate event detection\n   */\n  DUPLICATE_THRESHOLDS: {\n    /**\n     * Events with similarity >= this value are flagged as potential duplicates\n     * and shown as warnings during creation\n     */\n    WARNING: 0.7,\n    \n    /**\n     * Events with similarity >= this value are considered exact duplicates\n     * and block creation unless explicitly overridden with allowDuplicates flag\n     */\n    BLOCKING: 0.95\n  },\n  \n  /**\n   * Default similarity threshold for duplicate detection\n   * Used when duplicateSimilarityThreshold is not specified in the request\n   */\n  DEFAULT_DUPLICATE_THRESHOLD: 0.7\n} as const;\n\nexport type ConflictDetectionConfig = typeof CONFLICT_DETECTION_CONFIG;", "import { calendar_v3 } from \"googleapis\";\n\n/**\n * Generates a Google Calendar event view URL\n */\nexport function generateEventUrl(calendarId: string, eventId: string): string {\n    const encodedCalendarId = encodeURIComponent(calendarId);\n    const encodedEventId = encodeURIComponent(eventId);\n    return `https://calendar.google.com/calendar/event?eid=${encodedEventId}&cid=${encodedCalendarId}`;\n}\n\n/**\n * Gets the URL for a calendar event\n */\nexport function getEventUrl(event: calendar_v3.Schema$Event, calendarId?: string): string | null {\n    if (event.htmlLink) {\n        return event.htmlLink;\n    } else if (calendarId && event.id) {\n        return generateEventUrl(calendarId, event.id);\n    }\n    return null;\n}\n", "import { CallToolResult, McpError, ErrorCode } from \"@modelcontextprotocol/sdk/types.js\";\nimport { OAuth2Client } from \"google-auth-library\";\nimport { CreateEventInput } from \"../../tools/registry.js\";\nimport { BaseToolHandler } from \"./BaseToolHandler.js\";\nimport { calendar_v3 } from 'googleapis';\nimport { createTimeObject } from \"../../utils/datetime.js\";\nimport { validateEventId } from \"../../utils/event-id-validator.js\";\nimport { ConflictDetectionService } from \"../../services/conflict-detection/index.js\";\nimport { CONFLICT_DETECTION_CONFIG } from \"../../services/conflict-detection/config.js\";\nimport { createStructuredResponse, convertConflictsToStructured, createWarningsArray } from \"../../utils/response-builder.js\";\nimport { CreateEventResponse, convertGoogleEventToStructured } from \"../../types/structured-responses.js\";\n\nexport class CreateEventHandler extends BaseToolHandler {\n    private conflictDetectionService: ConflictDetectionService;\n    \n    constructor() {\n        super();\n        this.conflictDetectionService = new ConflictDetectionService();\n    }\n    \n    async runTool(args: any, accounts: Map<string, OAuth2Client>): Promise<CallToolResult> {\n        const validArgs = args as CreateEventInput;\n\n        // Get OAuth2Client with automatic account selection for write operations\n        // Also resolves calendar name to ID if a name was provided\n        const { client: oauth2Client, accountId: selectedAccountId, calendarId: resolvedCalendarId } = await this.getClientWithAutoSelection(\n            args.account,\n            validArgs.calendarId,\n            accounts,\n            'write'\n        );\n\n        // Validate primary calendar requirement for outOfOffice and workingLocation events\n        if (validArgs.eventType === 'outOfOffice' || validArgs.eventType === 'workingLocation') {\n            if (resolvedCalendarId !== 'primary' && !resolvedCalendarId.includes('@')) {\n                const eventTypeName = validArgs.eventType === 'outOfOffice' ? 'Out of Office' : 'Working Location';\n                throw new Error(\n                    `${eventTypeName} events can only be created on the primary calendar. ` +\n                    'Use calendarId: \"primary\" or your email address.'\n                );\n            }\n        }\n\n        // Create the event object for conflict checking\n        const timezone = args.timeZone || await this.getCalendarTimezone(oauth2Client, resolvedCalendarId);\n        const eventToCheck: calendar_v3.Schema$Event = {\n            summary: args.summary,\n            description: args.description,\n            start: createTimeObject(args.start, timezone),\n            end: createTimeObject(args.end, timezone),\n            attendees: args.attendees,\n            location: args.location,\n        };\n        \n        // Check for conflicts and duplicates using resolved calendar ID\n        const conflicts = await this.conflictDetectionService.checkConflicts(\n            oauth2Client,\n            eventToCheck,\n            resolvedCalendarId,\n            {\n                checkDuplicates: true,\n                checkConflicts: true,\n                calendarsToCheck: validArgs.calendarsToCheck || [resolvedCalendarId],\n                duplicateSimilarityThreshold: validArgs.duplicateSimilarityThreshold || CONFLICT_DETECTION_CONFIG.DEFAULT_DUPLICATE_THRESHOLD\n            }\n        );\n\n        // Block creation if exact or near-exact duplicate found\n        const exactDuplicate = conflicts.duplicates.find(\n            dup => dup.event.similarity >= CONFLICT_DETECTION_CONFIG.DUPLICATE_THRESHOLDS.BLOCKING\n        );\n\n        if (exactDuplicate && validArgs.allowDuplicates !== true) {\n            // Throw an error that will be handled by MCP SDK\n            throw new Error(\n                `Duplicate event detected (${Math.round(exactDuplicate.event.similarity * 100)}% similar). ` +\n                `Event \"${exactDuplicate.event.title}\" already exists. ` +\n                `To create anyway, set allowDuplicates to true.`\n            );\n        }\n\n        // Create the event with resolved calendar ID\n        const argsWithResolvedCalendar = { ...validArgs, calendarId: resolvedCalendarId };\n        const event = await this.createEvent(oauth2Client, argsWithResolvedCalendar);\n\n        // Generate structured response with conflict warnings\n        const structuredConflicts = convertConflictsToStructured(conflicts);\n        const response: CreateEventResponse = {\n            event: convertGoogleEventToStructured(event, resolvedCalendarId, selectedAccountId),\n            conflicts: structuredConflicts.conflicts,\n            duplicates: structuredConflicts.duplicates,\n            warnings: createWarningsArray(conflicts)\n        };\n\n        return createStructuredResponse(response);\n    }\n\n    private async createEvent(\n        client: OAuth2Client,\n        args: CreateEventInput\n    ): Promise<calendar_v3.Schema$Event> {\n        try {\n            const calendar = this.getCalendar(client);\n            \n            // Validate custom event ID if provided\n            if (args.eventId) {\n                validateEventId(args.eventId);\n            }\n            \n            // Use provided timezone or calendar's default timezone\n            const timezone = args.timeZone || await this.getCalendarTimezone(client, args.calendarId);\n\n            // Determine transparency and visibility based on event type\n            const { transparency, visibility } = this.getEventTypeDefaults(args);\n\n            // Generate summary for workingLocation if not provided\n            const summary = args.eventType === 'workingLocation' && !args.summary\n                ? this.generateWorkingLocationSummary(args)\n                : args.summary;\n\n            const requestBody: calendar_v3.Schema$Event = {\n                summary: summary,\n                description: args.description,\n                start: createTimeObject(args.start, timezone),\n                end: createTimeObject(args.end, timezone),\n                attendees: args.attendees,\n                location: args.location,\n                colorId: args.colorId,\n                reminders: args.reminders,\n                recurrence: args.recurrence,\n                transparency: transparency,\n                visibility: visibility,\n                guestsCanInviteOthers: args.guestsCanInviteOthers,\n                guestsCanModify: args.guestsCanModify,\n                guestsCanSeeOtherGuests: args.guestsCanSeeOtherGuests,\n                anyoneCanAddSelf: args.anyoneCanAddSelf,\n                conferenceData: args.conferenceData,\n                extendedProperties: args.extendedProperties,\n                attachments: args.attachments,\n                source: args.source,\n                eventType: args.eventType,\n                ...(args.eventId && { id: args.eventId }), // Include custom ID if provided\n                ...(args.focusTimeProperties && { focusTimeProperties: args.focusTimeProperties }),\n                ...(args.eventType === 'outOfOffice' && { outOfOfficeProperties: this.buildOutOfOfficeProperties(args) }),\n                ...(args.eventType === 'workingLocation' && { workingLocationProperties: this.buildWorkingLocationProperties(args) })\n            };\n            \n            // Determine if we need to enable conference data or attachments\n            const conferenceDataVersion = args.conferenceData ? 1 : undefined;\n            const supportsAttachments = args.attachments ? true : undefined;\n            \n            const response = await calendar.events.insert({\n                calendarId: args.calendarId,\n                requestBody: requestBody,\n                sendUpdates: args.sendUpdates,\n                ...(conferenceDataVersion && { conferenceDataVersion }),\n                ...(supportsAttachments && { supportsAttachments })\n            });\n            \n            if (!response.data) throw new Error('Failed to create event, no data returned');\n            return response.data;\n        } catch (error: any) {\n            // Handle ID conflict errors specifically\n            if (error?.code === 409 || error?.response?.status === 409) {\n                throw new Error(`Event ID '${args.eventId}' already exists. Please use a different ID.`);\n            }\n            throw this.handleGoogleApiError(error);\n        }\n    }\n\n    /**\n     * Get default transparency and visibility based on event type\n     */\n    private getEventTypeDefaults(args: CreateEventInput): {\n        transparency: string | undefined;\n        visibility: string | undefined;\n    } {\n        // Use explicit values if provided\n        let transparency = args.transparency;\n        let visibility = args.visibility;\n\n        switch (args.eventType) {\n            case 'focusTime':\n            case 'outOfOffice':\n                // Focus Time and Out of Office block time by default\n                if (!transparency) transparency = 'opaque';\n                break;\n            case 'workingLocation':\n                // Working Location events are visible but don't block time\n                if (!transparency) transparency = 'transparent';\n                if (!visibility) visibility = 'public';\n                break;\n        }\n\n        return { transparency, visibility };\n    }\n\n    /**\n     * Build outOfOfficeProperties from args\n     */\n    private buildOutOfOfficeProperties(args: CreateEventInput): calendar_v3.Schema$EventOutOfOfficeProperties {\n        const props = args.outOfOfficeProperties;\n        return {\n            autoDeclineMode: props?.autoDeclineMode || 'declineAllConflictingInvitations',\n            ...(props?.declineMessage && { declineMessage: props.declineMessage })\n        };\n    }\n\n    /**\n     * Build workingLocationProperties from args\n     */\n    private buildWorkingLocationProperties(args: CreateEventInput): calendar_v3.Schema$EventWorkingLocationProperties {\n        const props = args.workingLocationProperties;\n        if (!props) {\n            throw new Error('workingLocationProperties is required when eventType is \"workingLocation\"');\n        }\n\n        const properties: calendar_v3.Schema$EventWorkingLocationProperties = {\n            type: props.type\n        };\n\n        switch (props.type) {\n            case 'homeOffice':\n                properties.homeOffice = {};\n                break;\n            case 'officeLocation':\n                properties.officeLocation = props.officeLocation || {};\n                break;\n            case 'customLocation':\n                properties.customLocation = props.customLocation || {};\n                break;\n        }\n\n        return properties;\n    }\n\n    /**\n     * Generate summary for working location events if not provided\n     */\n    private generateWorkingLocationSummary(args: CreateEventInput): string {\n        const props = args.workingLocationProperties;\n        if (!props) return 'Working location';\n\n        switch (props.type) {\n            case 'homeOffice':\n                return 'Working from home';\n            case 'officeLocation':\n                return props.officeLocation?.label\n                    ? `Working from ${props.officeLocation.label}`\n                    : 'Working from office';\n            case 'customLocation':\n                return props.customLocation?.label\n                    ? `Working from ${props.customLocation.label}`\n                    : 'Working from custom location';\n            default:\n                return 'Working location';\n        }\n    }\n}\n", "import { calendar_v3 } from 'googleapis';\nimport { createTimeObject } from '../../utils/datetime.js';\n\nexport class RecurringEventHelpers {\n  private calendar: calendar_v3.Calendar;\n\n  constructor(calendar: calendar_v3.Calendar) {\n    this.calendar = calendar;\n  }\n\n  /**\n   * Get the calendar instance\n   */\n  getCalendar(): calendar_v3.Calendar {\n    return this.calendar;\n  }\n\n  /**\n   * Detects if an event is recurring or single\n   */\n  async detectEventType(eventId: string, calendarId: string): Promise<'recurring' | 'single'> {\n    const response = await this.calendar.events.get({\n      calendarId,\n      eventId\n    });\n\n    const event = response.data;\n    return event.recurrence && event.recurrence.length > 0 ? 'recurring' : 'single';\n  }\n\n  /**\n   * Formats an instance ID for single instance updates\n   */\n  formatInstanceId(eventId: string, originalStartTime: string): string {\n    // Convert to UTC first, then format to basic format: YYYYMMDDTHHMMSSZ\n    const utcDate = new Date(originalStartTime);\n    const basicTimeFormat = utcDate.toISOString().replace(/[-:]/g, '').split('.')[0] + 'Z';\n    \n    return `${eventId}_${basicTimeFormat}`;\n  }\n\n  /**\n   * Calculates the UNTIL date for future instance updates\n   */\n  calculateUntilDate(futureStartDate: string): string {\n    const futureDate = new Date(futureStartDate);\n    const untilDate = new Date(futureDate.getTime() - 86400000); // -1 day\n    return untilDate.toISOString().replace(/[-:]/g, '').split('.')[0] + 'Z';\n  }\n\n  /**\n   * Calculates end time based on original duration\n   */\n  calculateEndTime(newStartTime: string, originalEvent: calendar_v3.Schema$Event): string {\n    const newStart = new Date(newStartTime);\n    const originalStart = new Date(originalEvent.start!.dateTime!);\n    const originalEnd = new Date(originalEvent.end!.dateTime!);\n    const duration = originalEnd.getTime() - originalStart.getTime();\n    \n    return new Date(newStart.getTime() + duration).toISOString();\n  }\n\n  /**\n   * Updates recurrence rule with UNTIL clause\n   */\n  updateRecurrenceWithUntil(recurrence: string[], untilDate: string): string[] {\n    if (!recurrence || recurrence.length === 0) {\n      throw new Error('No recurrence rule found');\n    }\n\n    const updatedRecurrence: string[] = [];\n    let foundRRule = false;\n\n    for (const rule of recurrence) {\n      if (rule.startsWith('RRULE:')) {\n        foundRRule = true;\n        const updatedRule = rule\n          .replace(/;UNTIL=\\d{8}T\\d{6}Z/g, '') // Remove existing UNTIL\n          .replace(/;COUNT=\\d+/g, '') // Remove COUNT if present\n          + `;UNTIL=${untilDate}`;\n        updatedRecurrence.push(updatedRule);\n      } else {\n        // Preserve EXDATE, RDATE, and other rules as-is\n        updatedRecurrence.push(rule);\n      }\n    }\n\n    if (!foundRRule) {\n      throw new Error('No RRULE found in recurrence rules');\n    }\n\n    return updatedRecurrence;\n  }\n\n  /**\n   * Cleans event fields for new event creation\n   */\n  cleanEventForDuplication(event: calendar_v3.Schema$Event): calendar_v3.Schema$Event {\n    const cleanedEvent = { ...event };\n    \n    // Remove fields that shouldn't be duplicated\n    delete cleanedEvent.id;\n    delete cleanedEvent.etag;\n    delete cleanedEvent.iCalUID;\n    delete cleanedEvent.created;\n    delete cleanedEvent.updated;\n    delete cleanedEvent.htmlLink;\n    delete cleanedEvent.hangoutLink;\n    \n    return cleanedEvent;\n  }\n\n  /**\n   * Builds request body for event updates\n   */\n  buildUpdateRequestBody(args: any, defaultTimeZone?: string): calendar_v3.Schema$Event {\n    const requestBody: calendar_v3.Schema$Event = {};\n\n    if (args.summary !== undefined && args.summary !== null) requestBody.summary = args.summary;\n    if (args.description !== undefined && args.description !== null) requestBody.description = args.description;\n    if (args.location !== undefined && args.location !== null) requestBody.location = args.location;\n    if (args.colorId !== undefined && args.colorId !== null) requestBody.colorId = args.colorId;\n    if (args.attendees !== undefined && args.attendees !== null) requestBody.attendees = args.attendees;\n    if (args.reminders !== undefined && args.reminders !== null) requestBody.reminders = args.reminders;\n    if (args.recurrence !== undefined && args.recurrence !== null) requestBody.recurrence = args.recurrence;\n    if (args.conferenceData !== undefined && args.conferenceData !== null) requestBody.conferenceData = args.conferenceData;\n    if (args.transparency !== undefined && args.transparency !== null) requestBody.transparency = args.transparency;\n    if (args.visibility !== undefined && args.visibility !== null) requestBody.visibility = args.visibility;\n    if (args.guestsCanInviteOthers !== undefined && args.guestsCanInviteOthers !== null) requestBody.guestsCanInviteOthers = args.guestsCanInviteOthers;\n    if (args.guestsCanModify !== undefined && args.guestsCanModify !== null) requestBody.guestsCanModify = args.guestsCanModify;\n    if (args.guestsCanSeeOtherGuests !== undefined && args.guestsCanSeeOtherGuests !== null) requestBody.guestsCanSeeOtherGuests = args.guestsCanSeeOtherGuests;\n    if (args.anyoneCanAddSelf !== undefined && args.anyoneCanAddSelf !== null) requestBody.anyoneCanAddSelf = args.anyoneCanAddSelf;\n    if (args.extendedProperties !== undefined && args.extendedProperties !== null) requestBody.extendedProperties = args.extendedProperties;\n    if (args.attachments !== undefined && args.attachments !== null) requestBody.attachments = args.attachments;\n    if (args.eventType !== undefined && args.eventType !== null) requestBody.eventType = args.eventType;\n\n    // Handle time changes - use createTimeObject to support both timed and all-day events\n    const effectiveTimeZone = args.timeZone || defaultTimeZone;\n\n    if (args.start !== undefined && args.start !== null) {\n      const timeObj = createTimeObject(args.start, effectiveTimeZone);\n      // When converting between formats, explicitly nullify the opposite field\n      // This is required by Google Calendar API to successfully convert between timed and all-day events\n      if (timeObj.date !== undefined) {\n        // All-day event: set date and nullify dateTime\n        requestBody.start = { date: timeObj.date, dateTime: null };\n      } else {\n        // Timed event: set dateTime/timeZone and nullify date\n        requestBody.start = { dateTime: timeObj.dateTime, timeZone: timeObj.timeZone, date: null };\n      }\n    }\n    if (args.end !== undefined && args.end !== null) {\n      const timeObj = createTimeObject(args.end, effectiveTimeZone);\n      // When converting between formats, explicitly nullify the opposite field\n      if (timeObj.date !== undefined) {\n        // All-day event: set date and nullify dateTime\n        requestBody.end = { date: timeObj.date, dateTime: null };\n      } else {\n        // Timed event: set dateTime/timeZone and nullify date\n        requestBody.end = { dateTime: timeObj.dateTime, timeZone: timeObj.timeZone, date: null };\n      }\n    }\n\n    return requestBody;\n  }\n}\n\n/**\n * Custom error class for recurring event errors\n */\nexport class RecurringEventError extends Error {\n  public code: string;\n\n  constructor(message: string, code: string) {\n    super(message);\n    this.name = 'RecurringEventError';\n    this.code = code;\n  }\n}\n\nexport const RECURRING_EVENT_ERRORS = {\n  INVALID_SCOPE: 'INVALID_MODIFICATION_SCOPE',\n  MISSING_ORIGINAL_TIME: 'MISSING_ORIGINAL_START_TIME',\n  MISSING_FUTURE_DATE: 'MISSING_FUTURE_START_DATE',\n  PAST_FUTURE_DATE: 'FUTURE_DATE_IN_PAST',\n  NON_RECURRING_SCOPE: 'SCOPE_NOT_APPLICABLE_TO_SINGLE_EVENT'\n}; ", "import { CallToolResult, McpError, ErrorCode } from \"@modelcontextprotocol/sdk/types.js\";\nimport { OAuth2Client } from \"google-auth-library\";\nimport { UpdateEventInput } from \"../../tools/registry.js\";\nimport { BaseToolHandler } from \"./BaseToolHandler.js\";\nimport { calendar_v3 } from 'googleapis';\nimport { RecurringEventHelpers, RecurringEventError, RECURRING_EVENT_ERRORS } from './RecurringEventHelpers.js';\nimport { ConflictDetectionService } from \"../../services/conflict-detection/index.js\";\nimport { createTimeObject } from \"../../utils/datetime.js\";\nimport { \n    createStructuredResponse, \n    convertConflictsToStructured,\n    createWarningsArray\n} from \"../../utils/response-builder.js\";\nimport { \n    UpdateEventResponse,\n    convertGoogleEventToStructured \n} from \"../../types/structured-responses.js\";\n\nexport class UpdateEventHandler extends BaseToolHandler {\n    private conflictDetectionService: ConflictDetectionService;\n\n    constructor() {\n        super();\n        this.conflictDetectionService = new ConflictDetectionService();\n    }\n\n    async runTool(args: any, accounts: Map<string, OAuth2Client>): Promise<CallToolResult> {\n        const validArgs = args as UpdateEventInput;\n\n        // Setup write operation: get client, calendar API, and resolve calendar name to ID\n        const { client: oauth2Client, calendar, accountId: selectedAccountId, calendarId: resolvedCalendarId } =\n            await this.setupOperation(args.account, validArgs.calendarId, accounts, 'write');\n\n        // Fetch existing event if needed for conflict checking or attendees merge\n        const needsExistingEvent =\n            (validArgs.checkConflicts !== false && (validArgs.start || validArgs.end)) ||\n            (validArgs.attendees !== undefined && validArgs.attendees !== null);\n\n        let existingEvent: calendar_v3.Schema$Event | null = null;\n        if (needsExistingEvent) {\n            const existingEventResponse = await calendar.events.get({\n                calendarId: resolvedCalendarId,\n                eventId: validArgs.eventId\n            });\n            existingEvent = existingEventResponse.data;\n\n            if (!existingEvent) {\n                throw new Error('Event not found');\n            }\n        }\n\n        // Check for conflicts if enabled\n        let conflicts = null;\n        if (validArgs.checkConflicts !== false && (validArgs.start || validArgs.end) && existingEvent) {\n            // Create updated event object for conflict checking\n            const timezone = validArgs.timeZone || await this.getCalendarTimezone(oauth2Client, resolvedCalendarId);\n            const eventToCheck: calendar_v3.Schema$Event = {\n                ...existingEvent,\n                id: validArgs.eventId,\n                summary: validArgs.summary || existingEvent.summary,\n                description: validArgs.description || existingEvent.description,\n                start: validArgs.start ? createTimeObject(validArgs.start, timezone) : existingEvent.start,\n                end: validArgs.end ? createTimeObject(validArgs.end, timezone) : existingEvent.end,\n                location: validArgs.location || existingEvent.location,\n            };\n\n            // Check for conflicts\n            conflicts = await this.conflictDetectionService.checkConflicts(\n                oauth2Client,\n                eventToCheck,\n                resolvedCalendarId,\n                {\n                    checkDuplicates: false, // Don't check duplicates for updates\n                    checkConflicts: true,\n                    calendarsToCheck: validArgs.calendarsToCheck || [resolvedCalendarId]\n                }\n            );\n        }\n\n        // Merge attendees if provided - preserve existing attendee properties (responseStatus, etc.)\n        let argsWithMergedAttendees: UpdateEventInput & { calendarId: string } = { ...validArgs, calendarId: resolvedCalendarId };\n        if (validArgs.attendees !== undefined && validArgs.attendees !== null && existingEvent) {\n            const mergedAttendees = this.mergeAttendees(existingEvent.attendees || [], validArgs.attendees);\n            // Cast needed because mergeAttendees returns full attendee objects with responseStatus etc.\n            argsWithMergedAttendees = {\n                ...argsWithMergedAttendees,\n                attendees: mergedAttendees as UpdateEventInput['attendees']\n            };\n        }\n\n        // Update the event with resolved calendar ID and merged attendees\n        const event = await this.updateEventWithScope(oauth2Client, argsWithMergedAttendees);\n\n        // Create structured response\n        const response: UpdateEventResponse = {\n            event: convertGoogleEventToStructured(event, resolvedCalendarId, selectedAccountId)\n        };\n        \n        // Add conflict information if present\n        if (conflicts && conflicts.hasConflicts) {\n            const structuredConflicts = convertConflictsToStructured(conflicts);\n            if (structuredConflicts.conflicts) {\n                response.conflicts = structuredConflicts.conflicts;\n            }\n            response.warnings = createWarningsArray(conflicts);\n        }\n        \n        return createStructuredResponse(response);\n    }\n\n    private async updateEventWithScope(\n        client: OAuth2Client,\n        args: UpdateEventInput\n    ): Promise<calendar_v3.Schema$Event> {\n        try {\n            const calendar = this.getCalendar(client);\n            const helpers = new RecurringEventHelpers(calendar);\n            \n            // Get calendar's default timezone if not provided\n            const defaultTimeZone = await this.getCalendarTimezone(client, args.calendarId);\n            \n            // Detect event type and validate scope usage\n            const eventType = await helpers.detectEventType(args.eventId, args.calendarId);\n            \n            if (args.modificationScope && args.modificationScope !== 'all' && eventType !== 'recurring') {\n                throw new RecurringEventError(\n                    'Scope other than \"all\" only applies to recurring events',\n                    RECURRING_EVENT_ERRORS.NON_RECURRING_SCOPE\n                );\n            }\n            \n            switch (args.modificationScope) {\n                case 'thisEventOnly':\n                    return this.updateSingleInstance(helpers, args, defaultTimeZone);\n                case 'all':\n                case undefined:\n                    return this.updateAllInstances(helpers, args, defaultTimeZone);\n                case 'thisAndFollowing':\n                    return this.updateFutureInstances(helpers, args, defaultTimeZone);\n                default:\n                    throw new RecurringEventError(\n                        `Invalid modification scope: ${args.modificationScope}`,\n                        RECURRING_EVENT_ERRORS.INVALID_SCOPE\n                    );\n            }\n        } catch (error) {\n            if (error instanceof RecurringEventError) {\n                throw error;\n            }\n            throw this.handleGoogleApiError(error);\n        }\n    }\n\n    private async updateSingleInstance(\n        helpers: RecurringEventHelpers,\n        args: UpdateEventInput,\n        defaultTimeZone: string\n    ): Promise<calendar_v3.Schema$Event> {\n        if (!args.originalStartTime) {\n            throw new RecurringEventError(\n                'originalStartTime is required for single instance updates',\n                RECURRING_EVENT_ERRORS.MISSING_ORIGINAL_TIME\n            );\n        }\n\n        const calendar = helpers.getCalendar();\n        const instanceId = helpers.formatInstanceId(args.eventId, args.originalStartTime);\n\n        const requestBody = helpers.buildUpdateRequestBody(args, defaultTimeZone);\n        const conferenceDataVersion = requestBody.conferenceData !== undefined ? 1 : undefined;\n        const supportsAttachments = requestBody.attachments !== undefined ? true : undefined;\n\n        const response = await calendar.events.patch({\n            calendarId: args.calendarId,\n            eventId: instanceId,\n            requestBody,\n            ...(conferenceDataVersion && { conferenceDataVersion }),\n            ...(supportsAttachments && { supportsAttachments })\n        });\n\n        if (!response.data) throw new Error('Failed to update event instance');\n        return response.data;\n    }\n\n    private async updateAllInstances(\n        helpers: RecurringEventHelpers,\n        args: UpdateEventInput,\n        defaultTimeZone: string\n    ): Promise<calendar_v3.Schema$Event> {\n        const calendar = helpers.getCalendar();\n\n        const requestBody = helpers.buildUpdateRequestBody(args, defaultTimeZone);\n        const conferenceDataVersion = requestBody.conferenceData !== undefined ? 1 : undefined;\n        const supportsAttachments = requestBody.attachments !== undefined ? true : undefined;\n\n        const response = await calendar.events.patch({\n            calendarId: args.calendarId,\n            eventId: args.eventId,\n            requestBody,\n            ...(conferenceDataVersion && { conferenceDataVersion }),\n            ...(supportsAttachments && { supportsAttachments })\n        });\n\n        if (!response.data) throw new Error('Failed to update event');\n        return response.data;\n    }\n\n    private async updateFutureInstances(\n        helpers: RecurringEventHelpers,\n        args: UpdateEventInput,\n        defaultTimeZone: string\n    ): Promise<calendar_v3.Schema$Event> {\n        if (!args.futureStartDate) {\n            throw new RecurringEventError(\n                'futureStartDate is required for future instance updates',\n                RECURRING_EVENT_ERRORS.MISSING_FUTURE_DATE\n            );\n        }\n\n        const calendar = helpers.getCalendar();\n        const effectiveTimeZone = args.timeZone || defaultTimeZone;\n\n        // 1. Get original event\n        const originalResponse = await calendar.events.get({\n            calendarId: args.calendarId,\n            eventId: args.eventId\n        });\n        const originalEvent = originalResponse.data;\n\n        if (!originalEvent.recurrence) {\n            throw new Error('Event does not have recurrence rules');\n        }\n\n        // 2. Calculate UNTIL date and update original event\n        const untilDate = helpers.calculateUntilDate(args.futureStartDate);\n        const updatedRecurrence = helpers.updateRecurrenceWithUntil(originalEvent.recurrence, untilDate);\n\n        await calendar.events.patch({\n            calendarId: args.calendarId,\n            eventId: args.eventId,\n            requestBody: { recurrence: updatedRecurrence }\n        });\n\n        // 3. Create new recurring event starting from future date\n        const requestBody = helpers.buildUpdateRequestBody(args, defaultTimeZone);\n        \n        // Calculate end time if start time is changing\n        let endTime = args.end;\n        if (args.start || args.futureStartDate) {\n            const newStartTime = args.start || args.futureStartDate;\n            endTime = endTime || helpers.calculateEndTime(newStartTime, originalEvent);\n        }\n\n        const newEvent = {\n            ...helpers.cleanEventForDuplication(originalEvent),\n            ...requestBody,\n            start: { \n                dateTime: args.start || args.futureStartDate, \n                timeZone: effectiveTimeZone \n            },\n            end: { \n                dateTime: endTime, \n                timeZone: effectiveTimeZone \n            }\n        };\n\n        const conferenceDataVersion = newEvent.conferenceData !== undefined ? 1 : undefined;\n        const supportsAttachments = newEvent.attachments !== undefined ? true : undefined;\n\n        const response = await calendar.events.insert({\n            calendarId: args.calendarId,\n            requestBody: newEvent,\n            ...(conferenceDataVersion && { conferenceDataVersion }),\n            ...(supportsAttachments && { supportsAttachments })\n        });\n\n        if (!response.data) throw new Error('Failed to create new recurring event');\n        return response.data;\n    }\n\n    /**\n     * Merge new attendees with existing attendees, preserving properties like responseStatus.\n     * - Existing attendees: keep all their properties (responseStatus, displayName, etc.)\n     * - New attendees (not in existing list): add with only the provided email\n     */\n    private mergeAttendees(\n        existingAttendees: calendar_v3.Schema$EventAttendee[],\n        newAttendees: Array<{ email: string }>\n    ): calendar_v3.Schema$EventAttendee[] {\n        const existingByEmail = new Map<string, calendar_v3.Schema$EventAttendee>();\n        for (const attendee of existingAttendees) {\n            if (attendee.email) {\n                existingByEmail.set(attendee.email.toLowerCase(), attendee);\n            }\n        }\n\n        const mergedAttendees: calendar_v3.Schema$EventAttendee[] = [];\n\n        // Process new attendees list - preserve existing data or add new\n        for (const newAttendee of newAttendees) {\n            const existing = existingByEmail.get(newAttendee.email.toLowerCase());\n            if (existing) {\n                // Preserve all existing properties (responseStatus, displayName, etc.)\n                mergedAttendees.push(existing);\n            } else {\n                // New attendee - add with only the email\n                mergedAttendees.push({ email: newAttendee.email });\n            }\n        }\n\n        return mergedAttendees;\n    }\n\n}\n", "import { CallToolResult, McpError, ErrorCode } from \"@modelcontextprotocol/sdk/types.js\";\nimport { OAuth2Client } from \"google-auth-library\";\nimport { BaseToolHandler } from \"./BaseToolHandler.js\";\nimport { DeleteEventInput } from \"../../tools/registry.js\";\nimport { DeleteEventResponse } from \"../../types/structured-responses.js\";\nimport { createStructuredResponse } from \"../../utils/response-builder.js\";\n\nexport class DeleteEventHandler extends BaseToolHandler {\n    async runTool(args: any, accounts: Map<string, OAuth2Client>): Promise<CallToolResult> {\n        const validArgs = args as DeleteEventInput;\n\n        // Get OAuth2Client with automatic account selection for write operations\n        // Also resolves calendar name to ID if a name was provided\n        const { client: oauth2Client, calendarId: resolvedCalendarId } = await this.getClientWithAutoSelection(\n            args.account,\n            validArgs.calendarId,\n            accounts,\n            'write'\n        );\n\n        // Delete the event with resolved calendar ID\n        const argsWithResolvedCalendar = { ...validArgs, calendarId: resolvedCalendarId };\n        await this.deleteEvent(oauth2Client, argsWithResolvedCalendar);\n\n        const response: DeleteEventResponse = {\n            success: true,\n            eventId: validArgs.eventId,\n            calendarId: resolvedCalendarId,\n            message: \"Event deleted successfully\"\n        };\n\n        return createStructuredResponse(response);\n    }\n\n    private async deleteEvent(\n        client: OAuth2Client,\n        args: DeleteEventInput\n    ): Promise<void> {\n        try {\n            const calendar = this.getCalendar(client);\n            await calendar.events.delete({\n                calendarId: args.calendarId,\n                eventId: args.eventId,\n                sendUpdates: args.sendUpdates,\n            });\n        } catch (error) {\n            throw this.handleGoogleApiError(error);\n        }\n    }\n}\n", "import { BaseToolHandler } from './BaseToolHandler.js';\nimport { CallToolResult } from \"@modelcontextprotocol/sdk/types.js\";\nimport { OAuth2Client } from \"google-auth-library\";\nimport { GetFreeBusyInput } from \"../../tools/registry.js\";\nimport { FreeBusyResponse as GoogleFreeBusyResponse } from '../../schemas/types.js';\nimport { FreeBusyResponse, BusySlot } from '../../types/structured-responses.js';\nimport { createStructuredResponse } from '../../utils/response-builder.js';\nimport { McpError } from '@modelcontextprotocol/sdk/types.js';\nimport { ErrorCode } from '@modelcontextprotocol/sdk/types.js';\nimport { convertToRFC3339 } from '../../utils/datetime.js';\n\ninterface FreeBusyCalendarResult {\n  busy: BusySlot[];\n  errors?: Array<{ domain?: string; reason?: string }>;\n}\n\nexport class FreeBusyEventHandler extends BaseToolHandler {\n  async runTool(args: any, accounts: Map<string, OAuth2Client>): Promise<CallToolResult> {\n    const validArgs = args as GetFreeBusyInput;\n\n    if (!this.isLessThanThreeMonths(validArgs.timeMin, validArgs.timeMax)) {\n      throw new McpError(\n        ErrorCode.InvalidRequest,\n        \"The time gap between timeMin and timeMax must be less than 3 months\"\n      );\n    }\n\n    // Get clients for specified accounts (or all if not specified)\n    const selectedAccounts = this.getClientsForAccounts(args.account, accounts);\n\n    // Query freebusy from all selected accounts and merge results\n    const mergedCalendars = await this.queryFreeBusyMultiAccount(selectedAccounts, validArgs);\n\n    const response: FreeBusyResponse = {\n      timeMin: validArgs.timeMin,\n      timeMax: validArgs.timeMax,\n      calendars: mergedCalendars\n    };\n\n    return createStructuredResponse(response);\n  }\n\n  private async queryFreeBusyMultiAccount(\n    accounts: Map<string, OAuth2Client>,\n    args: GetFreeBusyInput\n  ): Promise<Record<string, FreeBusyCalendarResult>> {\n    const mergedCalendars: Record<string, FreeBusyCalendarResult> = {};\n    const calendarIds = args.calendars.map(c => c.id);\n\n    // For multi-account queries, pre-resolve which calendars exist on which accounts\n    // This prevents the \"cartesian product\" problem where we try to query all calendars\n    // from all accounts, causing failures when a calendar doesn't exist on an account\n    let accountCalendarMap: Map<string, string[]>;\n    const resolutionWarnings: string[] = [];\n\n    if (accounts.size > 1) {\n      const { resolved, warnings } = await this.calendarRegistry.resolveCalendarsToAccounts(\n        calendarIds,\n        accounts\n      );\n      accountCalendarMap = resolved;\n      resolutionWarnings.push(...warnings);\n\n      // If no calendars could be resolved, mark all as not found\n      if (accountCalendarMap.size === 0) {\n        for (const calId of calendarIds) {\n          mergedCalendars[calId] = {\n            busy: [],\n            errors: [{ reason: 'notFound' }]\n          };\n        }\n        return mergedCalendars;\n      }\n    } else {\n      // Single account: send all calendars to that account\n      const [accountId] = accounts.keys();\n      accountCalendarMap = new Map([[accountId, calendarIds]]);\n    }\n\n    // Query from each account with only the calendars that exist on that account\n    const results = await Promise.all(\n      Array.from(accountCalendarMap.entries()).map(async ([accountId, calendarsForAccount]) => {\n        const client = accounts.get(accountId)!;\n        try {\n          // Filter args.calendars to only include those routed to this account\n          const filteredArgs: GetFreeBusyInput = {\n            ...args,\n            calendars: args.calendars.filter(c => calendarsForAccount.includes(c.id))\n          };\n          const result = await this.queryFreeBusy(client, filteredArgs);\n          return { accountId, result, error: null, calendarsQueried: calendarsForAccount };\n        } catch (error) {\n          // Log but don't fail - other accounts might succeed\n          const message = error instanceof Error ? error.message : String(error);\n          process.stderr.write(`Warning: FreeBusy query failed for account \"${accountId}\": ${message}\\n`);\n          return { accountId, result: null, error: message, calendarsQueried: calendarsForAccount };\n        }\n      })\n    );\n\n    // Merge results from all accounts\n    // For each calendar, prefer results without errors\n    for (const calId of calendarIds) {\n      let bestResult: FreeBusyCalendarResult | null = null;\n\n      for (const { result } of results) {\n        if (!result?.calendars) continue;\n\n        const calData = result.calendars[calId];\n        if (!calData) continue;\n\n        // If we don't have a result yet, or this one has no errors but previous did, use this one\n        if (!bestResult) {\n          bestResult = {\n            busy: calData.busy?.map((slot: any) => ({ start: slot.start, end: slot.end })) || [],\n            errors: calData.errors?.map((err: any) => ({ domain: err.domain, reason: err.reason }))\n          };\n        } else if (bestResult.errors && !calData.errors) {\n          // Current best has errors but this one doesn't - prefer this one\n          bestResult = {\n            busy: calData.busy?.map((slot: any) => ({ start: slot.start, end: slot.end })) || []\n          };\n        }\n      }\n\n      // If no account returned data for this calendar, mark it as not found\n      if (!bestResult) {\n        mergedCalendars[calId] = {\n          busy: [],\n          errors: [{ reason: 'notFound' }]\n        };\n      } else {\n        mergedCalendars[calId] = bestResult;\n      }\n    }\n\n    return mergedCalendars;\n  }\n\n  private async queryFreeBusy(\n    client: OAuth2Client,\n    args: GetFreeBusyInput\n  ): Promise<GoogleFreeBusyResponse> {\n    try {\n      const calendar = this.getCalendar(client);\n\n      // Determine timezone with correct precedence:\n      // 1. Explicit timeZone parameter (highest priority)\n      // 2. Primary calendar's default timezone (fallback)\n      // 3. UTC if calendar timezone retrieval fails\n      let timezone: string;\n      if (args.timeZone) {\n        timezone = args.timeZone;\n      } else {\n        try {\n          timezone = await this.getCalendarTimezone(client, 'primary');\n        } catch (error) {\n          // If we can't get the primary calendar's timezone, fall back to UTC\n          // This can happen if the user doesn't have access to 'primary' calendar\n          timezone = 'UTC';\n        }\n      }\n\n      // Convert time boundaries to RFC3339 format for Google Calendar API\n      // This handles both timezone-aware and timezone-naive datetime strings\n      const timeMin = convertToRFC3339(args.timeMin, timezone);\n      const timeMax = convertToRFC3339(args.timeMax, timezone);\n\n      // Build request body\n      // Note: The timeZone parameter affects the response format, not request interpretation\n      // Since timeMin/timeMax are in RFC3339 (with timezone), they're unambiguous\n      // But we include timeZone so busy periods in the response use consistent timezone\n      const requestBody: any = {\n        timeMin,\n        timeMax,\n        items: args.calendars,\n        timeZone: timezone, // Always include to ensure response consistency\n      };\n\n      // Only add optional expansion fields if provided\n      if (args.groupExpansionMax !== undefined) {\n        requestBody.groupExpansionMax = args.groupExpansionMax;\n      }\n      if (args.calendarExpansionMax !== undefined) {\n        requestBody.calendarExpansionMax = args.calendarExpansionMax;\n      }\n\n      const response = await calendar.freebusy.query({\n        requestBody,\n      });\n      return response.data as GoogleFreeBusyResponse;\n    } catch (error) {\n      throw this.handleGoogleApiError(error);\n    }\n  }\n\n  private isLessThanThreeMonths(timeMin: string, timeMax: string): boolean {\n    const minDate = new Date(timeMin);\n    const maxDate = new Date(timeMax);\n\n    const diffInMilliseconds = maxDate.getTime() - minDate.getTime();\n    const threeMonthsInMilliseconds = 3 * 30 * 24 * 60 * 60 * 1000;\n\n    return diffInMilliseconds <= threeMonthsInMilliseconds;\n  }\n}\n", "import { CallToolResult } from \"@modelcontextprotocol/sdk/types.js\";\nimport { OAuth2Client } from \"google-auth-library\";\nimport { BaseToolHandler } from \"./BaseToolHandler.js\";\nimport { McpError, ErrorCode } from \"@modelcontextprotocol/sdk/types.js\";\nimport { GetCurrentTimeInput } from \"../../tools/registry.js\";\nimport { createStructuredResponse } from \"../../utils/response-builder.js\";\nimport { GetCurrentTimeResponse } from \"../../types/structured-responses.js\";\n\nexport class GetCurrentTimeHandler extends BaseToolHandler {\n    async runTool(args: any, accounts: Map<string, OAuth2Client>): Promise<CallToolResult> {\n        // Validate arguments using schema\n        const validArgs = args as GetCurrentTimeInput;\n\n        // Use specified account or default to first available account\n        // (get-current-time only needs any authenticated client for timezone lookup)\n        const oauth2Client = this.getClientForAccountOrFirst(args.account, accounts);\n        \n        const now = new Date();\n        \n        // If no timezone provided, use the primary Google Calendar's default timezone\n        const requestedTimeZone = validArgs.timeZone;\n        \n        let timezone: string;\n        if (validArgs.timeZone) {\n            if (!this.isValidTimeZone(validArgs.timeZone)) {\n                throw new McpError(\n                    ErrorCode.InvalidRequest,\n                    `Invalid timezone: ${validArgs.timeZone}. Use IANA format (e.g. 'America/Los_Angeles').`\n                );\n            }\n            timezone = validArgs.timeZone;\n        } else {\n            try {\n                timezone = await this.getCalendarTimezone(oauth2Client, 'primary');\n                if (timezone === 'UTC') {\n                    const sys = this.getSystemTimeZone();\n                    if (sys !== 'UTC') timezone = sys;\n                }\n            } catch {\n                timezone = this.getSystemTimeZone();\n            }\n        }\n\n        const response: GetCurrentTimeResponse = {\n            currentTime: this.formatISOInZone(now, timezone),\n            timezone: timezone,\n            offset: this.getTimezoneOffset(now, timezone),\n            isDST: this.isDaylightSavingTime(now, timezone),\n            dayOfWeek: new Intl.DateTimeFormat('en-US', {\n                weekday: 'long',\n                timeZone: timezone\n            }).format(now)\n        };\n\n        return createStructuredResponse(response);\n    }\n\n    /**\n     * Formats a Date object as an ISO 8601 string in a specific timezone with offset.\n     *\n     * This method uses Intl.DateTimeFormat to extract date/time components in the target\n     * timezone and constructs an ISO string with the timezone offset appended.\n     *\n     * @param date - The Date object to format\n     * @param timeZone - IANA timezone identifier (e.g., 'America/Los_Angeles', 'UTC')\n     * @returns ISO 8601 string with timezone offset (e.g., '2025-11-04T14:30:00.123-08:00' or '2025-11-04T14:30:00.123Z')\n     *\n     * @example\n     * formatISOInZone(new Date('2025-11-04T22:30:00.000Z'), 'America/Los_Angeles')\n     * // Returns: '2025-11-04T14:30:00.000-08:00'\n     *\n     * @example\n     * formatISOInZone(new Date('2025-11-04T14:30:00.000Z'), 'UTC')\n     * // Returns: '2025-11-04T14:30:00.000Z'\n     */\n    private formatISOInZone(date: Date, timeZone: string): string {\n        const parts = new Intl.DateTimeFormat('sv-SE', {\n            timeZone,\n            year: 'numeric',\n            month: '2-digit',\n            day: '2-digit',\n            hour: '2-digit',\n            minute: '2-digit',\n            second: '2-digit',\n            hour12: false,\n            fractionalSecondDigits: 3   // keep milliseconds\n        }).formatToParts(date);\n\n        const map = parts.reduce((acc, p) => {\n            acc[p.type] = p.value;\n            return acc;\n        }, {} as Record<string, string>);\n\n        const iso = `${map.year}-${map.month}-${map.day}T${map.hour}:${map.minute}:${map.second}.${map.fractionalSecond || '000'}`;\n        const offset = this.getTimezoneOffset(date, timeZone);\n        return offset === 'Z' ? `${iso}Z` : `${iso}${offset}`;\n    }\n\n    private getSystemTimeZone(): string {\n        try {\n            return Intl.DateTimeFormat().resolvedOptions().timeZone;\n        } catch {\n            return 'UTC'; // Fallback to UTC if system timezone detection fails\n        }\n    }\n    \n    private isValidTimeZone(timeZone: string): boolean {\n        try {\n            Intl.DateTimeFormat(undefined, { timeZone });\n            return true;\n        } catch {\n            return false;\n        }\n    }\n\n    private getTimezoneOffset(_date: Date, timeZone: string): string {\n        try {\n            const offsetMinutes = this.getTimezoneOffsetMinutes(timeZone);\n            \n            if (offsetMinutes === 0) {\n                return 'Z';\n            }\n            \n            const offsetHours = Math.floor(Math.abs(offsetMinutes) / 60);\n            const offsetMins = Math.abs(offsetMinutes) % 60;\n            const sign = offsetMinutes >= 0 ? '+' : '-';\n            \n            return `${sign}${offsetHours.toString().padStart(2, '0')}:${offsetMins.toString().padStart(2, '0')}`;\n        } catch {\n            return 'Z'; // Fallback to UTC if offset calculation fails\n        }\n    }\n    \n    private getTimezoneOffsetMinutes(timeZone: string): number {\n        return this.getTimezoneOffsetForDate(new Date(), timeZone);\n    }\n\n    private isDaylightSavingTime(date: Date, timeZone: string): boolean {\n        try {\n            // Get offset for the given date\n            const currentOffset = this.getTimezoneOffsetForDate(date, timeZone);\n\n            // Get offset for January 1st (typically standard time)\n            const january = new Date(date.getFullYear(), 0, 1);\n            const januaryOffset = this.getTimezoneOffsetForDate(january, timeZone);\n\n            // Get offset for July 1st (typically daylight saving time if applicable)\n            const july = new Date(date.getFullYear(), 6, 1);\n            const julyOffset = this.getTimezoneOffsetForDate(july, timeZone);\n\n            // If January and July have different offsets, DST is observed\n            // Current date is in DST if its offset matches the smaller offset (more negative/less positive)\n            if (januaryOffset !== julyOffset) {\n                const dstOffset = Math.min(januaryOffset, julyOffset);\n                return currentOffset === dstOffset;\n            }\n\n            return false;\n        } catch {\n            return false;\n        }\n    }\n\n    private getTimezoneOffsetForDate(date: Date, timeZone: string): number {\n        // Get local time for the target timezone\n        const targetTimeString = new Intl.DateTimeFormat('sv-SE', {\n            timeZone: timeZone,\n            year: 'numeric',\n            month: '2-digit',\n            day: '2-digit',\n            hour: '2-digit',\n            minute: '2-digit',\n            second: '2-digit'\n        }).format(date);\n\n        // Get UTC time string\n        const utcTimeString = new Intl.DateTimeFormat('sv-SE', {\n            timeZone: 'UTC',\n            year: 'numeric',\n            month: '2-digit',\n            day: '2-digit',\n            hour: '2-digit',\n            minute: '2-digit',\n            second: '2-digit'\n        }).format(date);\n\n        // Parse both times and calculate difference in minutes\n        const targetTime = new Date(targetTimeString.replace(' ', 'T') + 'Z').getTime();\n        const utcTimeParsed = new Date(utcTimeString.replace(' ', 'T') + 'Z').getTime();\n\n        return (targetTime - utcTimeParsed) / (1000 * 60);\n    }\n}\n", "import { CallToolResult } from \"@modelcontextprotocol/sdk/types.js\";\nimport { OAuth2Client } from \"google-auth-library\";\nimport { BaseToolHandler } from \"./BaseToolHandler.js\";\nimport { calendar_v3 } from 'googleapis';\nimport { createStructuredResponse } from \"../../utils/response-builder.js\";\nimport { RespondToEventResponse, convertGoogleEventToStructured } from \"../../types/structured-responses.js\";\nimport { RecurringEventHelpers, RecurringEventError, RECURRING_EVENT_ERRORS } from './RecurringEventHelpers.js';\n\nexport type RespondToEventInput = {\n    calendarId: string;\n    eventId: string;\n    response: \"accepted\" | \"declined\" | \"tentative\" | \"needsAction\";\n    comment?: string;\n    modificationScope?: \"thisEventOnly\" | \"all\";\n    originalStartTime?: string;\n    sendUpdates?: \"all\" | \"externalOnly\" | \"none\";\n    account?: string;\n};\n\nexport class RespondToEventHandler extends BaseToolHandler {\n    async runTool(args: RespondToEventInput, accounts: Map<string, OAuth2Client>): Promise<CallToolResult> {\n        const validArgs = args;\n\n        // Setup write operation: get client, calendar API, and resolve calendar name to ID\n        const { calendar, accountId: selectedAccountId, calendarId: resolvedCalendarId } =\n            await this.setupOperation(args.account, validArgs.calendarId, accounts, 'write');\n\n        try {\n            const helpers = new RecurringEventHelpers(calendar);\n\n            // 1. Determine the target event ID (may be instance-specific for recurring events)\n            let targetEventId = validArgs.eventId;\n\n            // Handle recurring event scopes\n            if (validArgs.modificationScope === 'thisEventOnly') {\n                if (!validArgs.originalStartTime) {\n                    throw new RecurringEventError(\n                        'originalStartTime is required when modificationScope is \"thisEventOnly\"',\n                        RECURRING_EVENT_ERRORS.MISSING_ORIGINAL_TIME\n                    );\n                }\n\n                // Detect if event is recurring\n                const eventType = await helpers.detectEventType(validArgs.eventId, resolvedCalendarId);\n                if (eventType !== 'recurring') {\n                    throw new RecurringEventError(\n                        'modificationScope \"thisEventOnly\" can only be used with recurring events',\n                        RECURRING_EVENT_ERRORS.NON_RECURRING_SCOPE\n                    );\n                }\n\n                // Format instance ID for single instance response\n                targetEventId = helpers.formatInstanceId(validArgs.eventId, validArgs.originalStartTime);\n            } else if (validArgs.modificationScope === 'all') {\n                // Extract base event ID by removing instance suffix if present\n                // Instance IDs have format: baseId_YYYYMMDDTHHMMSSZ\n                // Base IDs have no underscore, so split is safe for both cases\n                targetEventId = validArgs.eventId.split('_')[0];\n            }\n            // If no scope specified, default to 'all' behavior (use base event ID)\n\n            // 2. Get the event to find the current user's attendee entry\n            const eventResponse = await calendar.events.get({\n                calendarId: resolvedCalendarId,\n                eventId: targetEventId\n            });\n\n            const event = eventResponse.data;\n            if (!event) {\n                throw new Error('Event not found');\n            }\n\n            // 3. Find the authenticated user's attendee entry (marked with self: true)\n            const attendees = event.attendees || [];\n            const selfAttendeeIndex = attendees.findIndex(a => a.self === true);\n\n            if (selfAttendeeIndex === -1) {\n                throw new Error(\n                    'You are not an attendee of this event. Only attendees can respond to event invitations.'\n                );\n            }\n\n            const selfAttendee = attendees[selfAttendeeIndex];\n\n            // 4. Check if user is the organizer (organizers don't respond to their own events)\n            if (selfAttendee.organizer === true) {\n                throw new Error(\n                    'You are the organizer of this event. Organizers do not respond to their own event invitations.'\n                );\n            }\n\n            // 5. Update the response status and optionally comment for the authenticated user\n            const updatedAttendees = [...attendees];\n            updatedAttendees[selfAttendeeIndex] = {\n                ...selfAttendee,\n                responseStatus: validArgs.response,\n                ...(validArgs.comment !== undefined && { comment: validArgs.comment })\n            };\n\n            // 6. Patch the event with the updated attendee list\n            const actualSendUpdates = validArgs.sendUpdates || \"none\";\n            const updateResponse = await calendar.events.patch({\n                calendarId: resolvedCalendarId,\n                eventId: targetEventId,\n                requestBody: {\n                    attendees: updatedAttendees\n                },\n                sendUpdates: actualSendUpdates\n            });\n\n            if (!updateResponse.data) {\n                throw new Error('Failed to update event response');\n            }\n\n            // 7. Create structured response\n            let message = `Your response has been set to \"${validArgs.response}\"`;\n            if (validArgs.modificationScope === 'thisEventOnly') {\n                message += ' for this instance only';\n            } else if (validArgs.modificationScope === 'all') {\n                message += ' for all instances';\n            }\n            if (validArgs.comment) {\n                message += ` with note: \"${validArgs.comment}\"`;\n            }\n\n            const response: RespondToEventResponse = {\n                event: convertGoogleEventToStructured(updateResponse.data, resolvedCalendarId, selectedAccountId),\n                responseStatus: validArgs.response,\n                sendUpdates: actualSendUpdates,\n                message: message\n            };\n\n            return createStructuredResponse(response);\n        } catch (error: any) {\n            if (error instanceof RecurringEventError) {\n                throw error;\n            }\n            throw this.handleGoogleApiError(error);\n        }\n    }\n}\n", "import { CallToolResult } from \"@modelcontextprotocol/sdk/types.js\";\nimport { McpError, ErrorCode } from \"@modelcontextprotocol/sdk/types.js\";\nimport { OAuth2Client } from \"google-auth-library\";\nimport { google } from \"googleapis\";\nimport { AuthServer } from \"../../auth/server.js\";\nimport { TokenManager } from \"../../auth/tokenManager.js\";\nimport { validateAccountId } from \"../../auth/paths.js\";\nimport {\n  AddAccountResponse,\n  AccountStatusResponse,\n  AccountInfo,\n  RemoveAccountResponse\n} from \"../../types/structured-responses.js\";\n\nexport type ManageAccountsAction = 'list' | 'add' | 'remove';\n\nexport interface ManageAccountsArgs {\n  action: ManageAccountsAction;\n  account_id?: string;\n}\n\nexport interface ServerContext {\n  oauth2Client: OAuth2Client;\n  tokenManager: TokenManager;\n  authServer: AuthServer;\n  accounts: Map<string, OAuth2Client>;\n  reloadAccounts: () => Promise<Map<string, OAuth2Client>>;\n}\n\n/**\n * Unified handler for managing Google accounts.\n *\n * Supports three actions:\n * - list: Show all authenticated accounts and their status\n * - add: Add a new account via OAuth authentication\n * - remove: Remove an existing account\n */\nexport class ManageAccountsHandler {\n  async runTool(args: ManageAccountsArgs, context: ServerContext): Promise<CallToolResult> {\n    switch (args.action) {\n      case 'list':\n        return this.listAccounts(args.account_id, context);\n      case 'add':\n        return this.addAccount(args.account_id, context);\n      case 'remove':\n        return this.removeAccount(args.account_id, context);\n      default:\n        throw new McpError(\n          ErrorCode.InvalidRequest,\n          `Invalid action: ${args.action}. Must be 'list', 'add', or 'remove'.`\n        );\n    }\n  }\n\n  // ============ LIST ACTION ============\n  private async listAccounts(accountId: string | undefined, context: ServerContext): Promise<CallToolResult> {\n    // Reload accounts to get the latest state\n    const accounts = await context.reloadAccounts();\n\n    // If specific account requested, filter to just that one\n    if (accountId) {\n      const normalizedId = accountId.toLowerCase();\n      const client = accounts.get(normalizedId);\n\n      if (!client) {\n        const availableAccounts = Array.from(accounts.keys()).join(', ') || 'none';\n        throw new McpError(\n          ErrorCode.InvalidRequest,\n          `Account \"${normalizedId}\" not found. Available accounts: ${availableAccounts}`\n        );\n      }\n\n      const accountInfo = await this.getAccountInfo(normalizedId, client);\n\n      const response: AccountStatusResponse = {\n        accounts: [accountInfo],\n        total_accounts: 1,\n        message: `Found account \"${normalizedId}\"`\n      };\n\n      return {\n        content: [{\n          type: \"text\",\n          text: JSON.stringify(response, null, 2)\n        }]\n      };\n    }\n\n    // Get info for all accounts\n    if (accounts.size === 0) {\n      const response: AccountStatusResponse = {\n        accounts: [],\n        total_accounts: 0,\n        message: \"No authenticated accounts found. Use manage-accounts with action 'add' and provide a nickname to connect a Google account.\"\n      };\n\n      return {\n        content: [{\n          type: \"text\",\n          text: JSON.stringify(response, null, 2)\n        }]\n      };\n    }\n\n    const accountInfos: AccountInfo[] = [];\n    const errors: string[] = [];\n\n    for (const [accId, client] of accounts) {\n      try {\n        const info = await this.getAccountInfo(accId, client);\n        accountInfos.push(info);\n      } catch (error) {\n        errors.push(`${accId}: ${error instanceof Error ? error.message : 'Unknown error'}`);\n        accountInfos.push({\n          account_id: accId,\n          status: 'error',\n          error: error instanceof Error ? error.message : 'Failed to fetch account details'\n        });\n      }\n    }\n\n    const response: AccountStatusResponse = {\n      accounts: accountInfos,\n      total_accounts: accountInfos.length,\n      message: errors.length > 0\n        ? `Found ${accountInfos.length} account(s) with ${errors.length} error(s)`\n        : `Found ${accountInfos.length} authenticated account(s)`\n    };\n\n    return {\n      content: [{\n        type: \"text\",\n        text: JSON.stringify(response, null, 2)\n      }]\n    };\n  }\n\n  private async getAccountInfo(accountId: string, client: OAuth2Client): Promise<AccountInfo> {\n    try {\n      const calendar = google.calendar({ version: 'v3', auth: client });\n\n      const calendarList = await calendar.calendarList.list();\n      const calendars = calendarList.data.items || [];\n      const primaryCalendar = calendars.find(c => c.primary);\n\n      const credentials = client.credentials;\n      const expiryDate = credentials.expiry_date;\n      const isExpired = expiryDate ? Date.now() > expiryDate : false;\n\n      const email = primaryCalendar?.id || 'unknown';\n\n      return {\n        account_id: accountId,\n        status: isExpired ? 'expired' : 'active',\n        email,\n        calendar_count: calendars.length,\n        primary_calendar: primaryCalendar ? {\n          id: primaryCalendar.id || 'primary',\n          name: primaryCalendar.summary || 'Primary Calendar',\n          timezone: primaryCalendar.timeZone || 'UTC'\n        } : undefined,\n        token_expiry: expiryDate ? new Date(expiryDate).toISOString() : undefined\n      };\n    } catch (error) {\n      const credentials = client.credentials;\n      return {\n        account_id: accountId,\n        status: credentials.refresh_token ? 'active' : 'invalid',\n        error: error instanceof Error ? error.message : 'Failed to verify account'\n      };\n    }\n  }\n\n  // ============ ADD ACTION ============\n  private async addAccount(accountId: string | undefined, context: ServerContext): Promise<CallToolResult> {\n    if (!accountId) {\n      throw new McpError(\n        ErrorCode.InvalidRequest,\n        \"account_id is required for 'add' action. Provide a nickname like 'work' or 'personal' to identify this account.\"\n      );\n    }\n\n    const normalizedId = accountId.toLowerCase();\n\n    // Validate account ID format\n    try {\n      validateAccountId(normalizedId);\n    } catch (error) {\n      throw new McpError(\n        ErrorCode.InvalidRequest,\n        error instanceof Error ? error.message : 'Invalid account nickname format'\n      );\n    }\n\n    // Check if account already exists\n    if (context.accounts.has(normalizedId)) {\n      const response: AddAccountResponse = {\n        status: 'already_authenticated',\n        account_id: normalizedId,\n        message: `An account with nickname \"${normalizedId}\" is already connected. Use action 'list' to view account details.`\n      };\n\n      return {\n        content: [{\n          type: \"text\",\n          text: JSON.stringify(response, null, 2)\n        }]\n      };\n    }\n\n    // Set the account mode for this authentication\n    process.env.GOOGLE_ACCOUNT_MODE = normalizedId;\n    context.tokenManager.setAccountMode(normalizedId);\n\n    // Start the authentication server\n    try {\n      const started = await context.authServer.startForMcpTool(normalizedId);\n\n      if (!started.success) {\n        throw new McpError(\n          ErrorCode.InternalError,\n          started.error || 'Failed to start authentication server'\n        );\n      }\n\n      const response: AddAccountResponse = {\n        status: 'awaiting_authentication',\n        account_id: normalizedId,\n        auth_url: started.authUrl!,\n        callback_url: started.callbackUrl!,\n        instructions: `Visit the auth_url in your browser to connect your Google account. This will be saved with the nickname '${normalizedId}'.`,\n        expires_in_minutes: 5,\n        next_step: \"After authenticating in your browser, use manage-accounts with action 'list' to verify the account was connected successfully.\"\n      };\n\n      return {\n        content: [{\n          type: \"text\",\n          text: JSON.stringify(response, null, 2)\n        }]\n      };\n    } catch (error) {\n      if (error instanceof McpError) {\n        throw error;\n      }\n      throw new McpError(\n        ErrorCode.InternalError,\n        `Failed to start authentication: ${error instanceof Error ? error.message : 'Unknown error'}`\n      );\n    }\n  }\n\n  // ============ REMOVE ACTION ============\n  private async removeAccount(accountId: string | undefined, context: ServerContext): Promise<CallToolResult> {\n    if (!accountId) {\n      throw new McpError(\n        ErrorCode.InvalidRequest,\n        \"account_id is required for 'remove' action. Specify the nickname of the account to remove.\"\n      );\n    }\n\n    const normalizedId = accountId.toLowerCase();\n\n    // Validate account ID format\n    try {\n      validateAccountId(normalizedId);\n    } catch (error) {\n      throw new McpError(\n        ErrorCode.InvalidRequest,\n        error instanceof Error ? error.message : 'Invalid account nickname format'\n      );\n    }\n\n    // Reload accounts to get current state\n    const accounts = await context.reloadAccounts();\n\n    // Check if account exists\n    if (!accounts.has(normalizedId)) {\n      const availableAccounts = Array.from(accounts.keys()).join(', ') || 'none';\n      throw new McpError(\n        ErrorCode.InvalidRequest,\n        `Account \"${normalizedId}\" not found. Available accounts: ${availableAccounts}`\n      );\n    }\n\n    // Prevent removing the last account\n    if (accounts.size === 1) {\n      throw new McpError(\n        ErrorCode.InvalidRequest,\n        `Cannot remove the last authenticated account. Use action 'add' to connect another account first, then remove this one.`\n      );\n    }\n\n    // Remove the account\n    try {\n      await context.tokenManager.removeAccount(normalizedId);\n\n      // Reload accounts to confirm removal\n      const updatedAccounts = await context.reloadAccounts();\n      const remainingAccounts = Array.from(updatedAccounts.keys());\n\n      const response: RemoveAccountResponse = {\n        success: true,\n        account_id: normalizedId,\n        message: `Account \"${normalizedId}\" has been removed successfully.`,\n        remaining_accounts: remainingAccounts\n      };\n\n      return {\n        content: [{\n          type: \"text\",\n          text: JSON.stringify(response, null, 2)\n        }]\n      };\n    } catch (error) {\n      throw new McpError(\n        ErrorCode.InternalError,\n        `Failed to remove account: ${error instanceof Error ? error.message : 'Unknown error'}`\n      );\n    }\n  }\n}\n", "import { McpServer } from \"@modelcontextprotocol/sdk/server/mcp.js\";\nimport { StdioServerTransport } from \"@modelcontextprotocol/sdk/server/stdio.js\";\n\nexport class StdioTransportHandler {\n  private server: McpServer;\n\n  constructor(server: McpServer) {\n    this.server = server;\n  }\n\n  async connect(): Promise<void> {\n    const transport = new StdioServerTransport();\n    await this.server.connect(transport);\n  }\n} ", "import { McpServer } from \"@modelcontextprotocol/sdk/server/mcp.js\";\nimport { StreamableHTTPServerTransport } from \"@modelcontextprotocol/sdk/server/streamableHttp.js\";\nimport http from \"http\";\nimport { TokenManager } from \"../auth/tokenManager.js\";\nimport { CalendarRegistry } from \"../services/CalendarRegistry.js\";\nimport { renderAuthSuccess, renderAuthError, loadWebFile } from \"../web/templates.js\";\n\n/**\n * Security headers for HTML responses\n * Note: HTTP mode is designed for localhost development/testing only.\n * For production deployments, use stdio mode with Claude Desktop.\n */\nconst SECURITY_HEADERS = {\n  'Content-Security-Policy': \"default-src 'self'; script-src 'self' 'unsafe-inline'; style-src 'self' 'unsafe-inline'; frame-ancestors 'none'\",\n  'X-Frame-Options': 'DENY',\n  'X-Content-Type-Options': 'nosniff',\n  'Referrer-Policy': 'strict-origin-when-cross-origin',\n  'X-XSS-Protection': '1; mode=block'\n};\n\n\n/**\n * Validate if an origin is from localhost\n * Properly parses the URL to prevent bypass via subdomains like localhost.attacker.com\n * Exported for testing\n */\nexport function isLocalhostOrigin(origin: string): boolean {\n  try {\n    const url = new URL(origin);\n    const hostname = url.hostname;\n    // Only allow exact localhost or 127.0.0.1\n    return hostname === 'localhost' || hostname === '127.0.0.1';\n  } catch {\n    // Invalid URL - reject\n    return false;\n  }\n}\n\nexport interface HttpTransportConfig {\n  port?: number;\n  host?: string;\n}\n\nexport class HttpTransportHandler {\n  private server: McpServer;\n  private config: HttpTransportConfig;\n  private tokenManager: TokenManager;\n\n  constructor(\n    server: McpServer,\n    config: HttpTransportConfig = {},\n    tokenManager: TokenManager\n  ) {\n    this.server = server;\n    this.config = config;\n    this.tokenManager = tokenManager;\n  }\n\n  /**\n   * Creates an OAuth2Client configured for the given account.\n   * Consolidates credential loading and redirect URI construction.\n   */\n  private async createOAuth2Client(accountId: string, host: string, port: number): Promise<import('google-auth-library').OAuth2Client> {\n    const { OAuth2Client } = await import('google-auth-library');\n    const { loadCredentials } = await import('../auth/client.js');\n    const { client_id, client_secret } = await loadCredentials();\n    return new OAuth2Client(\n      client_id,\n      client_secret,\n      `http://${host}:${port}/oauth2callback?account=${accountId}`\n    );\n  }\n\n  /**\n   * Generates an OAuth authorization URL with standard settings.\n   */\n  private generateOAuthUrl(client: import('google-auth-library').OAuth2Client): string {\n    return client.generateAuthUrl({\n      access_type: 'offline',\n      scope: ['https://www.googleapis.com/auth/calendar'],\n      prompt: 'consent'\n    });\n  }\n\n  /**\n   * Validates an account ID format.\n   * Throws an error if the format is invalid.\n   */\n  private async validateAccountId(accountId: string): Promise<void> {\n    const { validateAccountId } = await import('../auth/paths.js') as any;\n    validateAccountId(accountId);\n  }\n\n  private parseRequestBody(req: http.IncomingMessage): Promise<any> {\n    return new Promise((resolve, reject) => {\n      let body = '';\n      req.on('data', chunk => body += chunk.toString());\n      req.on('end', () => {\n        try {\n          resolve(body ? JSON.parse(body) : {});\n        } catch (error) {\n          reject(new Error('Invalid JSON in request body'));\n        }\n      });\n      req.on('error', reject);\n    });\n  }\n\n  async connect(): Promise<void> {\n    const port = this.config.port || 3000;\n    const host = this.config.host || '127.0.0.1';\n\n    // Configure transport for stateless mode to allow multiple initialization cycles\n    const transport = new StreamableHTTPServerTransport({\n      sessionIdGenerator: undefined // Stateless mode - allows multiple initializations\n    });\n\n    await this.server.connect(transport);\n\n    // Create HTTP server to handle the StreamableHTTP transport\n    const httpServer = http.createServer(async (req, res) => {\n      // Validate Origin header to prevent DNS rebinding attacks (MCP spec requirement)\n      const origin = req.headers.origin;\n\n      // For requests with Origin header, validate it using proper URL parsing\n      // This prevents bypass via subdomains like localhost.attacker.com\n      if (origin && !isLocalhostOrigin(origin)) {\n        res.writeHead(403, { 'Content-Type': 'application/json' });\n        res.end(JSON.stringify({\n          error: 'Forbidden: Invalid origin',\n          message: 'Origin header validation failed'\n        }));\n        return;\n      }\n\n      // Basic request size limiting (prevent DoS)\n      const contentLength = parseInt(req.headers['content-length'] || '0', 10);\n      const maxRequestSize = 10 * 1024 * 1024; // 10MB limit\n      if (contentLength > maxRequestSize) {\n        res.writeHead(413, { 'Content-Type': 'application/json' });\n        res.end(JSON.stringify({\n          error: 'Payload Too Large',\n          message: 'Request size exceeds maximum allowed size'\n        }));\n        return;\n      }\n\n      // Handle CORS - restrict to localhost only for security\n      // HTTP mode is designed for local development/testing only\n      const allowedCorsOrigin = origin && isLocalhostOrigin(origin)\n        ? origin\n        : `http://${host}:${port}`;\n      res.setHeader('Access-Control-Allow-Origin', allowedCorsOrigin);\n      res.setHeader('Access-Control-Allow-Methods', 'GET, POST, DELETE, OPTIONS');\n      res.setHeader('Access-Control-Allow-Headers', 'Content-Type, mcp-session-id');\n      \n      if (req.method === 'OPTIONS') {\n        res.writeHead(200);\n        res.end();\n        return;\n      }\n\n      // Validate Accept header for MCP requests (spec requirement)\n      if (req.method === 'POST' || req.method === 'GET') {\n        const acceptHeader = req.headers.accept;\n        if (acceptHeader && !acceptHeader.includes('application/json') && !acceptHeader.includes('text/event-stream') && !acceptHeader.includes('*/*')) {\n          res.writeHead(406, { 'Content-Type': 'application/json' });\n          res.end(JSON.stringify({\n            error: 'Not Acceptable',\n            message: 'Accept header must include application/json or text/event-stream'\n          }));\n          return;\n        }\n      }\n\n      // Serve Account Management UI\n      if (req.method === 'GET' && (req.url === '/' || req.url === '/accounts')) {\n        try {\n          const html = await loadWebFile('accounts.html');\n          res.writeHead(200, {\n            'Content-Type': 'text/html; charset=utf-8',\n            ...SECURITY_HEADERS\n          });\n          res.end(html);\n        } catch (error) {\n          res.writeHead(500, { 'Content-Type': 'application/json' });\n          res.end(JSON.stringify({\n            error: 'Failed to load UI',\n            message: error instanceof Error ? error.message : String(error)\n          }));\n        }\n        return;\n      }\n\n      // Serve shared CSS\n      if (req.method === 'GET' && req.url === '/styles.css') {\n        try {\n          const css = await loadWebFile('styles.css');\n          res.writeHead(200, {\n            'Content-Type': 'text/css; charset=utf-8',\n            ...SECURITY_HEADERS\n          });\n          res.end(css);\n        } catch (error) {\n          res.writeHead(404, { 'Content-Type': 'text/plain' });\n          res.end('CSS file not found');\n        }\n        return;\n      }\n\n      // Account Management API Endpoints\n\n      // GET /api/accounts - List all authenticated accounts\n      if (req.method === 'GET' && req.url === '/api/accounts') {\n        try {\n          const accounts = await this.tokenManager.listAccounts();\n          res.writeHead(200, { 'Content-Type': 'application/json' });\n          res.end(JSON.stringify({ accounts }));\n        } catch (error) {\n          res.writeHead(500, { 'Content-Type': 'application/json' });\n          res.end(JSON.stringify({\n            error: 'Failed to list accounts',\n            message: error instanceof Error ? error.message : String(error)\n          }));\n        }\n        return;\n      }\n\n      // POST /api/accounts - Add new account (get OAuth URL)\n      if (req.method === 'POST' && req.url === '/api/accounts') {\n        try {\n          const body = await this.parseRequestBody(req);\n          const accountId = body.accountId;\n\n          if (!accountId || typeof accountId !== 'string') {\n            res.writeHead(400, { 'Content-Type': 'application/json' });\n            res.end(JSON.stringify({\n              error: 'Invalid request',\n              message: 'accountId is required and must be a string'\n            }));\n            return;\n          }\n\n          // Validate account ID format\n          try {\n            await this.validateAccountId(accountId);\n          } catch (error) {\n            res.writeHead(400, { 'Content-Type': 'application/json' });\n            res.end(JSON.stringify({\n              error: 'Invalid account ID',\n              message: error instanceof Error ? error.message : String(error)\n            }));\n            return;\n          }\n\n          // Generate OAuth URL for this account\n          const oauth2Client = await this.createOAuth2Client(accountId, host, port);\n          const authUrl = this.generateOAuthUrl(oauth2Client);\n\n          res.writeHead(200, { 'Content-Type': 'application/json' });\n          res.end(JSON.stringify({\n            authUrl,\n            accountId\n          }));\n        } catch (error) {\n          res.writeHead(500, { 'Content-Type': 'application/json' });\n          res.end(JSON.stringify({\n            error: 'Failed to initiate OAuth flow',\n            message: error instanceof Error ? error.message : String(error)\n          }));\n        }\n        return;\n      }\n\n      // GET /oauth2callback - OAuth callback handler\n      if (req.method === 'GET' && req.url?.startsWith('/oauth2callback')) {\n        try {\n          // Use configured host/port instead of req.headers.host for security\n          const url = new URL(req.url, `http://${host}:${port}`);\n          const code = url.searchParams.get('code');\n          const accountId = url.searchParams.get('account');\n\n          if (!code) {\n            res.writeHead(400, { 'Content-Type': 'text/html' });\n            res.end('<h1>Error</h1><p>Authorization code missing</p>');\n            return;\n          }\n\n          if (!accountId) {\n            res.writeHead(400, { 'Content-Type': 'text/html' });\n            res.end('<h1>Error</h1><p>Account ID missing</p>');\n            return;\n          }\n\n          // Exchange code for tokens\n          const oauth2Client = await this.createOAuth2Client(accountId, host, port);\n          const { tokens } = await oauth2Client.getToken(code);\n\n          // Get user email before saving tokens\n          oauth2Client.setCredentials(tokens);\n          let email = 'unknown';\n          try {\n            const tokenInfo = await oauth2Client.getTokenInfo(tokens.access_token || '');\n            email = tokenInfo.email || 'unknown';\n          } catch {\n            // Email retrieval failed, continue with 'unknown'\n          }\n\n          // Save tokens for this account with cached email\n          const originalMode = this.tokenManager.getAccountMode();\n          try {\n            this.tokenManager.setAccountMode(accountId);\n            await this.tokenManager.saveTokens(tokens, email !== 'unknown' ? email : undefined);\n          } finally {\n            this.tokenManager.setAccountMode(originalMode);\n          }\n\n          // Invalidate calendar registry cache since accounts changed\n          CalendarRegistry.getInstance().clearCache();\n\n          // Compute allowed origin for postMessage (localhost only)\n          const postMessageOrigin = `http://${host}:${port}`;\n\n          const successHtml = await renderAuthSuccess({\n            accountId,\n            email: email !== 'unknown' ? email : undefined,\n            showCloseButton: true,\n            postMessageOrigin\n          });\n          res.writeHead(200, {\n            'Content-Type': 'text/html; charset=utf-8',\n            ...SECURITY_HEADERS\n          });\n          res.end(successHtml);\n        } catch (error) {\n          const errorHtml = await renderAuthError({\n            errorMessage: error instanceof Error ? error.message : String(error),\n            showCloseButton: true\n          });\n          res.writeHead(500, {\n            'Content-Type': 'text/html; charset=utf-8',\n            ...SECURITY_HEADERS\n          });\n          res.end(errorHtml);\n        }\n        return;\n      }\n\n      // DELETE /api/accounts/:id - Remove account\n      if (req.method === 'DELETE' && req.url?.startsWith('/api/accounts/')) {\n        const accountId = req.url.substring('/api/accounts/'.length);\n\n        try {\n          // Validate account ID format\n          await this.validateAccountId(accountId);\n\n          // Switch to account and clear tokens\n          const originalMode = this.tokenManager.getAccountMode();\n          try {\n            this.tokenManager.setAccountMode(accountId);\n            await this.tokenManager.clearTokens();\n          } finally {\n            this.tokenManager.setAccountMode(originalMode);\n          }\n\n          // Invalidate calendar registry cache since accounts changed\n          CalendarRegistry.getInstance().clearCache();\n\n          res.writeHead(200, { 'Content-Type': 'application/json' });\n          res.end(JSON.stringify({\n            success: true,\n            accountId,\n            message: 'Account removed successfully'\n          }));\n        } catch (error) {\n          res.writeHead(500, { 'Content-Type': 'application/json' });\n          res.end(JSON.stringify({\n            error: 'Failed to remove account',\n            message: error instanceof Error ? error.message : String(error)\n          }));\n        }\n        return;\n      }\n\n      // POST /api/accounts/:id/reauth - Re-authenticate account\n      if (req.method === 'POST' && req.url?.match(/^\\/api\\/accounts\\/[^/]+\\/reauth$/)) {\n        const accountId = req.url.split('/')[3];\n\n        try {\n          // Validate account ID format\n          await this.validateAccountId(accountId);\n\n          // Generate OAuth URL for re-authentication\n          const oauth2Client = await this.createOAuth2Client(accountId, host, port);\n          const authUrl = this.generateOAuthUrl(oauth2Client);\n\n          res.writeHead(200, { 'Content-Type': 'application/json' });\n          res.end(JSON.stringify({\n            authUrl,\n            accountId\n          }));\n        } catch (error) {\n          res.writeHead(500, { 'Content-Type': 'application/json' });\n          res.end(JSON.stringify({\n            error: 'Failed to initiate re-authentication',\n            message: error instanceof Error ? error.message : String(error)\n          }));\n        }\n        return;\n      }\n\n      // Handle health check endpoint\n      if (req.method === 'GET' && req.url === '/health') {\n        res.writeHead(200, { 'Content-Type': 'application/json' });\n        res.end(JSON.stringify({\n          status: 'healthy',\n          server: 'google-calendar-mcp',\n          timestamp: new Date().toISOString()\n        }));\n        return;\n      }\n\n      try {\n        await transport.handleRequest(req, res);\n      } catch (error) {\n        process.stderr.write(`Error handling request: ${error instanceof Error ? error.message : error}\\n`);\n        if (!res.headersSent) {\n          res.writeHead(500, { 'Content-Type': 'application/json' });\n          res.end(JSON.stringify({\n            jsonrpc: '2.0',\n            error: {\n              code: -32603,\n              message: 'Internal server error',\n            },\n            id: null,\n          }));\n        }\n      }\n    });\n\n    httpServer.listen(port, host, () => {\n      process.stderr.write(`Google Calendar MCP Server listening on http://${host}:${port}\\n`);\n    });\n  }\n} ", "export interface TransportConfig {\n  type: 'stdio' | 'http';\n  port?: number;\n  host?: string;\n}\n\nexport interface ServerConfig {\n  transport: TransportConfig;\n  debug?: boolean;\n  enabledTools?: string[];\n}\n\nfunction parseEnabledTools(value: string | undefined, source: string): string[] | undefined {\n  if (value === undefined) {\n    return undefined;\n  }\n\n  const parsed = value.split(',').map(t => t.trim()).filter(t => t.length > 0);\n  if (parsed.length === 0) {\n    process.stderr.write(`Error: ${source} requires at least one tool name\\n`);\n    process.exit(1);\n  }\n\n  return parsed;\n}\n\nexport function parseArgs(args: string[]): ServerConfig {\n  // Start with environment variables as base config\n  const config: ServerConfig = {\n    transport: {\n      type: (process.env.TRANSPORT as 'stdio' | 'http') || 'stdio',\n      port: process.env.PORT ? parseInt(process.env.PORT, 10) : 3000,\n      host: process.env.HOST || '127.0.0.1'\n    },\n    debug: process.env.DEBUG === 'true' || false,\n    enabledTools: parseEnabledTools(process.env.ENABLED_TOOLS, 'ENABLED_TOOLS')\n  };\n\n  for (let i = 0; i < args.length; i++) {\n    const arg = args[i];\n    \n    switch (arg) {\n      case '--transport':\n        const transport = args[++i];\n        if (transport === 'stdio' || transport === 'http') {\n          config.transport.type = transport;\n        }\n        break;\n      case '--port':\n        config.transport.port = parseInt(args[++i], 10);\n        break;\n      case '--host':\n        config.transport.host = args[++i];\n        break;\n      case '--debug':\n        config.debug = true;\n        break;\n      case '--enable-tools':\n        const enabledTools = args[++i];\n        if (!enabledTools) {\n          process.stderr.write('Error: --enable-tools requires a comma-separated list of tool names\\n');\n          process.exit(1);\n        }\n        config.enabledTools = parseEnabledTools(enabledTools, '--enable-tools');\n        break;\n      case '--help':\n        process.stderr.write(`\nGoogle Calendar MCP Server\n\nUsage: node build/index.js [options]\n\nOptions:\n  --transport <type>        Transport type: stdio (default) | http\n  --port <number>          Port for HTTP transport (default: 3000)\n  --host <string>          Host for HTTP transport (default: 127.0.0.1)\n  --debug                  Enable debug logging\n  --enable-tools <list>    Comma-separated list of tools to enable (whitelist)\n  --help                   Show this help message\n\nEnvironment Variables:\n  TRANSPORT               Transport type: stdio | http\n  PORT                   Port for HTTP transport\n  HOST                   Host for HTTP transport\n  DEBUG                  Enable debug logging (true/false)\n  ENABLED_TOOLS          Comma-separated list of tools to enable\n\nExamples:\n  node build/index.js                              # stdio (local use)\n  node build/index.js --transport http --port 3000 # HTTP server\n  node build/index.js --enable-tools list-events,create-event,get-current-time\n  PORT=3000 TRANSPORT=http node build/index.js     # Using env vars\n        `);\n        process.exit(0);\n    }\n  }\n\n  return config;\n} \n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAOA,OAAO,UAAU;AACjB,SAAS,eAAe;AAMjB,SAAS,qBAAqB;AAEnC,MAAI,QAAQ,IAAI,gCAAgC;AAC9C,WAAO,KAAK,QAAQ,QAAQ,IAAI,8BAA8B;AAAA,EAChE;AAEA,QAAM,YAAY,QAAQ,IAAI,mBAAmB,KAAK,KAAK,QAAQ,GAAG,SAAS;AAC/E,SAAO,KAAK,KAAK,WAAW,uBAAuB,aAAa;AAClE;AAKO,SAAS,qBAAqB;AACnC,SAAO,KAAK,KAAK,QAAQ,IAAI,GAAG,wBAAwB;AAC1D;AAaO,SAAS,kBAAkBA,YAAW;AAC3C,MAAI,CAACA,cAAaA,WAAU,WAAW,GAAG;AACxC,UAAM,IAAI,MAAM,oGAAoG;AAAA,EACtH;AAGA,MAAI,eAAe,SAASA,UAAS,GAAG;AACtC,UAAM,IAAI,MAAM,eAAeA,UAAS,mCAAmC;AAAA,EAC7E;AAGA,MAAI,CAAC,qBAAqB,KAAKA,UAAS,GAAG;AACzC,UAAM,IAAI,MAAM,oGAAoG;AAAA,EACtH;AAEA,SAAOA;AACT;AAMO,SAAS,iBAAiB;AAE/B,QAAM,eAAe,QAAQ,IAAI;AACjC,MAAI,iBAAiB,UAAa,iBAAiB,MAAM;AAEvD,WAAO,kBAAkB,YAAY;AAAA,EACvC;AAGA,MAAI,QAAQ,IAAI,aAAa,QAAQ;AACnC,WAAO;AAAA,EACT;AAGA,SAAO;AACT;AA/EA,IAkCM;AAlCN;AAAA;AAAA;AAkCA,IAAM,iBAAiB;AAAA,MAAC;AAAA,MAAK;AAAA,MAAM;AAAA,MAAO;AAAA,MAAO;AAAA,MAAO;AAAA,MAAO;AAAA,MAAQ;AAAA,MAAQ;AAAA,MAAQ;AAAA,MAC/D;AAAA,MAAQ;AAAA,MAAQ;AAAA,IAAM;AAAA;AAAA;;;ACnC9C,YAAYC,WAAU;AAEtB,YAAY,QAAQ;AACpB,SAAS,qBAAqB;AAI9B,SAAS,iBAAyB;AAChC,QAAMC,aAAiB,cAAQ,cAAc,YAAY,GAAG,CAAC;AAG7D,QAAM,cAAmB,WAAKA,YAAW,IAAI;AAC7C,SAAY,cAAQ,WAAW;AACjC;AAIO,SAASC,kBAAyB;AACvC,SAAO,eAAqB;AAC9B;AASO,SAASC,sBAA6B;AAC3C,SAAO,mBAAyB;AAClC;AAGO,SAASC,sBAA6B;AAC3C,SAAO,mBAAyB;AAClC;AAKO,SAAS,kBAA0B;AAExC,QAAM,qBAAqB,QAAQ,IAAI;AACvC,MAAI,oBAAoB;AACtB,WAAY,cAAQ,kBAAkB;AAAA,EACxC;AAGA,QAAM,cAAc,eAAe;AACnC,QAAM,WAAgB,WAAK,aAAa,qBAAqB;AAC7D,SAAO;AACT;AA8BO,SAAS,0BAA8C;AAC5D,MAAI;AAEF,UAAM,kBAAkB,gBAAgB;AAExC,QAAI,CAAI,cAAW,eAAe,GAAG;AACnC,aAAO;AAAA,IACT;AAEA,UAAM,qBAAwB,gBAAa,iBAAiB,OAAO;AACnE,UAAM,cAA2C,KAAK,MAAM,kBAAkB;AAG9E,QAAI,YAAY,WAAW,YAAY;AACrC,aAAO,YAAY,UAAU;AAAA,IAC/B,WAAW,YAAY,YAAY;AACjC,aAAO,YAAY;AAAA,IACrB;AAEA,WAAO;AAAA,EACT,SAAS,OAAO;AAEd,WAAO;AAAA,EACT;AACF;AAGO,SAAS,kCAA0C;AACxD,SAAO;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,yBAWgBD,oBAAmB,CAAC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAS3C,KAAK;AACP;AAlIA;AAAA;AAAA;AAIA;AAAA;AAAA;;;ACJA;AAAA;AAAA;AAAA;AAAA;AAAA,SAAS,oBAAoB;AAC7B,YAAYE,SAAQ;AAGpB,eAAe,0BAAqD;AAClE,QAAM,cAAc,MAAS,aAAS,gBAAgB,GAAG,OAAO;AAChE,QAAM,OAAO,KAAK,MAAM,WAAW;AAEnC,MAAI,KAAK,WAAW;AAElB,UAAM,EAAE,WAAW,eAAe,cAAc,IAAI,KAAK;AACzD,WAAO,EAAE,WAAW,eAAe,cAAc;AAAA,EACnD,WAAW,KAAK,aAAa,KAAK,eAAe;AAE/C,WAAO;AAAA,MACL,WAAW,KAAK;AAAA,MAChB,eAAe,KAAK;AAAA,MACpB,eAAe,KAAK,iBAAiB,CAAC,sCAAsC;AAAA,IAC9E;AAAA,EACF,OAAO;AACL,UAAM,IAAI,MAAM,+GAA+G;AAAA,EACjI;AACF;AAEA,eAAe,8BAAyD;AAEtE,MAAI;AACF,WAAO,MAAM,wBAAwB;AAAA,EACvC,SAAS,WAAW;AAElB,UAAM,eAAe,gCAAgC;AACrD,UAAM,IAAI,MAAM,GAAG,YAAY;AAAA;AAAA,kBAAuB,qBAAqB,QAAQ,UAAU,UAAU,SAAS,EAAE;AAAA,EACpH;AACF;AAEA,eAAsB,yBAAgD;AAGpE,MAAI;AACF,UAAM,cAAc,MAAM,4BAA4B;AAGtD,WAAO,IAAI,aAAa;AAAA,MACtB,UAAU,YAAY;AAAA,MACtB,cAAc,YAAY;AAAA,MAC1B,aAAa,YAAY,cAAc,CAAC;AAAA,IAC1C,CAAC;AAAA,EACH,SAAS,OAAO;AACd,UAAM,IAAI,MAAM,6BAA6B,iBAAiB,QAAQ,MAAM,UAAU,KAAK,EAAE;AAAA,EAC/F;AACF;AAEA,eAAsB,kBAAyE;AAC7F,MAAI;AACF,UAAM,cAAc,MAAM,4BAA4B;AAEtD,QAAI,CAAC,YAAY,aAAa,CAAC,YAAY,eAAe;AACtD,YAAM,IAAI,MAAM,oDAAoD;AAAA,IACxE;AACA,WAAO;AAAA,MACL,WAAW,YAAY;AAAA,MACvB,eAAe,YAAY;AAAA,IAC7B;AAAA,EACF,SAAS,OAAO;AACd,UAAM,IAAI,MAAM,8BAA8B,iBAAiB,QAAQ,MAAM,UAAU,KAAK,EAAE;AAAA,EAChG;AACF;AAlEA;AAAA;AAAA;AAEA;AAAA;AAAA;;;ACFA,SAAS,iBAAAC,sBAAqB;;;ACK9B;AALA,SAAS,iBAAiB;AAC1B,SAAS,YAAAC,WAAU,aAAAC,kBAAiB;;;ACDpC,SAAS,gBAAAC,qBAAoB;;;ACE7B;AAFA,SAAS,gBAAAC,qBAAiC;AAC1C,OAAOC,SAAQ;AAEf,SAAS,mBAAmB;AAC5B,SAAS,aAAa;AACtB,SAAS,WAAAC,gBAAe;AAyBjB,IAAM,eAAN,MAAmB;AAAA,EAChB;AAAA,EACA;AAAA,EACA;AAAA,EACA,WAAsC,oBAAI,IAAI;AAAA,EAC9C;AAAA,EAKA,aAA4B,QAAQ,QAAQ;AAAA,EAEpD,YAAY,cAA4B;AACtC,SAAK,eAAe;AACpB,SAAK,YAAYC,oBAAmB;AACpC,SAAK,cAAcC,gBAAe;AAGlC,SAAK,cAAc;AAAA,MACjB,UAAW,aAAqB;AAAA,MAChC,cAAe,aAAqB;AAAA,MACpC,aAAc,aAAqB;AAAA,IACrC;AAEA,SAAK,kBAAkB;AAAA,EACzB;AAAA;AAAA,EAGO,eAAuB;AAC5B,WAAO,KAAK;AAAA,EACd;AAAA;AAAA,EAGO,iBAAyB;AAC9B,WAAO,KAAK;AAAA,EACd;AAAA;AAAA,EAGO,eAAe,MAAoB;AACxC,SAAK,cAAc;AAAA,EACrB;AAAA,EAEA,MAAc,6BAA4C;AACxD,QAAI;AACF,YAAM,MAAMF,SAAQ,KAAK,SAAS,GAAG,EAAE,WAAW,KAAK,CAAC;AAAA,IAC1D,SAAS,OAAO;AACd,cAAQ,OAAO,MAAM,qCAAqC,KAAK;AAAA,CAAI;AAAA,IACrE;AAAA,EACF;AAAA,EAEQ,oBAAoB,OAAyB;AACnD,WAAO,iBAAiB,SAAS,UAAU,SAAU,MAAc,SAAS;AAAA,EAC9E;AAAA,EAEA,MAAc,eAAe,QAA2C;AACtE,UAAM,KAAK,2BAA2B;AACtC,UAAMD,IAAG,UAAU,KAAK,WAAW,KAAK,UAAU,QAAQ,MAAM,CAAC,GAAG,EAAE,MAAM,IAAM,CAAC;AAAA,EACrF;AAAA,EAEA,MAAc,yBAAsD;AAClE,QAAI;AACF,YAAM,cAAc,MAAMA,IAAG,SAAS,KAAK,WAAW,OAAO;AAC7D,YAAM,SAAS,KAAK,MAAM,WAAW;AAGrC,UAAI,OAAO,gBAAgB,OAAO,eAAe;AAE/C,cAAM,qBAAyC;AAAA,UAC7C,QAAQ;AAAA,QACV;AACA,cAAM,KAAK,uBAAuB,kBAAkB;AACpD,eAAO;AAAA,MACT;AAGA,aAAO;AAAA,IACT,SAAS,OAAgB;AACvB,UAAI,KAAK,oBAAoB,KAAK,GAAG;AACnC,eAAO,CAAC;AAAA,MACV;AACA,YAAM;AAAA,IACR;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,MAAc,4BAAyD;AACrE,QAAI;AACF,YAAM,cAAc,MAAMA,IAAG,SAAS,KAAK,WAAW,OAAO;AAC7D,aAAO,KAAK,MAAM,WAAW;AAAA,IAC/B,SAAS,OAAgB;AACvB,UAAI,KAAK,oBAAoB,KAAK,GAAG;AACnC,eAAO,CAAC;AAAA,MACV;AACA,YAAM;AAAA,IACR;AAAA,EACF;AAAA,EAEA,MAAc,uBAAuB,oBAAuD;AAC1F,WAAO,KAAK,kBAAkB,YAAY;AACxC,YAAM,KAAK,eAAe,kBAAkB;AAAA,IAC9C,CAAC;AAAA,EACH;AAAA,EAEQ,kBAAkB,WAA+C;AACvE,UAAM,eAAe,KAAK,WACvB,MAAM,MAAM,MAAS,EACrB,KAAK,SAAS;AAEjB,SAAK,aAAa,aACf,MAAM,WAAS;AACd,cAAQ,OAAO,MAAM,6BAA6B,iBAAiB,QAAQ,MAAM,UAAU,KAAK;AAAA,CAAI;AACpG,YAAM;AAAA,IACR,CAAC,EACA,MAAM,MAAM,MAAS;AAExB,WAAO;AAAA,EACT;AAAA,EAEQ,oBAA0B;AAChC,SAAK,4BAA4B,KAAK,cAAc,KAAK,WAAW;AAAA,EACtE;AAAA;AAAA;AAAA;AAAA;AAAA,EAMQ,4BAA4B,QAAsBI,YAAyB;AACjF,WAAO,GAAG,UAAU,OAAO,cAAc;AACvC,UAAI;AAEF,cAAM,KAAK,kBAAkB,YAAY;AACvC,gBAAM,qBAAqB,MAAM,KAAK,uBAAuB;AAC7D,gBAAM,gBAAgB,mBAAmBA,UAAS,KAAK,CAAC;AAExD,gBAAM,gBAAgB;AAAA,YACpB,GAAG;AAAA,YACH,GAAG;AAAA,YACH,eAAe,UAAU,iBAAiB,cAAc;AAAA,UAC1D;AAEA,6BAAmBA,UAAS,IAAI;AAChC,gBAAM,KAAK,eAAe,kBAAkB;AAAA,QAC9C,CAAC;AAED,YAAI,QAAQ,IAAI,aAAa,QAAQ;AACnC,kBAAQ,OAAO,MAAM,gCAAgCA,UAAS;AAAA,CAAY;AAAA,QAC5E;AAAA,MACF,SAAS,OAAgB;AACvB,gBAAQ,OAAO,MAAM,+BAA+B;AACpD,YAAI,iBAAiB,OAAO;AAC1B,kBAAQ,OAAO,MAAM,MAAM,OAAO;AAAA,QACpC,WAAW,OAAO,UAAU,UAAU;AACpC,kBAAQ,OAAO,MAAM,KAAK;AAAA,QAC5B;AACA,gBAAQ,OAAO,MAAM,IAAI;AAAA,MAC3B;AAAA,IACF,CAAC;AAAA,EACH;AAAA,EAEA,MAAc,sBAAwC;AACpD,UAAM,aAAaC,oBAAmB;AACtC,QAAI;AAEF,UAAI,CAAE,MAAML,IAAG,OAAO,UAAU,EAAE,KAAK,MAAM,IAAI,EAAE,MAAM,MAAM,KAAK,GAAI;AACtE,eAAO;AAAA,MACT;AAGA,YAAM,eAAe,KAAK,MAAM,MAAMA,IAAG,SAAS,YAAY,OAAO,CAAC;AAEtE,UAAI,CAAC,gBAAgB,OAAO,iBAAiB,UAAU;AACrD,gBAAQ,OAAO,MAAM,mDAAmD;AACxE,eAAO;AAAA,MACT;AAGA,YAAM,KAAK,eAAe,YAAY;AAEtC,cAAQ,OAAO,MAAM,yCAAyC,UAAU,QAAQ,KAAK,SAAS;AAAA,CAAI;AAGlG,UAAI;AACF,cAAMA,IAAG,OAAO,UAAU;AAC1B,gBAAQ,OAAO,MAAM,6BAA6B;AAAA,MACpD,SAAS,WAAW;AAClB,gBAAQ,OAAO,MAAM,gDAAgD,SAAS;AAAA,CAAI;AAAA,MACpF;AAEA,aAAO;AAAA,IACT,SAAS,OAAO;AACd,cAAQ,OAAO,MAAM,kCAAkC,KAAK;AAAA,CAAI;AAChE,aAAO;AAAA,IACT;AAAA,EACF;AAAA,EAEA,MAAM,kBAAoC;AACxC,QAAI;AACF,YAAM,KAAK,2BAA2B;AAGtC,YAAM,cAAc,MAAMA,IAAG,OAAO,KAAK,SAAS,EAAE,KAAK,MAAM,IAAI,EAAE,MAAM,MAAM,KAAK;AAGtF,UAAI,CAAC,aAAa;AAChB,cAAM,WAAW,MAAM,KAAK,oBAAoB;AAChD,YAAI,CAAC,UAAU;AACb,kBAAQ,OAAO,MAAM,2BAA2B,KAAK,SAAS;AAAA,CAAI;AAClE,iBAAO;AAAA,QACT;AAAA,MACF;AAEA,YAAM,qBAAqB,MAAM,KAAK,uBAAuB;AAC7D,YAAM,SAAS,mBAAmB,KAAK,WAAW;AAElD,UAAI,CAAC,UAAU,OAAO,WAAW,UAAU;AACzC,gBAAQ,OAAO,MAAM,uBAAuB,KAAK,WAAW,qBAAqB,KAAK,SAAS;AAAA,CAAI;AACnG,eAAO;AAAA,MACT;AAEA,WAAK,aAAa,eAAe,MAAM;AACvC,cAAQ,OAAO,MAAM,qBAAqB,KAAK,WAAW;AAAA,CAAY;AACtE,aAAO;AAAA,IACT,SAAS,OAAgB;AACvB,cAAQ,OAAO,MAAM,4BAA4B,KAAK,WAAW,YAAY;AAC7E,UAAI,iBAAiB,SAAS,UAAU,SAAS,MAAM,SAAS,UAAU;AACtE,YAAI;AACA,gBAAMA,IAAG,OAAO,KAAK,SAAS;AAC9B,kBAAQ,OAAO,MAAM,4CAA4C;AAAA,QACnE,SAAS,WAAW;AAAA,QAAe;AAAA,MACzC;AACA,aAAO;AAAA,IACT;AAAA,EACF;AAAA,EAEA,MAAM,wBAA0C;AAC9C,UAAM,aAAa,KAAK,aAAa,YAAY;AACjD,UAAM,YAAY,aACd,KAAK,IAAI,KAAK,aAAa,IAAI,KAAK,MACpC,CAAC,KAAK,aAAa,YAAY;AAEnC,QAAI,aAAa,KAAK,aAAa,YAAY,eAAe;AAC5D,UAAI,QAAQ,IAAI,aAAa,QAAQ;AACnC,gBAAQ,OAAO,MAAM,4CAA4C,KAAK,WAAW;AAAA,CAA2B;AAAA,MAC9G;AACA,UAAI;AACF,cAAM,WAAW,MAAM,KAAK,aAAa,mBAAmB;AAC5D,cAAM,YAAY,SAAS;AAE3B,YAAI,CAAC,UAAU,cAAc;AAC3B,gBAAM,IAAI,MAAM,wCAAwC;AAAA,QAC1D;AAEA,aAAK,aAAa,eAAe,SAAS;AAC1C,YAAI,QAAQ,IAAI,aAAa,QAAQ;AACnC,kBAAQ,OAAO,MAAM,oCAAoC,KAAK,WAAW;AAAA,CAAY;AAAA,QACvF;AACA,eAAO;AAAA,MACT,SAAS,cAAc;AACrB,YAAI,wBAAwB,eAAe,aAAa,UAAU,MAAM,UAAU,iBAAiB;AAC/F,kBAAQ,OAAO,MAAM,mCAAmC,KAAK,WAAW;AAAA,CAAqF;AAC7J,iBAAO;AAAA,QACX,OAAO;AAEH,kBAAQ,OAAO,MAAM,mCAAmC,KAAK,WAAW,YAAY;AACpF,cAAI,wBAAwB,OAAO;AACjC,oBAAQ,OAAO,MAAM,aAAa,OAAO;AAAA,UAC3C,WAAW,OAAO,iBAAiB,UAAU;AAC3C,oBAAQ,OAAO,MAAM,YAAY;AAAA,UACnC;AACA,kBAAQ,OAAO,MAAM,IAAI;AACzB,iBAAO;AAAA,QACX;AAAA,MACF;AAAA,IACF,WAAW,CAAC,KAAK,aAAa,YAAY,gBAAgB,CAAC,KAAK,aAAa,YAAY,eAAe;AACpG,cAAQ,OAAO,MAAM,4CAA4C,KAAK,WAAW;AAAA,CAAqC;AACtH,aAAO;AAAA,IACX,OAAO;AAEH,aAAO;AAAA,IACX;AAAA,EACF;AAAA,EAEA,MAAM,eAAe,aAAwC;AAI3D,UAAM,iBAAiB,eAAe,KAAK;AAC3C,UAAM,cAAc,KAAK;AAEzB,QAAI;AAEF,UAAI,mBAAmB,aAAa;AAClC,aAAK,cAAc;AAAA,MACrB;AAEA,UAAI,CAAC,KAAK,aAAa,eAAe,CAAC,KAAK,aAAa,YAAY,cAAc;AAE/E,YAAI,CAAE,MAAM,KAAK,gBAAgB,GAAI;AACjC,iBAAO;AAAA,QACX;AAEA,YAAI,CAAC,KAAK,aAAa,eAAe,CAAC,KAAK,aAAa,YAAY,cAAc;AAC/E,iBAAO;AAAA,QACX;AAAA,MACJ;AAEA,YAAM,SAAS,MAAM,KAAK,sBAAsB;AAChD,aAAO;AAAA,IACT,UAAE;AAEA,UAAI,mBAAmB,aAAa;AAClC,aAAK,cAAc;AAAA,MACrB;AAAA,IACF;AAAA,EACF;AAAA,EAEA,MAAM,WAAW,QAAqB,OAA+B;AACnE,QAAI;AAEA,YAAM,KAAK,kBAAkB,YAAY;AACvC,cAAM,qBAAqB,MAAM,KAAK,uBAAuB;AAC7D,cAAM,eAAkC,EAAE,GAAG,OAAO;AAGpD,YAAI,OAAO;AACT,uBAAa,eAAe;AAAA,QAC9B;AAEA,2BAAmB,KAAK,WAAW,IAAI;AACvC,cAAM,KAAK,eAAe,kBAAkB;AAAA,MAC9C,CAAC;AACD,WAAK,aAAa,eAAe,MAAM;AACvC,cAAQ,OAAO,MAAM,iCAAiC,KAAK,WAAW,gBAAgB,KAAK,SAAS;AAAA,CAAI;AAAA,IAC5G,SAAS,OAAgB;AACrB,cAAQ,OAAO,MAAM,2BAA2B,KAAK,WAAW,aAAa,KAAK;AAAA,CAAI;AACtF,YAAM;AAAA,IACV;AAAA,EACF;AAAA,EAEA,MAAM,cAA6B;AACjC,QAAI;AACF,WAAK,aAAa,eAAe,CAAC,CAAC;AAGnC,YAAM,KAAK,kBAAkB,YAAY;AACvC,cAAM,qBAAqB,MAAM,KAAK,uBAAuB;AAC7D,eAAO,mBAAmB,KAAK,WAAW;AAG1C,YAAI,OAAO,KAAK,kBAAkB,EAAE,WAAW,GAAG;AAChD,gBAAMA,IAAG,OAAO,KAAK,SAAS;AAC9B,kBAAQ,OAAO,MAAM;AAAA,CAAoC;AAAA,QAC3D,OAAO;AACL,gBAAM,KAAK,eAAe,kBAAkB;AAC5C,kBAAQ,OAAO,MAAM,sBAAsB,KAAK,WAAW;AAAA,CAAY;AAAA,QACzE;AAAA,MACF,CAAC;AAAA,IACH,SAAS,OAAgB;AACvB,UAAI,KAAK,oBAAoB,KAAK,GAAG;AAEnC,gBAAQ,OAAO,MAAM,8BAA8B;AAAA,MACrD,OAAO;AACL,gBAAQ,OAAO,MAAM,6BAA6B,KAAK,WAAW,aAAa,KAAK;AAAA,CAAI;AAAA,MAE1F;AAAA,IACF;AAAA,EACF;AAAA;AAAA,EAGA,MAAM,wBAA2C;AAC/C,QAAI;AACF,YAAM,qBAAqB,MAAM,KAAK,uBAAuB;AAC7D,aAAO,OAAO,KAAK,kBAAkB;AAAA,IACvC,SAAS,OAAO;AACd,aAAO,CAAC;AAAA,IACV;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,MAAM,cAAcI,YAAkC;AACpD,UAAM,eAAeA,WAAU,YAAY;AAE3C,UAAM,KAAK,kBAAkB,YAAY;AACvC,YAAM,qBAAqB,MAAM,KAAK,uBAAuB;AAE7D,UAAI,CAAC,mBAAmB,YAAY,GAAG;AACrC,cAAM,IAAI,MAAM,YAAY,YAAY,aAAa;AAAA,MACvD;AAEA,aAAO,mBAAmB,YAAY;AAGtC,UAAI,OAAO,KAAK,kBAAkB,EAAE,WAAW,GAAG;AAChD,cAAMJ,IAAG,OAAO,KAAK,SAAS;AAC9B,gBAAQ,OAAO,MAAM;AAAA,CAAoC;AAAA,MAC3D,OAAO;AACL,cAAM,KAAK,eAAe,kBAAkB;AAC5C,gBAAQ,OAAO,MAAM,YAAY,YAAY;AAAA,CAA0B;AAAA,MACzE;AAGA,WAAK,SAAS,OAAO,YAAY;AAAA,IACnC,CAAC;AAAA,EACH;AAAA;AAAA,EAGA,MAAM,cAAc,SAAmC;AACrD,SAAK,cAAc;AACnB,WAAO,KAAK,gBAAgB;AAAA,EAC9B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASA,MAAM,kBAAsD;AAC1D,QAAI;AACF,YAAM,qBAAqB,MAAM,KAAK,uBAAuB;AAG7D,iBAAWI,cAAa,KAAK,SAAS,KAAK,GAAG;AAC5C,YAAI,CAAC,mBAAmBA,UAAS,GAAG;AAClC,gBAAM,SAAS,KAAK,SAAS,IAAIA,UAAS;AAC1C,cAAI,QAAQ;AAEV,mBAAO,mBAAmB,QAAQ;AAAA,UACpC;AACA,eAAK,SAAS,OAAOA,UAAS;AAAA,QAChC;AAAA,MACF;AAGA,iBAAW,CAACA,YAAW,MAAM,KAAK,OAAO,QAAQ,kBAAkB,GAAG;AAEpE,YAAI;AACF,gBAAM,EAAE,mBAAAE,mBAAkB,IAAI,MAAM;AACpC,UAAAA,mBAAkBF,UAAS;AAG3B,cAAI,CAAC,UAAU,OAAO,WAAW,YAAY,CAAC,OAAO,cAAc;AACjE;AAAA,UACF;AAGA,cAAI,SAAS,KAAK,SAAS,IAAIA,UAAS;AAExC,cAAI,CAAC,QAAQ;AAEX,qBAAS,IAAIL;AAAA,cACX,KAAK,YAAY;AAAA,cACjB,KAAK,YAAY;AAAA,cACjB,KAAK,YAAY;AAAA,YACnB;AAGA,iBAAK,4BAA4B,QAAQK,UAAS;AAElD,iBAAK,SAAS,IAAIA,YAAW,MAAM;AAAA,UACrC;AAGA,iBAAO,eAAe,MAAM;AAAA,QAE9B,SAAS,OAAO;AAEd,cAAI,QAAQ,IAAI,aAAa,QAAQ;AACnC,oBAAQ,OAAO,MAAM,6BAA6BA,UAAS,MAAM,KAAK;AAAA,CAAI;AAAA,UAC5E;AACA;AAAA,QACF;AAAA,MACF;AAEA,aAAO,KAAK;AAAA,IACd,SAAS,OAAY;AAEnB,UAAI,SAAS,MAAM,SAAS,UAAU;AAEpC,eAAO,oBAAI,IAAI;AAAA,MACjB;AACA,YAAM;AAAA,IACR;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,UAAUA,YAAiC;AAEzC,UAAM,EAAE,mBAAAE,mBAAkB,IAAI;AAC9B,IAAAA,mBAAkBF,UAAS;AAE3B,UAAM,SAAS,KAAK,SAAS,IAAIA,UAAS;AAC1C,QAAI,CAAC,QAAQ;AACX,YAAM,IAAI,MAAM,YAAYA,UAAS,sDAAsD;AAAA,IAC7F;AAEA,WAAO;AAAA,EACT;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,MAAM,eAKF;AACF,QAAI;AACF,YAAM,qBAAqB,MAAM,KAAK,uBAAuB;AAC7D,YAAM,cAKD,CAAC;AACN,UAAI,gBAAgB;AAGpB,YAAM,qBAAqB,IAAI,KAAK;AAEpC,iBAAW,CAACA,YAAW,MAAM,KAAK,OAAO,QAAQ,kBAAkB,GAAG;AAEpE,YAAI,CAAC,UAAU,OAAO,WAAW,UAAU;AACzC;AAAA,QACF;AAEA,YAAI,SAA8B;AAGlC,YAAI,OAAO,gBAAgB,OAAO,eAAe;AAC/C,cAAI;AACF,qBAAS,IAAIL;AAAA,cACX,KAAK,YAAY;AAAA,cACjB,KAAK,YAAY;AAAA,cACjB,KAAK,YAAY;AAAA,YACnB;AACA,mBAAO,eAAe,MAAM;AAG5B,gBAAI,OAAO,kBAAkB,CAAC,OAAO,gBAAiB,OAAO,eAAe,OAAO,cAAc,KAAK,IAAI,IAAK;AAC7G,kBAAI;AACF,sBAAM,WAAW,MAAM,OAAO,mBAAmB;AACjD,uBAAO,eAAe,SAAS,WAAW;AAC1C,uBAAO,OAAO,QAAQ,SAAS,WAAW;AAC1C,gCAAgB;AAAA,cAClB,QAAQ;AAAA,cAER;AAAA,YACF;AAAA,UACF,QAAQ;AACN,qBAAS;AAAA,UACX;AAAA,QACF;AAGA,YAAI,QAAQ,OAAO,gBAAgB;AACnC,YAAI,CAAC,OAAO,gBAAgB,QAAQ;AAClC,cAAI;AACF,oBAAQ,MAAM,KAAK,aAAa,MAAM;AACtC,gBAAI,UAAU,WAAW;AACvB,qBAAO,eAAe;AACtB,8BAAgB;AAAA,YAClB;AAAA,UACF,QAAQ;AAAA,UAER;AAAA,QACF;AAGA,YAAI,YAA8B,OAAO,oBAAoB,CAAC;AAC9D,cAAM,eAAe,CAAC,OAAO,uBAC1B,KAAK,IAAI,IAAI,OAAO,sBAAuB;AAE9C,YAAI,gBAAgB,QAAQ;AAC1B,cAAI;AACF,wBAAY,MAAM,KAAK,wBAAwB,MAAM;AACrD,mBAAO,mBAAmB;AAC1B,mBAAO,sBAAsB,KAAK,IAAI;AACtC,4BAAgB;AAAA,UAClB,QAAQ;AAAA,UAER;AAAA,QACF;AAGA,YAAI,SAAS;AACb,YAAI,CAAC,OAAO,eAAe;AACzB,cAAI,CAAC,OAAO,gBAAiB,OAAO,eAAe,OAAO,cAAc,KAAK,IAAI,GAAI;AACnF,qBAAS;AAAA,UACX;AAAA,QACF;AAEA,oBAAY,KAAK,EAAE,IAAIK,YAAW,OAAO,QAAQ,UAAU,CAAC;AAAA,MAC9D;AAIA,UAAI,eAAe;AACjB,cAAM,KAAK,kBAAkB,YAAY;AAEvC,gBAAM,eAAe,MAAM,KAAK,0BAA0B;AAG1D,qBAAWA,cAAa,OAAO,KAAK,kBAAkB,GAAG;AACvD,kBAAM,eAAe,mBAAmBA,UAAS;AACjD,kBAAM,gBAAgB,aAAaA,UAAS;AAE5C,gBAAI,iBAAiB,cAAc;AAEjC,kBAAI,aAAa,cAAc;AAC7B,8BAAc,eAAe,aAAa;AAAA,cAC5C;AACA,kBAAI,aAAa,kBAAkB;AACjC,8BAAc,mBAAmB,aAAa;AAC9C,8BAAc,sBAAsB,aAAa;AAAA,cACnD;AAAA,YACF;AAAA,UACF;AAEA,gBAAM,KAAK,eAAe,YAAY;AAAA,QACxC,CAAC;AAAA,MACH;AAEA,aAAO;AAAA,IACT,SAAS,OAAO;AACd,aAAO,CAAC;AAAA,IACV;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKA,MAAc,wBAAwB,QAAiD;AACrF,UAAM,EAAE,QAAAG,QAAO,IAAI,MAAM,OAAO,YAAY;AAC5C,UAAM,WAAWA,QAAO,SAAS,EAAE,SAAS,MAAM,MAAM,OAAO,CAAC;AAChE,UAAM,WAAW,MAAM,SAAS,aAAa,KAAK;AAClD,UAAM,QAAQ,SAAS,KAAK,SAAS,CAAC;AAEtC,UAAM,YAA8B,MAAM,IAAI,UAAQ;AAAA,MACpD,IAAI,IAAI,MAAM;AAAA,MACd,SAAS,IAAI,WAAW;AAAA,MACxB,iBAAiB,IAAI,mBAAmB;AAAA,MACxC,YAAY,IAAI,cAAc;AAAA,MAC9B,SAAS,IAAI,WAAW;AAAA,MACxB,iBAAiB,IAAI,mBAAmB;AAAA,IAC1C,EAAE;AAGF,cAAU,KAAK,CAAC,GAAG,MAAM;AACvB,UAAI,EAAE,WAAW,CAAC,EAAE,QAAS,QAAO;AACpC,UAAI,CAAC,EAAE,WAAW,EAAE,QAAS,QAAO;AACpC,cAAQ,EAAE,mBAAmB,EAAE,SAAS,cAAc,EAAE,mBAAmB,EAAE,OAAO;AAAA,IACtF,CAAC;AAED,WAAO;AAAA,EACT;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,MAAc,aAAa,QAAuC;AAChE,QAAI;AAEF,YAAM,YAAY,MAAM,OAAO,aAAa,OAAO,YAAY,gBAAgB,EAAE;AACjF,UAAI,UAAU,OAAO;AACnB,eAAO,UAAU;AAAA,MACnB;AAAA,IACF,QAAQ;AAAA,IAER;AAGA,QAAI;AACF,YAAM,EAAE,QAAAA,QAAO,IAAI,MAAM,OAAO,YAAY;AAC5C,YAAM,WAAWA,QAAO,SAAS,EAAE,SAAS,MAAM,MAAM,OAAO,CAAC;AAChE,YAAM,WAAW,MAAM,SAAS,UAAU,IAAI,EAAE,YAAY,UAAU,CAAC;AACvE,YAAM,YAAY,SAAS,KAAK;AAEhC,UAAI,aAAa,UAAU,SAAS,GAAG,GAAG;AACxC,eAAO;AAAA,MACT;AAAA,IACF,QAAQ;AAAA,IAER;AAEA,WAAO;AAAA,EACT;AACF;;;ADvtBA;AACA;AAJA,OAAO,UAAU;AACjB,SAAS,OAAAC,YAAW;AACpB,OAAO,UAAU;;;AEJjB,OAAOC,SAAQ;AACf,OAAOC,WAAU;AACjB,SAAS,iBAAAC,sBAAqB;AAE9B,IAAM,aAAaA,eAAc,YAAY,GAAG;AAChD,IAAM,YAAYD,MAAK,QAAQ,UAAU;AAKlC,SAAS,WAAW,MAAsB;AAC/C,QAAM,cAAsC;AAAA,IAC1C,KAAK;AAAA,IACL,KAAK;AAAA,IACL,KAAK;AAAA,IACL,KAAK;AAAA,IACL,KAAK;AAAA,EACP;AACA,SAAO,KAAK,QAAQ,YAAY,UAAQ,YAAY,IAAI,CAAC;AAC3D;AASA,eAAsB,YAAY,UAAmC;AAInE,QAAM,YAAY;AAAA,IAChBA,MAAK,KAAK,WAAW,QAAQ;AAAA;AAAA,IAC7BA,MAAK,KAAK,WAAW,OAAO,QAAQ;AAAA;AAAA,EACtC;AAEA,aAAW,YAAY,WAAW;AAChC,QAAI;AACF,YAAMD,IAAG,OAAO,QAAQ;AACxB,aAAOA,IAAG,SAAS,UAAU,OAAO;AAAA,IACtC,QAAQ;AAAA,IAER;AAAA,EACF;AAEA,QAAM,IAAI,MAAM,uBAAuB,QAAQ,YAAY,UAAU,KAAK,IAAI,CAAC,EAAE;AACnF;AAKA,eAAe,aAAa,cAAuC;AACjE,SAAO,YAAY,YAAY;AACjC;AAaA,eAAsB,kBAAkB,QAA4C;AAClF,QAAM,WAAW,MAAM,aAAa,mBAAmB;AACvD,QAAM,gBAAgB,WAAW,OAAO,SAAS;AAGjD,MAAI;AACJ,MAAI,OAAO,OAAO;AAChB,yBAAqB;AAAA,iCACQ,WAAW,OAAO,KAAK,CAAC;AAAA,gDACT,aAAa;AAAA,EAC3D,OAAO;AACL,yBAAqB;AAAA;AAAA,gDAEuB,aAAa;AAAA,EAC3D;AAEA,QAAM,qBAAqB,OAAO,kBAC9B,2DACA;AAEJ,QAAM,gBAAgB,OAAO,oBACzB;AAAA;AAAA,0EAEoE,aAAa,SAAS,WAAW,OAAO,iBAAiB,CAAC;AAAA;AAAA;AAAA,mBAI9H;AAEJ,SAAO,SACJ,QAAQ,mBAAmB,kBAAkB,EAC7C,QAAQ,mBAAmB,kBAAkB,EAC7C,QAAQ,cAAc,aAAa;AACxC;AAUA,eAAsB,gBAAgB,QAA0C;AAC9E,QAAM,WAAW,MAAM,aAAa,iBAAiB;AACrD,QAAM,YAAY,WAAW,OAAO,YAAY;AAEhD,QAAM,qBAAqB,OAAO,kBAC9B,2DACA;AAEJ,SAAO,SACJ,QAAQ,oBAAoB,SAAS,EACrC,QAAQ,mBAAmB,kBAAkB;AAClD;AAUA,eAAsB,kBAAkB,QAA4C;AAClF,QAAM,WAAW,MAAM,aAAa,mBAAmB;AACvD,QAAM,gBAAgB,WAAW,OAAO,SAAS;AACjD,QAAM,cAAc,WAAW,OAAO,OAAO;AAE7C,SAAO,SACJ,QAAQ,sBAAsB,aAAa,EAC3C,QAAQ,eAAe,WAAW;AACvC;;;AF3HO,IAAM,aAAN,MAAiB;AAAA,EACd;AAAA;AAAA,EACA,mBAAwC;AAAA;AAAA,EACxC,SAA6B;AAAA,EAC7B;AAAA,EACA;AAAA,EACA,oBAA+C,oBAAI,IAAI;AAAA;AAAA,EACxD,4BAA4B;AAAA;AAAA,EAC3B,iBAAuD;AAAA;AAAA,EACvD,wBAAwB;AAAA;AAAA,EAEhC,YAAY,cAA4B;AACtC,SAAK,mBAAmB;AACxB,SAAK,eAAe,IAAI,aAAa,YAAY;AACjD,SAAK,YAAY,EAAE,OAAO,MAAM,KAAK,KAAK;AAAA,EAC5C;AAAA;AAAA;AAAA;AAAA,EAKA,MAAc,uBAAuB,MAAqC;AACxE,UAAM,EAAE,WAAW,cAAc,IAAI,MAAM,gBAAgB;AAC3D,WAAO,IAAIG;AAAA,MACT;AAAA,MACA;AAAA,MACA,oBAAoB,IAAI;AAAA,IAC1B;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKQ,iBAAiB,QAA8B;AACrD,WAAO,OAAO,gBAAgB;AAAA,MAC5B,aAAa;AAAA,MACb,OAAO,CAAC,0CAA0C;AAAA,MAClD,QAAQ;AAAA,IACV,CAAC;AAAA,EACH;AAAA,EAEQ,eAA4B;AAClC,UAAM,SAAS,KAAK,aAAa,OAAO,KAAK,QAAQ;AACnD,YAAM,MAAM,IAAIC,KAAI,IAAI,OAAO,KAAK,UAAU,IAAI,QAAQ,IAAI,EAAE;AAEhE,UAAI,IAAI,aAAa,eAAe;AAElC,cAAM,MAAM,MAAM,YAAY,YAAY;AAC1C,YAAI,UAAU,KAAK,EAAE,gBAAgB,0BAA0B,CAAC;AAChE,YAAI,IAAI,GAAG;AAAA,MAEb,WAAW,IAAI,aAAa,KAAK;AAE/B,cAAM,eAAe,KAAK,oBAAoB,KAAK;AACnD,cAAM,UAAU,KAAK,iBAAiB,YAAY;AAClD,cAAM,cAAcC,gBAAe;AAEnC,cAAM,cAAc,MAAM,kBAAkB;AAAA,UAC1C,WAAW;AAAA,UACX;AAAA,QACF,CAAC;AACD,YAAI,UAAU,KAAK,EAAE,gBAAgB,2BAA2B,CAAC;AACjE,YAAI,IAAI,WAAW;AAAA,MAErB,WAAW,IAAI,aAAa,mBAAmB;AAE7C,cAAM,OAAO,IAAI,aAAa,IAAI,MAAM;AACxC,YAAI,CAAC,MAAM;AACT,gBAAM,YAAY,MAAM,gBAAgB;AAAA,YACtC,cAAc;AAAA,UAChB,CAAC;AACD,cAAI,UAAU,KAAK,EAAE,gBAAgB,2BAA2B,CAAC;AACjE,cAAI,IAAI,SAAS;AACjB;AAAA,QACF;AAEA,YAAI,CAAC,KAAK,kBAAkB;AAC1B,gBAAM,YAAY,MAAM,gBAAgB;AAAA,YACtC,cAAc;AAAA,UAChB,CAAC;AACD,cAAI,UAAU,KAAK,EAAE,gBAAgB,2BAA2B,CAAC;AACjE,cAAI,IAAI,SAAS;AACjB;AAAA,QACF;AAEA,YAAI;AACF,gBAAM,EAAE,OAAO,IAAI,MAAM,KAAK,iBAAiB,SAAS,IAAI;AAC5D,gBAAM,KAAK,aAAa,WAAW,MAAM;AACzC,eAAK,4BAA4B;AAEjC,gBAAM,YAAY,KAAK,aAAa,aAAa;AACjD,gBAAM,cAAc,KAAK,aAAa,eAAe;AAGrD,cAAI,KAAK,uBAAuB;AAE9B,gBAAI,KAAK,gBAAgB;AACvB,2BAAa,KAAK,cAAc;AAChC,mBAAK,iBAAiB;AAAA,YACxB;AAEA,uBAAW,MAAM;AACf,mBAAK,KAAK,EAAE,MAAM,MAAM;AAAA,cAAC,CAAC;AAAA,YAC5B,GAAG,GAAI;AAAA,UACT;AAEA,gBAAM,cAAc,MAAM,kBAAkB;AAAA,YAC1C,WAAW;AAAA,YACX;AAAA,UACF,CAAC;AACD,cAAI,UAAU,KAAK,EAAE,gBAAgB,2BAA2B,CAAC;AACjE,cAAI,IAAI,WAAW;AAAA,QACrB,SAAS,OAAgB;AACvB,eAAK,4BAA4B;AACjC,gBAAM,UAAU,iBAAiB,QAAQ,MAAM,UAAU;AACzD,kBAAQ,OAAO,MAAM,6BAAwB,OAAO;AAAA,CAAI;AAExD,gBAAM,YAAY,MAAM,gBAAgB;AAAA,YACtC,cAAc;AAAA,UAChB,CAAC;AACD,cAAI,UAAU,KAAK,EAAE,gBAAgB,2BAA2B,CAAC;AACjE,cAAI,IAAI,SAAS;AAAA,QACnB;AAAA,MACF,OAAO;AAEL,YAAI,UAAU,KAAK,EAAE,gBAAgB,aAAa,CAAC;AACnD,YAAI,IAAI,WAAW;AAAA,MACrB;AAAA,IACF,CAAC;AAGD,WAAO,GAAG,cAAc,CAAC,WAAW;AAClC,WAAK,kBAAkB,IAAI,MAAM;AACjC,aAAO,GAAG,SAAS,MAAM;AACvB,aAAK,kBAAkB,OAAO,MAAM;AAAA,MACtC,CAAC;AAAA,IACH,CAAC;AAED,WAAO;AAAA,EACT;AAAA,EAEA,MAAM,MAAM,cAAc,MAAwB;AAEhD,WAAO,QAAQ,KAAK;AAAA,MAClB,KAAK,iBAAiB,WAAW;AAAA,MACjC,IAAI,QAAiB,CAAC,GAAG,WAAW;AAClC,mBAAW,MAAM,OAAO,IAAI,MAAM,8CAA8C,CAAC,GAAG,GAAK;AAAA,MAC3F,CAAC;AAAA,IACH,CAAC,EAAE,MAAM,MAAM,KAAK;AAAA,EACtB;AAAA,EAEA,MAAc,iBAAiB,cAAc,MAAwB;AACnE,QAAI,MAAM,KAAK,aAAa,eAAe,GAAG;AAC5C,WAAK,4BAA4B;AACjC,aAAO;AAAA,IACT;AAGA,UAAM,OAAO,MAAM,KAAK,2BAA2B;AACnD,QAAI,SAAS,MAAM;AACjB,cAAQ,OAAO,MAAM,kFAAkF,KAAK,UAAU,KAAK,IAAI,KAAK,UAAU,GAAG;AAAA,CAAoB;AAErK,WAAK,4BAA4B;AACjC,aAAO;AAAA,IACT;AAGA,QAAI;AACF,WAAK,mBAAmB,MAAM,KAAK,uBAAuB,IAAI;AAAA,IAChE,SAAS,OAAO;AAEZ,WAAK,4BAA4B;AACjC,YAAM,KAAK,KAAK;AAChB,aAAO;AAAA,IACX;AAGA,UAAM,eAAe,KAAK,iBAAiB,KAAK,gBAAgB;AAGhE,YAAQ,OAAO,MAAM;AAAA,gCAA4B,YAAY;AAAA;AAAA,CAAM;AACnE,YAAQ,OAAO,MAAM,8BAA8B,IAAI;AAAA;AAAA,CAAM;AAE7D,QAAI,aAAa;AACf,UAAI;AACF,cAAM,KAAK,YAAY;AACvB,gBAAQ,OAAO,MAAM;AAAA,CAAuE;AAAA,MAC9F,SAAS,OAAO;AACd,gBAAQ,OAAO,MAAM;AAAA,CAAmE;AAAA,MAC1F;AAAA,IACF,OAAO;AACL,cAAQ,OAAO,MAAM;AAAA,CAA0D;AAAA,IACjF;AAEA,WAAO;AAAA,EACT;AAAA,EAEA,MAAc,6BAAqD;AACjE,aAAS,OAAO,KAAK,UAAU,OAAO,QAAQ,KAAK,UAAU,KAAK,QAAQ;AACxE,UAAI;AACF,cAAM,IAAI,QAAc,CAACC,UAAS,WAAW;AAC3C,gBAAM,aAAa,KAAK,aAAa;AACrC,qBAAW,OAAO,MAAM,MAAM;AAC5B,iBAAK,SAAS;AACd,YAAAA,SAAQ;AAAA,UACV,CAAC;AACD,qBAAW,GAAG,SAAS,CAAC,QAA+B;AACrD,gBAAI,IAAI,SAAS,cAAc;AAE7B,yBAAW,MAAM,MAAM,OAAO,GAAG,CAAC;AAAA,YACpC,OAAO;AAEL,qBAAO,GAAG;AAAA,YACZ;AAAA,UACF,CAAC;AAAA,QACH,CAAC;AACD,eAAO;AAAA,MACT,SAAS,OAAgB;AAEvB,YAAI,EAAE,iBAAiB,SAAS,UAAU,SAAS,MAAM,SAAS,eAAe;AAE7E,iBAAO;AAAA,QACX;AAAA,MAEF;AAAA,IACF;AACA,WAAO;AAAA,EACT;AAAA,EAEO,iBAAgC;AACrC,QAAI,KAAK,QAAQ;AACf,YAAM,UAAU,KAAK,OAAO,QAAQ;AACpC,UAAI,OAAO,YAAY,YAAY,YAAY,MAAM;AACnD,eAAO,QAAQ;AAAA,MACjB;AAAA,IACF;AACA,WAAO;AAAA,EACT;AAAA,EAEA,MAAM,OAAsB;AAE1B,QAAI,KAAK,gBAAgB;AACvB,mBAAa,KAAK,cAAc;AAChC,WAAK,iBAAiB;AAAA,IACxB;AACA,SAAK,wBAAwB;AAE7B,WAAO,IAAI,QAAQ,CAACA,UAAS,WAAW;AACtC,UAAI,KAAK,QAAQ;AAEf,mBAAW,cAAc,KAAK,mBAAmB;AAC/C,qBAAW,QAAQ;AAAA,QACrB;AACA,aAAK,kBAAkB,MAAM;AAG7B,cAAM,UAAU,WAAW,MAAM;AAC/B,kBAAQ,OAAO,MAAM,yCAAyC;AAC9D,eAAK,SAAS;AACd,UAAAA,SAAQ;AAAA,QACV,GAAG,GAAI;AAEP,aAAK,OAAO,MAAM,CAAC,QAAQ;AACzB,uBAAa,OAAO;AACpB,cAAI,KAAK;AACP,mBAAO,GAAG;AAAA,UACZ,OAAO;AACL,iBAAK,SAAS;AACd,YAAAA,SAAQ;AAAA,UACV;AAAA,QACF,CAAC;AAAA,MACH,OAAO;AACL,QAAAA,SAAQ;AAAA,MACV;AAAA,IACF,CAAC;AAAA,EACH;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAcA,MAAM,gBAAgBC,YAAmD;AAEvE,QAAI,KAAK,QAAQ;AACf,YAAM,KAAK,KAAK;AAAA,IAClB;AAGA,SAAK,aAAa,eAAeA,UAAS;AAG1C,UAAM,OAAO,MAAM,KAAK,2BAA2B;AACnD,QAAI,SAAS,MAAM;AACjB,aAAO;AAAA,QACL,SAAS;AAAA,QACT,OAAO,sCAAsC,KAAK,UAAU,KAAK,IAAI,KAAK,UAAU,GAAG;AAAA,MACzF;AAAA,IACF;AAGA,QAAI;AACF,WAAK,mBAAmB,MAAM,KAAK,uBAAuB,IAAI;AAAA,IAChE,SAAS,OAAO;AACd,YAAM,KAAK,KAAK;AAChB,aAAO;AAAA,QACL,SAAS;AAAA,QACT,OAAO,qCAAqC,iBAAiB,QAAQ,MAAM,UAAU,eAAe;AAAA,MACtG;AAAA,IACF;AAGA,UAAM,UAAU,KAAK,iBAAiB,KAAK,gBAAgB;AAG3D,SAAK,wBAAwB;AAC7B,SAAK,4BAA4B;AAGjC,SAAK,iBAAiB,WAAW,YAAY;AAC3C,UAAI,CAAC,KAAK,2BAA2B;AACnC,gBAAQ,OAAO,MAAM,6BAA6BA,UAAS;AAAA,CAAiC;AAC5F,cAAM,KAAK,KAAK;AAAA,MAClB;AAAA,IACF,GAAG,IAAI,KAAK,GAAI;AAEhB,WAAO;AAAA,MACL,SAAS;AAAA,MACT;AAAA,MACA,aAAa,oBAAoB,IAAI;AAAA,IACvC;AAAA,EACF;AACF;;;AGjWA,SAAS,SAAS;AAClB,SAAS,uBAAuB;;;ACGzB,IAAM,uBAAuB;AAAA,EAClC;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AACF;AAKO,IAAM,uBAA4C;AAAA,EACvD;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AACF;AAKO,SAAS,eAAe,QAAuC;AACpE,QAAM,cAAmC,CAAC;AAC1C,QAAM,gBAA0B,CAAC;AAEjC,aAAW,SAAS,QAAQ;AAC1B,QAAI,qBAAqB,SAAS,KAA0B,GAAG;AAC7D,kBAAY,KAAK,KAA0B;AAAA,IAC7C,OAAO;AACL,oBAAc,KAAK,KAAK;AAAA,IAC1B;AAAA,EACF;AAEA,MAAI,cAAc,SAAS,GAAG;AAC5B,UAAM,IAAI,MAAM,6BAA6B,cAAc,KAAK,IAAI,CAAC,qBAAqB,qBAAqB,KAAK,IAAI,CAAC,EAAE;AAAA,EAC7H;AAEA,SAAO;AACT;AAMA,SAAS,cACP,iBACA,kBAA2B,MACM;AACjC,MAAI,CAAC,mBAAmB,gBAAgB,WAAW,GAAG;AACpD,WAAO;AAAA,EACT;AAEA,QAAM,cAAc,eAAe,eAAe;AAElD,SAAO,kBACH,CAAC,GAAG,oBAAI,IAAI,CAAC,GAAG,sBAAsB,GAAG,WAAW,CAAC,CAAC,IACtD;AACN;AAQO,SAAS,oBACd,iBACA,kBAA2B,MACP;AACpB,QAAM,SAAS,cAAc,iBAAiB,eAAe;AAC7D,MAAI,CAAC,OAAQ,QAAO;AAGpB,SAAO,SAAS,OAAO,KAAK,GAAG,CAAC;AAClC;AAKO,SAAS,0BACd,iBACA,kBAA2B,MACP;AACpB,QAAM,SAAS,cAAc,iBAAiB,eAAe;AAC7D,MAAI,CAAC,OAAQ,QAAO;AAGpB,SAAO,OAAO,KAAK,GAAG;AACxB;AAMO,SAAS,mBACd,iBACA,kBAA2B,MACP;AAEpB,MAAI,CAAC,mBAAmB,gBAAgB,WAAW,GAAG;AACpD,WAAO;AAAA,EACT;AAEA,QAAM,iBAAiB,oBAAoB,iBAAiB,eAAe;AAC3E,MAAI,CAAC,gBAAgB;AACnB,WAAO;AAAA,EACT;AAGA,SAAO,GAAG,cAAc;AAC1B;;;ACjJA;AAJA,SAAS,UAAU,iBAAiB;AAEpC,SAAS,eAAAC,oBAAmB;AAC5B,SAAsB,UAAAC,eAAc;;;ACFpC;AADA,SAAsB,cAAc;AA2BpC,IAAM,kBAA0C;AAAA,EAC9C,SAAS;AAAA,EACT,UAAU;AAAA,EACV,UAAU;AAAA,EACV,kBAAkB;AACpB;AAOO,IAAM,mBAAN,MAAM,kBAAiB;AAAA,EAC5B,OAAe,WAAoC;AAAA,EAE3C,QAAqE,oBAAI,IAAI;AAAA,EACpE,YAAY,IAAI,KAAK;AAAA;AAAA;AAAA,EAG9B,mBAA4D,oBAAI,IAAI;AAAA;AAAA;AAAA;AAAA,EAK5E,OAAO,cAAgC;AACrC,QAAI,CAAC,kBAAiB,UAAU;AAC9B,wBAAiB,WAAW,IAAI,kBAAiB;AAAA,IACnD;AACA,WAAO,kBAAiB;AAAA,EAC1B;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,OAAO,gBAAsB;AAC3B,QAAI,kBAAiB,UAAU;AAC7B,wBAAiB,SAAS,WAAW;AAAA,IACvC;AACA,sBAAiB,WAAW;AAAA,EAC9B;AAAA;AAAA;AAAA;AAAA,EAKQ,YAAY,MAA0C;AAC5D,UAAM,iBAAiB,wBAAwB;AAC/C,UAAM,SAAc;AAAA,MAClB,SAAS;AAAA,MACT;AAAA,MACA,SAAS;AAAA,IACX;AACA,QAAI,gBAAgB;AAClB,aAAO,iBAAiB;AAAA,IAC1B;AACA,WAAO,OAAO,SAAS,MAAM;AAAA,EAC/B;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,MAAM,oBAAoB,UAAiE;AACzF,UAAM,WAAW,MAAM,KAAK,SAAS,KAAK,CAAC,EAAE,KAAK,EAAE,KAAK,GAAG;AAG5D,UAAM,WAAW,KAAK,iBAAiB,IAAI,QAAQ;AACnD,QAAI,UAAU;AACZ,aAAO;AAAA,IACT;AAGA,UAAM,SAAS,KAAK,MAAM,IAAI,QAAQ;AACtC,QAAI,UAAU,KAAK,IAAI,IAAI,OAAO,YAAY,KAAK,WAAW;AAC5D,aAAO,OAAO;AAAA,IAChB;AAGA,UAAM,iBAAiB,KAAK,8BAA8B,UAAU,QAAQ;AAC5E,SAAK,iBAAiB,IAAI,UAAU,cAAc;AAElD,QAAI;AACF,aAAO,MAAM;AAAA,IACf,UAAE;AAEA,WAAK,iBAAiB,OAAO,QAAQ;AAAA,IACvC;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKA,MAAc,8BACZ,UACA,UAC4B;AAE5B,UAAM,qBAAqB,MAAM,QAAQ;AAAA,MACvC,MAAM,KAAK,SAAS,QAAQ,CAAC,EAAE,IAAI,OAAO,CAACC,YAAW,MAAM,MAAM;AAChE,YAAI;AACF,gBAAM,WAAW,KAAK,YAAY,MAAM;AACxC,gBAAM,WAAW,MAAM,SAAS,aAAa,KAAK;AAClD,iBAAO;AAAA,YACL,WAAAA;AAAA,YACA,WAAW,SAAS,KAAK,SAAS,CAAC;AAAA,UACrC;AAAA,QACF,SAAS,OAAO;AAEd,iBAAO;AAAA,YACL,WAAAA;AAAA,YACA,WAAW,CAAC;AAAA,UACd;AAAA,QACF;AAAA,MACF,CAAC;AAAA,IACH;AAGA,UAAM,cAAc,oBAAI,IAA8B;AAEtD,eAAW,EAAE,WAAAA,YAAW,UAAU,KAAK,oBAAoB;AACzD,iBAAW,OAAO,WAAW;AAC3B,YAAI,CAAC,IAAI,GAAI;AAEb,cAAM,SAAyB;AAAA,UAC7B,WAAAA;AAAA,UACA,YAAa,IAAI,cAA+C;AAAA,UAChE,SAAS,IAAI,WAAW;AAAA,UACxB,SAAS,IAAI,WAAW,IAAI;AAAA,UAC5B,iBAAiB,IAAI,mBAAmB;AAAA,QAC1C;AAEA,cAAM,WAAW,YAAY,IAAI,IAAI,EAAE,KAAK,CAAC;AAC7C,iBAAS,KAAK,MAAM;AACpB,oBAAY,IAAI,IAAI,IAAI,QAAQ;AAAA,MAClC;AAAA,IACF;AAGA,UAAM,UAA6B,MAAM,KAAK,YAAY,QAAQ,CAAC,EAAE,IAAI,CAAC,CAAC,YAAYC,SAAQ,MAAM;AAEnG,YAAM,iBAAiB,CAAC,GAAGA,SAAQ,EAAE,KAAK,CAAC,GAAG,MAAM;AAClD,cAAM,QAAQ,gBAAgB,EAAE,UAAU,KAAK;AAC/C,cAAM,QAAQ,gBAAgB,EAAE,UAAU,KAAK;AAC/C,eAAO,QAAQ;AAAA,MACjB,CAAC;AAED,YAAM,mBAAmB,eAAe,CAAC,EAAE;AAG3C,YAAM,gBAAgBA,UAAS,KAAK,OAAK,EAAE,OAAO;AAClD,YAAM,kBAAkB,eAAe,CAAC;AACxC,YAAM,cACJ,eAAe,mBACf,gBAAgB,mBAChB,gBAAgB;AAElB,aAAO;AAAA,QACL;AAAA,QACA,UAAAA;AAAA,QACA;AAAA,QACA;AAAA,MACF;AAAA,IACF,CAAC;AAGD,SAAK,MAAM,IAAI,UAAU;AAAA,MACvB,MAAM;AAAA,MACN,WAAW,KAAK,IAAI;AAAA,IACtB,CAAC;AAED,WAAO;AAAA,EACT;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,MAAM,sBACJ,YACA,UACA,gBAAkC,QACyB;AAC3D,UAAM,UAAU,MAAM,KAAK,oBAAoB,QAAQ;AACvD,UAAM,WAAW,QAAQ,KAAK,OAAK,EAAE,eAAe,UAAU;AAE9D,QAAI,CAAC,UAAU;AACb,aAAO;AAAA,IACT;AAEA,QAAI,kBAAkB,SAAS;AAE7B,YAAMC,mBAAkB,SAAS,SAAS,KAAK,OAAK,EAAE,cAAc,SAAS,gBAAgB;AAC7F,UAAI,CAACA,iBAAiB,QAAO;AAG7B,UAAIA,iBAAgB,eAAe,WAAWA,iBAAgB,eAAe,UAAU;AACrF,eAAO;AAAA,UACL,WAAWA,iBAAgB;AAAA,UAC3B,YAAYA,iBAAgB;AAAA,QAC9B;AAAA,MACF;AACA,aAAO;AAAA,IACT;AAGA,UAAM,kBAAkB,SAAS,SAAS,KAAK,OAAK,EAAE,cAAc,SAAS,gBAAgB;AAC7F,QAAI,CAAC,gBAAiB,QAAO;AAE7B,WAAO;AAAA,MACL,WAAW,gBAAgB;AAAA,MAC3B,YAAY,gBAAgB;AAAA,IAC9B;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,uBACJ,YACA,UAC2B;AAC3B,UAAM,UAAU,MAAM,KAAK,oBAAoB,QAAQ;AACvD,UAAM,WAAW,QAAQ,KAAK,OAAK,EAAE,eAAe,UAAU;AAC9D,WAAO,UAAU,YAAY,CAAC;AAAA,EAChC;AAAA;AAAA;AAAA;AAAA,EAKA,aAAmB;AACjB,SAAK,MAAM,MAAM;AACjB,SAAK,iBAAiB,MAAM;AAAA,EAC9B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAYA,MAAM,wBACJ,UACA,UACA,gBAAkC,QAC6C;AAG/E,QAAI,aAAa,WAAW;AAC1B,UAAI,SAAS,SAAS,GAAG;AACvB,cAAM,CAACF,UAAS,IAAI,SAAS,KAAK;AAElC,eAAO,EAAE,YAAY,WAAW,WAAAA,YAAW,YAAY,QAAQ;AAAA,MACjE;AAGA,YAAM,SAAS,MAAM,KAAK,sBAAsB,UAAU,UAAU,aAAa;AACjF,UAAI,QAAQ;AACV,eAAO,EAAE,YAAY,UAAU,GAAG,OAAO;AAAA,MAC3C;AAGA,YAAM,CAAC,cAAc,IAAI,SAAS,KAAK;AACvC,aAAO,EAAE,YAAY,WAAW,WAAW,gBAAgB,YAAY,QAAQ;AAAA,IACjF;AAGA,QAAI,SAAS,SAAS,GAAG,GAAG;AAC1B,YAAM,SAAS,MAAM,KAAK,sBAAsB,UAAU,UAAU,aAAa;AACjF,UAAI,QAAQ;AACV,eAAO,EAAE,YAAY,UAAU,GAAG,OAAO;AAAA,MAC3C;AACA,aAAO;AAAA,IACT;AAGA,UAAM,UAAU,MAAM,KAAK,oBAAoB,QAAQ;AACvD,UAAM,YAAY,SAAS,YAAY;AAIvC,QAAI;AAGJ,YAAQ,QAAQ;AAAA,MAAK,SACnB,IAAI,SAAS,KAAK,OAAK,EAAE,oBAAoB,QAAQ;AAAA,IACvD;AAGA,QAAI,CAAC,OAAO;AACV,cAAQ,QAAQ;AAAA,QAAK,SACnB,IAAI,SAAS,KAAK,OAAK,EAAE,iBAAiB,YAAY,MAAM,SAAS;AAAA,MACvE;AAAA,IACF;AAGA,QAAI,CAAC,OAAO;AACV,cAAQ,QAAQ,KAAK,SAAO,IAAI,gBAAgB,QAAQ;AAAA,IAC1D;AAGA,QAAI,CAAC,OAAO;AACV,cAAQ,QAAQ,KAAK,SAAO,IAAI,YAAY,YAAY,MAAM,SAAS;AAAA,IACzE;AAGA,QAAI,CAAC,OAAO;AACV,cAAQ,QAAQ;AAAA,QAAK,SACnB,IAAI,SAAS,KAAK,OAAK,EAAE,YAAY,QAAQ;AAAA,MAC/C;AAAA,IACF;AAGA,QAAI,CAAC,OAAO;AACV,cAAQ,QAAQ;AAAA,QAAK,SACnB,IAAI,SAAS,KAAK,OAAK,EAAE,QAAQ,YAAY,MAAM,SAAS;AAAA,MAC9D;AAAA,IACF;AAEA,QAAI,CAAC,OAAO;AACV,aAAO;AAAA,IACT;AAGA,QAAI,kBAAkB,SAAS;AAC7B,YAAME,mBAAkB,MAAM,SAAS,KAAK,OAAK,EAAE,cAAc,MAAO,gBAAgB;AACxF,UAAI,CAACA,oBAAoBA,iBAAgB,eAAe,WAAWA,iBAAgB,eAAe,UAAW;AAC3G,eAAO;AAAA,MACT;AACA,aAAO;AAAA,QACL,YAAY,MAAM;AAAA,QAClB,WAAWA,iBAAgB;AAAA,QAC3B,YAAYA,iBAAgB;AAAA,MAC9B;AAAA,IACF;AAGA,UAAM,kBAAkB,MAAM,SAAS,KAAK,OAAK,EAAE,cAAc,MAAO,gBAAgB;AACxF,QAAI,CAAC,iBAAiB;AACpB,aAAO;AAAA,IACT;AAEA,WAAO;AAAA,MACL,YAAY,MAAM;AAAA,MAClB,WAAW,gBAAgB;AAAA,MAC3B,YAAY,gBAAgB;AAAA,IAC9B;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAYA,MAAM,2BACJ,YACA,UACA,SAIC;AACD,UAAM,WAAW,oBAAI,IAAsB;AAC3C,UAAM,WAAqB,CAAC;AAG5B,UAAM,oBAAoB,SAAS,qBAC/B,IAAI,IAAI,MAAM,KAAK,SAAS,QAAQ,CAAC,EAAE,OAAO,CAAC,CAAC,EAAE,MAAM,QAAQ,mBAAoB,SAAS,EAAE,CAAC,CAAC,IACjG;AAEJ,eAAW,YAAY,YAAY;AAEjC,YAAM,aAAa,MAAM,KAAK,wBAAwB,UAAU,mBAAmB,MAAM;AAEzF,UAAI,CAAC,YAAY;AACf,iBAAS,KAAK,aAAa,QAAQ,4BAA4B;AAC/D;AAAA,MACF;AAEA,YAAM,EAAE,YAAY,WAAAF,WAAU,IAAI;AAGlC,YAAM,mBAAmB,SAAS,IAAIA,UAAS,KAAK,CAAC;AACrD,UAAI,CAAC,iBAAiB,SAAS,UAAU,GAAG;AAC1C,yBAAiB,KAAK,UAAU;AAAA,MAClC;AACA,eAAS,IAAIA,YAAW,gBAAgB;AAAA,IAC1C;AAEA,WAAO,EAAE,UAAU,SAAS;AAAA,EAC9B;AACF;;;ADraA;;;AEGO,SAAS,sBAAsB,UAA2B;AAC7D,SAAO,2DAA2D,KAAK,QAAQ;AACnF;AAaO,SAAS,iBAAiB,UAAkB,kBAAkC;AACjF,MAAI,sBAAsB,QAAQ,GAAG;AAEjC,WAAO;AAAA,EACX,OAAO;AAEH,QAAI;AAEA,YAAM,QAAQ,SAAS,MAAM,mDAAmD;AAChF,UAAI,CAAC,OAAO;AACR,cAAM,IAAI,MAAM,yBAAyB;AAAA,MAC7C;AAEA,YAAM,CAAC,EAAE,MAAM,OAAO,KAAK,MAAM,QAAQ,MAAM,IAAI,MAAM,IAAI,MAAM;AAGnE,YAAM,UAAU,IAAI,KAAK,KAAK,IAAI,MAAM,QAAQ,GAAG,KAAK,MAAM,QAAQ,MAAM,CAAC;AAI7E,YAAM,aAAa,sBAAsB,MAAM,QAAQ,GAAG,KAAK,MAAM,QAAQ,QAAQ,gBAAgB;AAErG,aAAO,WAAW,YAAY,EAAE,QAAQ,WAAW,GAAG;AAAA,IAC1D,SAAS,OAAO;AAEZ,aAAO,WAAW;AAAA,IACtB;AAAA,EACJ;AACJ;AAKA,SAAS,sBAAsB,MAAc,OAAe,KAAa,MAAc,QAAgB,QAAgB,UAAwB;AAG3I,MAAI,WAAW,IAAI,KAAK,KAAK,IAAI,MAAM,OAAO,KAAK,MAAM,QAAQ,MAAM,CAAC;AAGxE,QAAM,UAAsC;AAAA,IACxC,UAAU;AAAA,IACV,MAAM;AAAA,IACN,OAAO;AAAA,IACP,KAAK;AAAA,IACL,MAAM;AAAA,IACN,QAAQ;AAAA,IACR,QAAQ;AAAA,IACR,QAAQ;AAAA,EACZ;AAGA,QAAM,YAAY,IAAI,KAAK,eAAe,SAAS,OAAO;AAC1D,QAAM,sBAAsB,UAAU,OAAO,QAAQ;AAGrD,QAAM,CAAC,UAAU,QAAQ,IAAI,oBAAoB,MAAM,GAAG;AAC1D,QAAM,CAAC,YAAY,aAAa,SAAS,IAAI,SAAS,MAAM,GAAG,EAAE,IAAI,MAAM;AAC3E,QAAM,CAAC,YAAY,cAAc,YAAY,IAAI,SAAS,MAAM,GAAG,EAAE,IAAI,MAAM;AAG/E,QAAM,aAAa,IAAI,KAAK,MAAM,OAAO,KAAK,MAAM,QAAQ,MAAM,EAAE,QAAQ;AAC5E,QAAM,aAAa,IAAI,KAAK,YAAY,cAAc,GAAG,WAAW,YAAY,cAAc,YAAY,EAAE,QAAQ;AACpH,QAAM,WAAW,aAAa;AAG9B,SAAO,IAAI,KAAK,SAAS,QAAQ,IAAI,QAAQ;AACjD;AASO,SAAS,iBAAiB,UAAkB,kBAAmF;AAGlI,MAAI,CAAC,IAAI,KAAK,QAAQ,GAAG;AAErB,WAAO,EAAE,MAAM,SAAS;AAAA,EAC5B;AAGA,MAAI,sBAAsB,QAAQ,GAAG;AAEjC,WAAO,EAAE,UAAU,SAAS;AAAA,EAChC,OAAO;AAEH,WAAO,EAAE,UAAU,UAAU,UAAU,iBAAiB;AAAA,EAC5D;AACJ;;;AFzGO,IAAe,kBAAf,MAA4C;AAAA,EACrC,mBAAqC,iBAAiB,YAAY;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASpE,mBAAmBG,YAA2B;AAClD,WAAOA,WAAU,YAAY;AAAA,EACjC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAUU,2BAA2BA,YAA+B,UAAmD;AAEnH,QAAI,SAAS,SAAS,GAAG;AACrB,YAAM,IAAI;AAAA,QACN,UAAU;AAAA,QACV;AAAA,MACJ;AAAA,IACJ;AAGA,QAAIA,YAAW;AACX,YAAM,eAAe,KAAK,mBAAmBA,UAAS;AACtD,UAAI;AACA,0BAAkB,YAAY;AAAA,MAClC,SAAS,OAAO;AACZ,cAAM,IAAI;AAAA,UACN,UAAU;AAAA,UACV,iBAAiB,QAAQ,MAAM,UAAU;AAAA,QAC7C;AAAA,MACJ;AAEA,YAAMC,UAAS,SAAS,IAAI,YAAY;AACxC,UAAI,CAACA,SAAQ;AACT,cAAM,oBAAoB,MAAM,KAAK,SAAS,KAAK,CAAC,EAAE,KAAK,IAAI;AAC/D,cAAM,IAAI;AAAA,UACN,UAAU;AAAA,UACV,YAAY,YAAY,oCAAoC,iBAAiB;AAAA,QACjF;AAAA,MACJ;AACA,aAAOA;AAAA,IACX;AAGA,UAAM,mBAAmB,MAAM,KAAK,SAAS,KAAK,CAAC,EAAE,KAAK;AAC1D,UAAM,iBAAiB,iBAAiB,CAAC;AACzC,UAAM,SAAS,SAAS,IAAI,cAAc;AAC1C,QAAI,CAAC,QAAQ;AACT,YAAM,IAAI;AAAA,QACN,UAAU;AAAA,QACV;AAAA,MACJ;AAAA,IACJ;AACA,WAAO;AAAA,EACX;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASU,oBAAoBD,YAA+B,UAAmD;AAE5G,QAAI,SAAS,SAAS,GAAG;AACrB,YAAM,IAAI;AAAA,QACN,UAAU;AAAA,QACV;AAAA,MACJ;AAAA,IACJ;AAGA,QAAIA,YAAW;AAEX,YAAM,eAAe,KAAK,mBAAmBA,UAAS;AAGtD,UAAI;AACA,0BAAkB,YAAY;AAAA,MAClC,SAAS,OAAO;AACZ,cAAM,IAAI;AAAA,UACN,UAAU;AAAA,UACV,iBAAiB,QAAQ,MAAM,UAAU;AAAA,QAC7C;AAAA,MACJ;AAGA,YAAM,SAAS,SAAS,IAAI,YAAY;AACxC,UAAI,CAAC,QAAQ;AACT,cAAME,qBAAoB,MAAM,KAAK,SAAS,KAAK,CAAC,EAAE,KAAK,IAAI;AAC/D,cAAM,IAAI;AAAA,UACN,UAAU;AAAA,UACV,YAAY,YAAY,oCAAoCA,kBAAiB;AAAA,QACjF;AAAA,MACJ;AAEA,aAAO;AAAA,IACX;AAGA,QAAI,SAAS,SAAS,GAAG;AAErB,YAAM,cAAc,SAAS,OAAO,EAAE,KAAK,EAAE;AAC7C,UAAI,CAAC,aAAa;AACd,cAAM,IAAI;AAAA,UACN,UAAU;AAAA,UACV;AAAA,QACJ;AAAA,MACJ;AACA,aAAO;AAAA,IACX;AAGA,UAAM,oBAAoB,MAAM,KAAK,SAAS,KAAK,CAAC,EAAE,KAAK,IAAI;AAC/D,UAAM,IAAI;AAAA,MACN,UAAU;AAAA,MACV,gCAAgC,iBAAiB;AAAA,IACrD;AAAA,EACJ;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASU,sBACN,YACA,UACyB;AAEzB,QAAI,SAAS,SAAS,GAAG;AACrB,YAAM,IAAI;AAAA,QACN,UAAU;AAAA,QACV;AAAA,MACJ;AAAA,IACJ;AAGA,UAAM,MAAM,KAAK,oBAAoB,UAAU;AAG/C,QAAI,IAAI,WAAW,GAAG;AAClB,UAAI,SAAS,SAAS,GAAG;AAErB,eAAO;AAAA,MACX;AAEA,aAAO;AAAA,IACX;AAGA,UAAM,SAAS,oBAAI,IAA0B;AAE7C,eAAW,MAAM,KAAK;AAElB,YAAM,eAAe,KAAK,mBAAmB,EAAE;AAE/C,UAAI;AACA,0BAAkB,YAAY;AAAA,MAClC,SAAS,OAAO;AACZ,cAAM,IAAI;AAAA,UACN,UAAU;AAAA,UACV,iBAAiB,QAAQ,MAAM,UAAU;AAAA,QAC7C;AAAA,MACJ;AAEA,YAAM,SAAS,SAAS,IAAI,YAAY;AACxC,UAAI,CAAC,QAAQ;AACT,cAAM,oBAAoB,MAAM,KAAK,SAAS,KAAK,CAAC,EAAE,KAAK,IAAI;AAC/D,cAAM,IAAI;AAAA,UACN,UAAU;AAAA,UACV,YAAY,YAAY,oCAAoC,iBAAiB;AAAA,QACjF;AAAA,MACJ;AAEA,aAAO,IAAI,cAAc,MAAM;AAAA,IACnC;AAEA,WAAO;AAAA,EACX;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASA,MAAgB,2BACZ,YACA,UAC2D;AAC3D,WAAO,KAAK,4BAA4B,YAAY,UAAU,OAAO;AAAA,EACzE;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQA,MAAgB,4BACZ,YACA,UACA,WAC2D;AAE3D,QAAI,SAAS,SAAS,GAAG;AACrB,YAAM,QAAQ,SAAS,QAAQ,EAAE,KAAK,EAAE;AACxC,UAAI,OAAO;AACP,cAAM,CAACF,YAAWC,OAAM,IAAI;AAC5B,eAAO,EAAE,WAAAD,YAAW,QAAAC,QAAO;AAAA,MAC/B;AAAA,IACJ;AAGA,UAAM,SAAS,MAAM,KAAK,iBAAiB;AAAA,MACvC;AAAA,MACA;AAAA,MACA;AAAA,IACJ;AAEA,QAAI,CAAC,QAAQ;AACT,aAAO;AAAA,IACX;AAEA,UAAM,SAAS,SAAS,IAAI,OAAO,SAAS;AAC5C,QAAI,CAAC,QAAQ;AACT,aAAO;AAAA,IACX;AAEA,WAAO;AAAA,MACH,WAAW,OAAO;AAAA,MAClB;AAAA,IACJ;AAAA,EACJ;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAkBA,MAAgB,2BACZD,YACA,kBACA,UACA,WACkG;AAElG,QAAIA,YAAW;AAEX,YAAM,sBAAsB,KAAK,mBAAmBA,UAAS;AAC7D,YAAMC,UAAS,KAAK,oBAAoB,qBAAqB,QAAQ;AAGrE,UAAI,qBAAqB;AACzB,UAAI,qBAAqB,aAAa,CAAC,iBAAiB,SAAS,GAAG,GAAG;AACnE,6BAAqB,MAAM,KAAK,kBAAkBA,SAAQ,gBAAgB;AAAA,MAC9E;AAEA,aAAO,EAAE,QAAAA,SAAQ,WAAW,qBAAqB,YAAY,oBAAoB,iBAAiB,MAAM;AAAA,IAC5G;AAGA,UAAM,aAAa,MAAM,KAAK,iBAAiB;AAAA,MAC3C;AAAA,MACA;AAAA,MACA;AAAA,IACJ;AAEA,QAAI,CAAC,YAAY;AACb,YAAM,oBAAoB,MAAM,KAAK,SAAS,KAAK,CAAC,EAAE,KAAK,IAAI;AAC/D,YAAM,aAAa,cAAc,UAAU,UAAU;AACrD,YAAM,IAAI;AAAA,QACN,UAAU;AAAA,QACV,kBAAkB,UAAU,wBAAwB,gBAAgB,0BAC7C,iBAAiB;AAAA,MAE5C;AAAA,IACJ;AAEA,UAAM,SAAS,SAAS,IAAI,WAAW,SAAS;AAChD,QAAI,CAAC,QAAQ;AACT,YAAM,IAAI;AAAA,QACN,UAAU;AAAA,QACV,0CAA0C,WAAW,SAAS;AAAA,MAClE;AAAA,IACJ;AAEA,WAAO;AAAA,MACH;AAAA,MACA,WAAW,WAAW;AAAA,MACtB,YAAY,WAAW;AAAA,MACvB,iBAAiB;AAAA,IACrB;AAAA,EACJ;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOU,oBAAoB,YAAqD;AAC/E,QAAI,CAAC,YAAY;AACb,aAAO,CAAC;AAAA,IACZ;AACA,WAAO,MAAM,QAAQ,UAAU,IAAI,aAAa,CAAC,UAAU;AAAA,EAC/D;AAAA,EAEU,qBAAqB,OAAuB;AAClD,QAAI,iBAAiBE,cAAa;AAC9B,YAAM,SAAS,MAAM,UAAU;AAC/B,YAAM,YAAY,MAAM,UAAU;AAGlC,UAAI,WAAW,UAAU,iBAAiB;AACtC,cAAM,IAAI;AAAA,UACN,UAAU;AAAA,UACV;AAAA,QACJ;AAAA,MACJ;AAEA,UAAI,WAAW,KAAK;AAEhB,cAAMC,gBAAe,WAAW,OAAO;AACvC,cAAMC,gBAAe,WAAW,OAAO,QAAQ;AAAA,UAAI,CAAC,MAChD,GAAG,EAAE,WAAW,EAAE,MAAM,GAAG,EAAE,WAAW,KAAK,EAAE,QAAQ,MAAM,EAAE;AAAA,QACnE,EAAE,KAAK,IAAI;AAGX,YAAIC;AACJ,YAAID,eAAc;AACd,UAAAC,eAAc,gBAAgBF,iBAAgB,4BAA4B,cAAcC,aAAY;AAAA,QACxG,WAAWD,eAAc;AACrB,UAAAE,eAAc,gBAAgBF,aAAY;AAAA,QAC9C,OAAO;AAEH,gBAAM,WAAW,KAAK,UAAU,WAAW,MAAM,CAAC;AAClD,UAAAE,eAAc,uDAAuD,QAAQ;AAAA,QACjF;AAEA,cAAM,IAAI;AAAA,UACN,UAAU;AAAA,UACVA;AAAA,QACJ;AAAA,MACJ;AAEA,UAAI,WAAW,KAAK;AAChB,cAAM,IAAI;AAAA,UACN,UAAU;AAAA,UACV,kBAAkB,WAAW,OAAO,WAAW,0BAA0B;AAAA,QAC7E;AAAA,MACJ;AAEA,UAAI,WAAW,KAAK;AAChB,cAAM,IAAI;AAAA,UACN,UAAU;AAAA,UACV,uBAAuB,WAAW,OAAO,WAAW,gDAAgD;AAAA,QACxG;AAAA,MACJ;AAEA,UAAI,WAAW,KAAK;AAChB,cAAMF,gBAAe,WAAW,OAAO,WAAW;AAGlD,YAAIA,cAAa,SAAS,0BAA0B,GAAG;AACnD,gBAAM,IAAI;AAAA,YACN,UAAU;AAAA,YACV;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,kBAONA,aAAY;AAAA,UACV;AAAA,QACJ;AAEA,cAAM,IAAI;AAAA,UACN,UAAU;AAAA,UACV,gDAAgDA,aAAY;AAAA,QAChE;AAAA,MACJ;AAEA,UAAI,UAAU,UAAU,KAAK;AACzB,cAAM,IAAI;AAAA,UACN,UAAU;AAAA,UACV,4BAA4B,WAAW,OAAO,WAAW,MAAM,OAAO;AAAA,QAC1E;AAAA,MACJ;AAGA,YAAM,eAAe,WAAW,OAAO,WAAW,MAAM;AACxD,YAAM,eAAe,WAAW,OAAO,QAAQ;AAAA,QAAI,CAAC,MAChD,GAAG,EAAE,WAAW,EAAE,MAAM,GAAG,EAAE,WAAW,KAAK,EAAE,QAAQ,MAAM,EAAE;AAAA,MACnE,EAAE,KAAK,IAAI;AAEX,YAAM,cAAc,eACd,qBAAqB,YAAY,cAAc,YAAY,KAC3D,qBAAqB,YAAY;AAEvC,YAAM,IAAI;AAAA,QACN,UAAU;AAAA,QACV;AAAA,MACJ;AAAA,IACJ;AAGA,QAAI,iBAAiB,OAAO;AACxB,YAAM,IAAI;AAAA,QACN,UAAU;AAAA,QACV,mBAAmB,MAAM,OAAO;AAAA,MACpC;AAAA,IACJ;AAEA,UAAM,IAAI;AAAA,MACN,UAAU;AAAA,MACV;AAAA,IACJ;AAAA,EACJ;AAAA,EAEU,YAAY,MAA0C;AAE5D,UAAM,iBAAiB,wBAAwB;AAE/C,UAAM,SAAc;AAAA,MAChB,SAAS;AAAA,MACT;AAAA,MACA,SAAS;AAAA;AAAA,IACb;AAGA,QAAI,gBAAgB;AAChB,aAAO,iBAAiB;AAAA,IAC5B;AAEA,WAAOG,QAAO,SAAS,MAAM;AAAA,EACjC;AAAA,EAEA,MAAgB,YAAe,SAAqB,YAAoB,KAAmB;AACvF,UAAM,iBAAiB,IAAI,QAAe,CAAC,GAAG,WAAW;AACrD,iBAAW,MAAM,OAAO,IAAI,MAAM,6BAA6B,SAAS,IAAI,CAAC,GAAG,SAAS;AAAA,IAC7F,CAAC;AAED,WAAO,QAAQ,KAAK,CAAC,SAAS,cAAc,CAAC;AAAA,EACjD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAaA,MAAgB,eACZP,YACA,kBACA,UACA,WAMD;AACC,UAAM,EAAE,QAAQ,WAAW,mBAAmB,YAAY,mBAAmB,IACzE,MAAM,KAAK,2BAA2BA,YAAW,kBAAkB,UAAU,SAAS;AAC1F,UAAM,WAAW,KAAK,YAAY,MAAM;AAExC,WAAO;AAAA,MACH;AAAA,MACA;AAAA,MACA,WAAW;AAAA,MACX,YAAY;AAAA,IAChB;AAAA,EACJ;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQA,MAAgB,mBAAmB,QAAsB,YAAmE;AACxH,QAAI;AACA,YAAM,WAAW,KAAK,YAAY,MAAM;AACxC,YAAM,WAAW,MAAM,SAAS,aAAa,IAAI,EAAE,WAAW,CAAC;AAC/D,UAAI,CAAC,SAAS,MAAM;AAChB,cAAM,IAAI,MAAM,YAAY,UAAU,YAAY;AAAA,MACtD;AACA,aAAO,SAAS;AAAA,IACpB,SAAS,OAAO;AACZ,YAAM,KAAK,qBAAqB,KAAK;AAAA,IACzC;AAAA,EACJ;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQA,MAAgB,oBAAoB,QAAsB,YAAqC;AAC3F,QAAI;AACA,YAAM,kBAAkB,MAAM,KAAK,mBAAmB,QAAQ,UAAU;AACxE,aAAO,gBAAgB,YAAY;AAAA,IACvC,SAAS,OAAO;AAEZ,aAAO;AAAA,IACX;AAAA,EACJ;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAaA,MAAgB,mBACZ,QACA,YACA,SACA,SACA,UACiE;AACjE,UAAM,WAAW,YAAY,MAAM,KAAK,oBAAoB,QAAQ,UAAU;AAC9E,WAAO;AAAA,MACH,SAAS,UAAU,iBAAiB,SAAS,QAAQ,IAAI;AAAA,MACzD,SAAS,UAAU,iBAAiB,SAAS,QAAQ,IAAI;AAAA,MACzD;AAAA,IACJ;AAAA,EACJ;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAwBA,MAAgB,kBAAkB,QAAsB,UAAmC;AAEvF,QAAI,aAAa,aAAa,SAAS,SAAS,GAAG,GAAG;AAClD,aAAO;AAAA,IACX;AAGA,QAAI;AACA,YAAM,WAAW,KAAK,YAAY,MAAM;AACxC,YAAM,WAAW,MAAM,SAAS,aAAa,KAAK;AAClD,YAAM,YAAY,SAAS,KAAK,SAAS,CAAC;AAE1C,YAAM,YAAY,SAAS,YAAY;AAGvC,UAAI,QAAQ,UAAU,KAAK,SAAO,IAAI,oBAAoB,QAAQ;AAGlE,UAAI,CAAC,OAAO;AACR,gBAAQ,UAAU;AAAA,UAAK,SACnB,IAAI,iBAAiB,YAAY,MAAM;AAAA,QAC3C;AAAA,MACJ;AAGA,UAAI,CAAC,OAAO;AACR,gBAAQ,UAAU,KAAK,SAAO,IAAI,YAAY,QAAQ;AAAA,MAC1D;AAGA,UAAI,CAAC,OAAO;AACR,gBAAQ,UAAU;AAAA,UAAK,SACnB,IAAI,SAAS,YAAY,MAAM;AAAA,QACnC;AAAA,MACJ;AAEA,UAAI,SAAS,MAAM,IAAI;AACnB,eAAO,MAAM;AAAA,MACjB;AAGA,YAAM,qBAAqB,UACtB,IAAI,SAAO;AACR,YAAI,IAAI,mBAAmB,IAAI,oBAAoB,IAAI,SAAS;AAC5D,iBAAO,IAAI,IAAI,eAAe,QAAQ,IAAI,OAAO,MAAM,IAAI,EAAE;AAAA,QACjE;AACA,eAAO,IAAI,IAAI,OAAO,MAAM,IAAI,EAAE;AAAA,MACtC,CAAC,EACA,KAAK,IAAI;AAEd,YAAM,IAAI;AAAA,QACN,UAAU;AAAA,QACV,aAAa,QAAQ,qCAAqC,sBAAsB,MAAM;AAAA,MAC1F;AAAA,IACJ,SAAS,OAAO;AACZ,UAAI,iBAAiB,UAAU;AAC3B,cAAM;AAAA,MACV;AACA,YAAM,KAAK,qBAAqB,KAAK;AAAA,IACzC;AAAA,EACJ;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOU,sBAA0D,QAAkB;AAClF,WAAO,OAAO,KAAK,CAAC,GAAG,MAAM;AACzB,YAAM,SAAS,EAAE,OAAO,YAAY,EAAE,OAAO,QAAQ;AACrD,YAAM,SAAS,EAAE,OAAO,YAAY,EAAE,OAAO,QAAQ;AACrD,aAAO,OAAO,cAAc,MAAM;AAAA,IACtC,CAAC;AAAA,EACL;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,MAAgB,2BACZ,oBACA,kBACc;AACd,UAAM,eAAe,MAAM,KAAK,iBAAiB,oBAAoB,gBAAgB;AACrF,UAAM,eAAe,aAAa,IAAI,OAAK,IAAI,EAAE,WAAW,MAAM,EAAE,UAAU,GAAG,EAAE,KAAK,IAAI;AAC5F,UAAM,IAAI;AAAA,MACN,UAAU;AAAA,MACV,mDAAmD,mBAAmB,IAAI,OAAK,IAAI,CAAC,GAAG,EAAE,KAAK,IAAI,CAAC,0BAC3E,gBAAgB,MAAM;AAAA,IAClD;AAAA,EACJ;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAkBA,MAAgB,mBAAmB,QAAsB,YAAyC;AAE9F,UAAM,cAAc,WAAW,OAAO,UAAQ,QAAQ,KAAK,KAAK,EAAE,SAAS,CAAC;AAE5E,QAAI,YAAY,WAAW,GAAG;AAC1B,YAAM,IAAI;AAAA,QACN,UAAU;AAAA,QACV;AAAA,MACJ;AAAA,IACJ;AAGA,UAAM,kBAAkB,YAAY;AAAA,MAAK,UACrC,SAAS,aAAa,CAAC,KAAK,SAAS,GAAG;AAAA,IAC5C;AAEA,QAAI,CAAC,iBAAiB;AAElB,aAAO;AAAA,IACX;AAGA,UAAM,WAAW,KAAK,YAAY,MAAM;AACxC,UAAM,WAAW,MAAM,SAAS,aAAa,KAAK;AAClD,UAAM,YAAY,SAAS,KAAK,SAAS,CAAC;AAI1C,UAAM,kBAAkB,oBAAI,IAAoB;AAChD,UAAM,iBAAiB,oBAAI,IAAoB;AAC/C,UAAM,uBAAuB,oBAAI,IAAoB;AACrD,UAAM,sBAAsB,oBAAI,IAAoB;AAEpD,eAAW,OAAO,WAAW;AACzB,UAAI,IAAI,IAAI;AACR,YAAI,IAAI,iBAAiB;AACrB,0BAAgB,IAAI,IAAI,iBAAiB,IAAI,EAAE;AAC/C,+BAAqB,IAAI,IAAI,gBAAgB,YAAY,GAAG,IAAI,EAAE;AAAA,QACtE;AACA,YAAI,IAAI,SAAS;AACb,yBAAe,IAAI,IAAI,SAAS,IAAI,EAAE;AACtC,8BAAoB,IAAI,IAAI,QAAQ,YAAY,GAAG,IAAI,EAAE;AAAA,QAC7D;AAAA,MACJ;AAAA,IACJ;AAEA,UAAM,cAAwB,CAAC;AAC/B,UAAM,SAAmB,CAAC;AAE1B,eAAW,YAAY,aAAa;AAEhC,UAAI,aAAa,aAAa,SAAS,SAAS,GAAG,GAAG;AAClD,oBAAY,KAAK,QAAQ;AACzB;AAAA,MACJ;AAEA,YAAM,YAAY,SAAS,YAAY;AAGvC,UAAI,KAAK,gBAAgB,IAAI,QAAQ;AAGrC,UAAI,CAAC,IAAI;AACL,aAAK,qBAAqB,IAAI,SAAS;AAAA,MAC3C;AAGA,UAAI,CAAC,IAAI;AACL,aAAK,eAAe,IAAI,QAAQ;AAAA,MACpC;AAGA,UAAI,CAAC,IAAI;AACL,aAAK,oBAAoB,IAAI,SAAS;AAAA,MAC1C;AAEA,UAAI,IAAI;AACJ,oBAAY,KAAK,EAAE;AAAA,MACvB,OAAO;AACH,eAAO,KAAK,QAAQ;AAAA,MACxB;AAAA,IACJ;AAGA,QAAI,OAAO,SAAS,GAAG;AACnB,YAAM,qBAAqB,UACtB,IAAI,SAAO;AACR,YAAI,IAAI,mBAAmB,IAAI,oBAAoB,IAAI,SAAS;AAC5D,iBAAO,IAAI,IAAI,eAAe,QAAQ,IAAI,OAAO,MAAM,IAAI,EAAE;AAAA,QACjE;AACA,eAAO,IAAI,IAAI,OAAO,MAAM,IAAI,EAAE;AAAA,MACtC,CAAC,EACA,KAAK,IAAI;AAEd,YAAM,eAAe,0BAA0B,OAAO,IAAI,OAAK,IAAI,CAAC,GAAG,EAAE,KAAK,IAAI,CAAC,0BAA0B,sBAAsB,MAAM;AAEzI,YAAM,IAAI;AAAA,QACN,UAAU;AAAA,QACV;AAAA,MACJ;AAAA,IACJ;AAEA,WAAO;AAAA,EACX;AAEJ;;;AGjWA,SAAS,aAAa,gBAA2C,UAA8C;AAC7G,MAAI,CAAC,eAAgB,QAAO;AAE5B,MAAI;AAIF,QAAI,CAAC,YAAY,mBAAmB,KAAK,cAAc,GAAG;AACxD,YAAM,YAAY,eAAe,MAAM,0BAA0B;AACjE,UAAI,WAAW;AACb,cAAM,CAAC,EAAE,MAAM,OAAO,GAAG,IAAI;AAE7B,cAAM,YAAY,IAAI,KAAK,KAAK,IAAI,SAAS,IAAI,GAAG,SAAS,KAAK,IAAI,GAAG,SAAS,GAAG,GAAG,IAAI,GAAG,CAAC,CAAC;AACjG,YAAI,CAAC,MAAM,UAAU,QAAQ,CAAC,GAAG;AAC/B,iBAAO,IAAI,KAAK,eAAe,SAAS;AAAA,YACtC,SAAS;AAAA,YACT,UAAU;AAAA,UACZ,CAAC,EAAE,OAAO,SAAS;AAAA,QACrB;AAAA,MACF;AAAA,IACF;AAEA,UAAM,OAAO,IAAI,KAAK,cAAc;AACpC,QAAI,MAAM,KAAK,QAAQ,CAAC,EAAG,QAAO;AAElC,WAAO,IAAI,KAAK,eAAe,SAAS;AAAA,MACtC,SAAS;AAAA,MACT,UAAU,YAAY;AAAA,IACxB,CAAC,EAAE,OAAO,IAAI;AAAA,EAChB,QAAQ;AACN,WAAO;AAAA,EACT;AACF;AASO,SAAS,+BACd,OACA,YACAQ,YACiB;AACjB,SAAO;AAAA,IACL,IAAI,MAAM,MAAM;AAAA,IAChB,SAAS,MAAM,WAAW;AAAA,IAC1B,aAAa,MAAM,eAAe;AAAA,IAClC,UAAU,MAAM,YAAY;AAAA,IAC5B,OAAO;AAAA,MACL,UAAU,MAAM,OAAO,YAAY;AAAA,MACnC,MAAM,MAAM,OAAO,QAAQ;AAAA,MAC3B,UAAU,MAAM,OAAO,YAAY;AAAA,IACrC;AAAA,IACA,KAAK;AAAA,MACH,UAAU,MAAM,KAAK,YAAY;AAAA,MACjC,MAAM,MAAM,KAAK,QAAQ;AAAA,MACzB,UAAU,MAAM,KAAK,YAAY;AAAA,IACnC;AAAA,IACA,gBAAgB;AAAA,MACd,MAAM,OAAO,YAAY,MAAM,OAAO;AAAA,MACtC,MAAM,OAAO;AAAA,IACf;AAAA,IACA,cAAc;AAAA,MACZ,MAAM,KAAK,YAAY,MAAM,KAAK;AAAA,MAClC,MAAM,KAAK;AAAA,IACb;AAAA,IACA,QAAQ,MAAM,UAAU;AAAA,IACxB,UAAU,MAAM,YAAY;AAAA,IAC5B,SAAS,MAAM,WAAW;AAAA,IAC1B,SAAS,MAAM,WAAW;AAAA,IAC1B,SAAS,MAAM,WAAW;AAAA,IAC1B,SAAS,MAAM,UAAU;AAAA,MACvB,OAAO,MAAM,QAAQ,SAAS;AAAA,MAC9B,aAAa,MAAM,QAAQ,eAAe;AAAA,MAC1C,MAAM,MAAM,QAAQ,QAAQ;AAAA,IAC9B,IAAI;AAAA,IACJ,WAAW,MAAM,YAAY;AAAA,MAC3B,OAAO,MAAM,UAAU,SAAS;AAAA,MAChC,aAAa,MAAM,UAAU,eAAe;AAAA,MAC5C,MAAM,MAAM,UAAU,QAAQ;AAAA,IAChC,IAAI;AAAA,IACJ,WAAW,MAAM,WAAW,IAAI,QAAM;AAAA,MACpC,OAAO,EAAE,SAAS;AAAA,MAClB,aAAa,EAAE,eAAe;AAAA,MAC9B,gBAAgB,EAAE;AAAA,MAClB,UAAU,EAAE,YAAY;AAAA,MACxB,WAAW,EAAE,aAAa;AAAA,MAC1B,MAAM,EAAE,QAAQ;AAAA,MAChB,UAAU,EAAE,YAAY;AAAA,MACxB,SAAS,EAAE,WAAW;AAAA,MACtB,kBAAkB,EAAE,oBAAoB;AAAA,IAC1C,EAAE;AAAA,IACF,YAAY,MAAM,cAAc;AAAA,IAChC,kBAAkB,MAAM,oBAAoB;AAAA,IAC5C,mBAAmB,MAAM,oBAAoB;AAAA,MAC3C,UAAU,MAAM,kBAAkB,YAAY;AAAA,MAC9C,MAAM,MAAM,kBAAkB,QAAQ;AAAA,MACtC,UAAU,MAAM,kBAAkB,YAAY;AAAA,IAChD,IAAI;AAAA,IACJ,cAAc,MAAM;AAAA,IACpB,YAAY,MAAM;AAAA,IAClB,SAAS,MAAM,WAAW;AAAA,IAC1B,UAAU,MAAM,YAAY;AAAA,IAC5B,WAAW,MAAM,YAAY;AAAA,MAC3B,YAAY,MAAM,UAAU,cAAc;AAAA,MAC1C,WAAW,MAAM,UAAU,WAAW,IAAI,QAAM;AAAA,QAC9C,QAAS,EAAE,UAAkB;AAAA,QAC7B,SAAS,EAAE,WAAW;AAAA,MACxB,EAAE;AAAA,IACJ,IAAI;AAAA,IACJ,QAAQ,MAAM,SAAS;AAAA,MACrB,KAAK,MAAM,OAAO,OAAO;AAAA,MACzB,OAAO,MAAM,OAAO,SAAS;AAAA,IAC/B,IAAI;AAAA,IACJ,aAAa,MAAM,aAAa,IAAI,QAAM;AAAA,MACxC,SAAS,EAAE,WAAW;AAAA,MACtB,OAAO,EAAE,SAAS;AAAA,MAClB,UAAU,EAAE,YAAY;AAAA,MACxB,UAAU,EAAE,YAAY;AAAA,MACxB,QAAQ,EAAE,UAAU;AAAA,IACtB,EAAE;AAAA,IACF,WAAW,MAAM;AAAA,IACjB,qBAAqB,MAAM;AAAA,IAC3B,uBAAuB,MAAM;AAAA,IAC7B,2BAA2B,MAAM;AAAA,IACjC,gBAAgB,MAAM;AAAA,IACtB,oBAAoB,MAAM;AAAA,IAC1B,aAAa,MAAM,eAAe;AAAA,IAClC,kBAAkB,MAAM,oBAAoB;AAAA,IAC5C,uBAAuB,MAAM,yBAAyB;AAAA,IACtD,iBAAiB,MAAM,mBAAmB;AAAA,IAC1C,yBAAyB,MAAM,2BAA2B;AAAA,IAC1D,aAAa,MAAM,eAAe;AAAA,IAClC,QAAQ,MAAM,UAAU;AAAA,IACxB;AAAA,IACA,WAAWA;AAAA,EACb;AACF;;;ACvkBO,SAAS,yBAA4B,MAAyB;AACnE,SAAO;AAAA,IACL,SAAS,CAAC;AAAA,MACR,MAAM;AAAA,MACN,MAAM,KAAK,UAAU,IAAI;AAAA,IAC3B,CAAC;AAAA,EACH;AACF;AAKO,SAAS,6BACd,WAC8D;AAC9D,QAAM,SAAuE,CAAC;AAE9E,MAAI,UAAU,WAAW,SAAS,GAAG;AACnC,WAAO,aAAa,UAAU,WAAW,IAAI,SAAO;AAElD,UAAI,QAAQ;AACZ,UAAI,MAAM;AACV,UAAI,IAAI,WAAW;AACjB,gBAAQ,IAAI,UAAU,OAAO,YAAY,IAAI,UAAU,OAAO,QAAQ;AACtE,cAAM,IAAI,UAAU,KAAK,YAAY,IAAI,UAAU,KAAK,QAAQ;AAAA,MAClE;AAEA,aAAO;AAAA,QACL,OAAO;AAAA,UACL,IAAI,IAAI,MAAM,MAAM;AAAA,UACpB,OAAO,IAAI,MAAM;AAAA,UACjB;AAAA,UACA;AAAA,UACA,KAAK,IAAI,MAAM;AAAA,UACf,YAAY,IAAI,MAAM;AAAA,QACxB;AAAA,QACA,YAAY,IAAI,cAAc;AAAA,QAC9B,YAAY,IAAI;AAAA,MAClB;AAAA,IACF,CAAC;AAAA,EACH;AAEA,MAAI,UAAU,UAAU,SAAS,GAAG;AAClC,WAAO,YAAY,UAAU,UAAU,IAAI,cAAY;AAErD,UAAI,QAAQ,SAAS,MAAM,SAAS;AACpC,UAAI,MAAM,SAAS,MAAM,OAAO;AAChC,UAAI,CAAC,SAAS,SAAS,WAAW;AAChC,gBAAQ,SAAS,UAAU,OAAO,YAAY,SAAS,UAAU,OAAO,QAAQ;AAAA,MAClF;AACA,UAAI,CAAC,OAAO,SAAS,WAAW;AAC9B,cAAM,SAAS,UAAU,KAAK,YAAY,SAAS,UAAU,KAAK,QAAQ;AAAA,MAC5E;AAEA,aAAO;AAAA,QACL,OAAO;AAAA,UACL,IAAI,SAAS,MAAM,MAAM;AAAA,UACzB,OAAO,SAAS,MAAM;AAAA,UACtB;AAAA,UACA;AAAA,UACA,KAAK,SAAS,MAAM;AAAA,UACpB,YAAY,SAAS;AAAA,QACvB;AAAA,QACA,UAAU,SAAS;AAAA,QACnB,SAAS,SAAS,UAAU;AAAA,UAC1B,UAAU,SAAS,QAAQ;AAAA,UAC3B,YAAY,GAAG,SAAS,QAAQ,UAAU;AAAA,QAC5C,IAAI;AAAA,MACN;AAAA,IACF,CAAC;AAAA,EACH;AAEA,SAAO;AACT;AA+HO,SAAS,oBAAoB,WAAuD;AACzF,MAAI,CAAC,aAAa,CAAC,UAAU,cAAc;AACzC,WAAO;AAAA,EACT;AAEA,QAAM,WAAqB,CAAC;AAE5B,MAAI,UAAU,WAAW,SAAS,GAAG;AACnC,aAAS,KAAK,SAAS,UAAU,WAAW,MAAM,yBAAyB;AAAA,EAC7E;AAEA,MAAI,UAAU,UAAU,SAAS,GAAG;AAClC,aAAS,KAAK,SAAS,UAAU,UAAU,MAAM,yBAAyB;AAAA,EAC5E;AAEA,SAAO,SAAS,SAAS,IAAI,WAAW;AAC1C;;;ACnOO,IAAM,uBAAN,cAAmC,gBAAgB;AAAA,EACtD,MAAM,QAAQ,MAAW,UAA8D;AAEnF,UAAM,mBAAmB,KAAK,sBAAsB,KAAK,SAAS,QAAQ;AAG1E,UAAM,sBAAsB,MAAM,QAAQ;AAAA,MACtC,MAAM,KAAK,iBAAiB,QAAQ,CAAC,EAAE,IAAI,OAAO,CAACC,YAAW,MAAM,MAAM;AACtE,cAAM,YAAY,MAAM,KAAK,cAAc,MAAM;AACjD,eAAO,UAAU,IAAI,UAAQ,EAAE,GAAG,KAAK,YAAYA,WAAU,EAAE;AAAA,MACnE,CAAC;AAAA,IACL;AAEA,UAAM,eAAe,oBAAoB,KAAK;AAG9C,QAAI,iBAAiB,OAAO,GAAG;AAC3B,YAAM,mBAAmB,MAAM,KAAK,iBAAiB,oBAAoB,gBAAgB;AAEzF,YAAMC,YAAkC;AAAA,QACpC,WAAW,iBAAiB,IAAI,aAAW;AAEvC,gBAAM,eAAe,aAAa;AAAA,YAC9B,SAAO,IAAI,OAAO,QAAQ,cAAe,IAAY,eAAe,QAAQ;AAAA,UAChF;AAEA,iBAAO;AAAA,YACH,GAAG,KAAK,4BAA4B,cAAc,QAAQ,UAAU;AAAA,YACpE,eAAe,QAAQ,SAAS,IAAI,QAAM;AAAA,cACtC,WAAW,EAAE;AAAA,cACb,YAAY,EAAE;AAAA,cACd,SAAS,EAAE;AAAA,YACf,EAAE;AAAA,UACN;AAAA,QACJ,CAAC;AAAA,QACD,YAAY,iBAAiB;AAAA,QAC7B,MAAM,yCAAyC,iBAAiB,IAAI;AAAA,MACxE;AAEA,aAAO,yBAAyBA,SAAQ;AAAA,IAC5C;AAGA,UAAM,WAAkC;AAAA,MACpC,WAAW,aAAa,IAAI,SAAO,KAAK,4BAA4B,GAAG,CAAC;AAAA,MACxE,YAAY,aAAa;AAAA,IAC7B;AAEA,WAAO,yBAAyB,QAAQ;AAAA,EAC5C;AAAA,EAEQ,4BAA4B,KAA2C,YAAqB;AAChG,WAAO;AAAA,MACH,IAAI,cAAc,IAAI,MAAM;AAAA,MAC5B,SAAS,IAAI,WAAW;AAAA,MACxB,aAAa,IAAI,eAAe;AAAA,MAChC,UAAU,IAAI,YAAY;AAAA,MAC1B,UAAU,IAAI,YAAY;AAAA,MAC1B,iBAAiB,IAAI,mBAAmB;AAAA,MACxC,SAAS,IAAI,WAAW;AAAA,MACxB,iBAAiB,IAAI,mBAAmB;AAAA,MACxC,iBAAiB,IAAI,mBAAmB;AAAA,MACxC,QAAQ,IAAI,UAAU;AAAA,MACtB,UAAU,IAAI,YAAY;AAAA,MAC1B,YAAY,IAAI,cAAc;AAAA,MAC9B,kBAAkB,IAAI,kBAAkB,IAAI,QAAM;AAAA,QAC9C,QAAS,EAAE,UAAgC;AAAA,QAC3C,SAAS,EAAE,WAAW;AAAA,MAC1B,EAAE;AAAA,MACF,sBAAsB,IAAI,uBAAuB;AAAA,QAC7C,eAAe,IAAI,qBAAqB,eAAe,IAAI,QAAM;AAAA,UAC7D,MAAM,EAAE,QAAQ;AAAA,UAChB,QAAQ,EAAE,UAAU;AAAA,QACxB,EAAE;AAAA,MACN,IAAI;AAAA,MACJ,SAAS,IAAI,WAAW;AAAA,MACxB,SAAS,IAAI,WAAW;AAAA,MACxB,sBAAsB,IAAI,uBAAuB;AAAA,QAC7C,gCAAgC,IAAI,qBAAqB,kCAAkC;AAAA,MAC/F,IAAI;AAAA,IACR;AAAA,EACJ;AAAA,EAEA,MAAc,cAAc,QAAuE;AAC/F,QAAI;AACA,YAAM,WAAW,KAAK,YAAY,MAAM;AACxC,YAAM,WAAW,MAAM,SAAS,aAAa,KAAK;AAClD,aAAO,SAAS,KAAK,SAAS,CAAC;AAAA,IACnC,SAAS,OAAO;AACZ,YAAM,KAAK,qBAAqB,KAAK;AAAA,IACzC;AAAA,EACJ;AACJ;;;AC5EO,IAAM,oBAAN,cAAgC,MAAM;AAAA,EAC3C,YACE,SACO,QACA,UAAmB,OAC1B;AACA,UAAM,OAAO;AAHN;AACA;AAGP,SAAK,OAAO;AAAA,EACd;AACF;AAEO,IAAM,sBAAN,MAA0B;AAAA;AAAA,EAM/B,YAAoB,MAAoB;AAApB;AAClB,SAAK,WAAW,oBAAoB,KAAK,IAAI;AAAA,EAC/C;AAAA,EAPiB,gBAAgB;AAAA,EAChB;AAAA,EACA,aAAa;AAAA,EACb,YAAY;AAAA,EAM7B,MAAM,aAAa,UAAoD;AACrE,QAAI,SAAS,WAAW,GAAG;AACzB,aAAO,CAAC;AAAA,IACV;AAEA,QAAI,SAAS,SAAS,IAAI;AACxB,YAAM,IAAI,MAAM,oDAAoD;AAAA,IACtE;AAEA,WAAO,KAAK,sBAAsB,UAAU,CAAC;AAAA,EAC/C;AAAA,EAEA,MAAc,sBAAsB,UAA0B,SAA2C;AACvG,QAAI;AACF,YAAM,YAAY,KAAK,gBAAgB,QAAQ;AAC/C,YAAM,QAAQ,MAAM,KAAK,KAAK,eAAe;AAE7C,YAAM,WAAW,MAAM,MAAM,KAAK,eAAe;AAAA,QAC/C,QAAQ;AAAA,QACR,SAAS;AAAA,UACP,iBAAiB,UAAU,MAAM,KAAK;AAAA,UACtC,gBAAgB,6BAA6B,KAAK,QAAQ;AAAA,QAC5D;AAAA,QACA,MAAM;AAAA,MACR,CAAC;AAED,YAAM,eAAe,MAAM,SAAS,KAAK;AAGzC,UAAI,SAAS,WAAW,OAAO,UAAU,KAAK,YAAY;AACxD,cAAM,aAAa,SAAS,QAAQ,IAAI,aAAa;AACrD,cAAM,QAAQ,aAAa,SAAS,UAAU,IAAI,MAAO,KAAK,YAAY,KAAK,IAAI,GAAG,OAAO;AAE7F,gBAAQ,OAAO,MAAM,gCAAgC,KAAK,eAAe,UAAU,CAAC,IAAI,KAAK,UAAU;AAAA,CAAK;AAC5G,cAAM,KAAK,MAAM,KAAK;AACtB,eAAO,KAAK,sBAAsB,UAAU,UAAU,CAAC;AAAA,MACzD;AAEA,UAAI,CAAC,SAAS,IAAI;AAChB,cAAM,IAAI;AAAA,UACR,yBAAyB,SAAS,MAAM,IAAI,SAAS,UAAU;AAAA,UAC/D,CAAC;AAAA,YACC,YAAY,SAAS;AAAA,YACrB,SAAS,QAAQ,SAAS,MAAM,KAAK,SAAS,UAAU;AAAA,YACxD,SAAS;AAAA,UACX,CAAC;AAAA,QACH;AAAA,MACF;AAEA,aAAO,KAAK,mBAAmB,YAAY;AAAA,IAC7C,SAAS,OAAO;AACd,UAAI,iBAAiB,mBAAmB;AACtC,cAAM;AAAA,MACR;AAGA,UAAI,UAAU,KAAK,cAAc,KAAK,iBAAiB,KAAK,GAAG;AAC7D,cAAM,QAAQ,KAAK,YAAY,KAAK,IAAI,GAAG,OAAO;AAClD,gBAAQ,OAAO,MAAM,iCAAiC,KAAK,eAAe,UAAU,CAAC,IAAI,KAAK,UAAU,MAAM,iBAAiB,QAAQ,MAAM,UAAU,eAAe;AAAA,CAAI;AAC1K,cAAM,KAAK,MAAM,KAAK;AACtB,eAAO,KAAK,sBAAsB,UAAU,UAAU,CAAC;AAAA,MACzD;AAGA,YAAM,IAAI;AAAA,QACR,oCAAoC,iBAAiB,QAAQ,MAAM,UAAU,eAAe;AAAA,QAC5F,CAAC;AAAA,UACC,YAAY;AAAA,UACZ,SAAS,iBAAiB,QAAQ,MAAM,UAAU;AAAA,UAClD,SAAS;AAAA,QACX,CAAC;AAAA,MACH;AAAA,IACF;AAAA,EACF;AAAA,EAEQ,iBAAiB,OAAqB;AAC5C,QAAI,iBAAiB,OAAO;AAC1B,YAAM,UAAU,MAAM,QAAQ,YAAY;AAC1C,aAAO,QAAQ,SAAS,SAAS,KAC1B,QAAQ,SAAS,SAAS,KAC1B,QAAQ,SAAS,YAAY,KAC7B,QAAQ,SAAS,WAAW;AAAA,IACrC;AACA,WAAO;AAAA,EACT;AAAA,EAEQ,MAAM,IAA2B;AACvC,WAAO,IAAI,QAAQ,CAAAC,aAAW,WAAWA,UAAS,EAAE,CAAC;AAAA,EACvD;AAAA,EAEQ,gBAAgB,UAAkC;AACxD,WAAO,SAAS,IAAI,CAAC,KAAK,UAAU;AAClC,YAAM,QAAQ;AAAA,QACZ,KAAK,KAAK,QAAQ;AAAA,QAClB;AAAA,QACA,oBAAoB,QAAQ,CAAC;AAAA,QAC7B;AAAA,QACA,GAAG,IAAI,MAAM,IAAI,IAAI,IAAI;AAAA,MAC3B;AAEA,UAAI,IAAI,SAAS;AACf,eAAO,QAAQ,IAAI,OAAO,EAAE,QAAQ,CAAC,CAAC,KAAK,KAAK,MAAM;AACpD,gBAAM,KAAK,GAAG,GAAG,KAAK,KAAK,EAAE;AAAA,QAC/B,CAAC;AAAA,MACH;AAEA,UAAI,IAAI,MAAM;AACZ,cAAM,KAAK,gCAAgC;AAC3C,cAAM,KAAK,EAAE;AACb,cAAM,KAAK,KAAK,UAAU,IAAI,IAAI,CAAC;AAAA,MACrC;AAEA,aAAO,MAAM,KAAK,MAAM;AAAA,IAC1B,CAAC,EAAE,KAAK,UAAU,IAAI;AAAA,IAAS,KAAK,QAAQ;AAAA,EAC9C;AAAA,EAEQ,mBAAmB,cAAuC;AAGhE,UAAM,QAAQ,aAAa,MAAM,OAAO;AACxC,QAAI,WAAW;AAGf,aAAS,IAAI,GAAG,IAAI,KAAK,IAAI,IAAI,MAAM,MAAM,GAAG,KAAK;AACnD,YAAM,OAAO,MAAM,CAAC;AACpB,UAAI,KAAK,YAAY,EAAE,SAAS,eAAe,KAAK,KAAK,SAAS,WAAW,GAAG;AAC9E,cAAM,gBAAgB,KAAK,MAAM,wBAAwB;AACzD,YAAI,eAAe;AACjB,qBAAW,cAAc,CAAC;AAC1B;AAAA,QACF;AAAA,MACF;AAAA,IACF;AAGA,QAAI,CAAC,UAAU;AACb,YAAM,gBAAgB,aAAa,MAAM,oBAAoB;AAC7D,UAAI,eAAe;AACjB,mBAAW,cAAc,CAAC;AAAA,MAC5B;AAAA,IACF;AAEA,QAAI,CAAC,UAAU;AACb,YAAM,IAAI,MAAM,2CAA2C;AAAA,IAC7D;AAGA,UAAM,QAAQ,aAAa,MAAM,KAAK,QAAQ,EAAE;AAEhD,UAAM,YAA6B,CAAC;AAGpC,aAAS,IAAI,GAAG,IAAI,MAAM,QAAQ,KAAK;AACrC,YAAM,OAAO,MAAM,CAAC;AAGpB,UAAI,KAAK,KAAK,MAAM,MAAM,KAAK,KAAK,MAAM,QAAQ,KAAK,KAAK,EAAE,WAAW,IAAI,EAAG;AAEhF,YAAM,WAAW,KAAK,kBAAkB,IAAI;AAC5C,UAAI,UAAU;AACZ,kBAAU,KAAK,QAAQ;AAAA,MACzB;AAAA,IACF;AAEA,WAAO;AAAA,EACT;AAAA,EAEQ,kBAAkB,MAAoC;AAE5D,UAAM,QAAQ,KAAK,MAAM,OAAO;AAGhC,QAAI,gBAAgB;AACpB,aAAS,IAAI,GAAG,IAAI,MAAM,QAAQ,KAAK;AACrC,UAAI,MAAM,CAAC,EAAE,WAAW,UAAU,GAAG;AACnC,wBAAgB;AAChB;AAAA,MACF;AAAA,IACF;AAEA,QAAI,kBAAkB,GAAI,QAAO;AAGjC,UAAM,WAAW,MAAM,aAAa;AACpC,UAAM,cAAc,SAAS,MAAM,kBAAkB;AACrD,QAAI,CAAC,YAAa,QAAO;AAEzB,UAAM,aAAa,SAAS,YAAY,CAAC,CAAC;AAG1C,UAAM,UAAkC,CAAC;AACzC,QAAI,iBAAiB,gBAAgB;AAErC,aAAS,IAAI,gBAAgB,GAAG,IAAI,MAAM,QAAQ,KAAK;AACrD,YAAM,OAAO,MAAM,CAAC;AACpB,UAAI,KAAK,KAAK,MAAM,IAAI;AACtB,yBAAiB,IAAI;AACrB;AAAA,MACF;AAEA,YAAM,aAAa,KAAK,QAAQ,GAAG;AACnC,UAAI,aAAa,GAAG;AAClB,cAAM,MAAM,KAAK,UAAU,GAAG,UAAU,EAAE,KAAK;AAC/C,cAAM,QAAQ,KAAK,UAAU,aAAa,CAAC,EAAE,KAAK;AAClD,gBAAQ,GAAG,IAAI;AAAA,MACjB;AAAA,IACF;AAGA,QAAI,OAAY;AAChB,QAAI,iBAAiB,MAAM,QAAQ;AAEjC,YAAM,YAAY,CAAC;AACnB,eAAS,IAAI,gBAAgB,IAAI,MAAM,QAAQ,KAAK;AAClD,kBAAU,KAAK,MAAM,CAAC,CAAC;AAAA,MACzB;AAGA,aAAO,UAAU,SAAS,KAAK,UAAU,UAAU,SAAS,CAAC,EAAE,KAAK,MAAM,IAAI;AAC5E,kBAAU,IAAI;AAAA,MAChB;AAEA,UAAI,UAAU,SAAS,GAAG;AACxB,cAAM,WAAW,UAAU,KAAK,IAAI;AACpC,YAAI,SAAS,KAAK,GAAG;AACnB,cAAI;AACF,mBAAO,KAAK,MAAM,QAAQ;AAAA,UAC5B,QAAQ;AAEN,mBAAO;AAAA,UACT;AAAA,QACF;AAAA,MACF;AAAA,IACF;AAEA,WAAO;AAAA,MACL;AAAA,MACA;AAAA,MACA;AAAA,IACF;AAAA,EACF;AACF;;;ACzQO,IAAM,oBAAN,cAAgC,gBAAgB;AAAA,EACnD,MAAM,QAAQ,MAAsB,UAA8D;AAE9F,UAAM,mBAAmB,KAAK,sBAAsB,KAAK,SAAS,QAAQ;AAC1E,UAAM,kBAAgE,CAAC;AACvE,UAAM,qBAA+B,CAAC;AAGtC,UAAM,qBAAqB,MAAM,QAAQ,KAAK,UAAU,IAClD,KAAK,aACL,CAAC,KAAK,UAAU;AAItB,QAAI;AAEJ,QAAI,iBAAiB,OAAO,GAAG;AAE3B,YAAM,EAAE,UAAU,UAAAC,UAAS,IAAI,MAAM,KAAK,iBAAiB;AAAA,QACvD;AAAA,QACA;AAAA,MACJ;AACA,2BAAqB;AACrB,yBAAmB,KAAK,GAAGA,SAAQ;AAGnC,UAAI,mBAAmB,SAAS,GAAG;AAC/B,cAAM,KAAK,2BAA2B,oBAAoB,gBAAgB;AAAA,MAC9E;AAAA,IACJ,OAAO;AAGH,YAAM,CAACC,UAAS,IAAI,iBAAiB,KAAK;AAC1C,2BAAqB,oBAAI,IAAI,CAAC,CAACA,YAAW,kBAAkB,CAAC,CAAC;AAAA,IAClE;AAGA,UAAM,mBAAmB,MAAM,QAAQ;AAAA,MACnC,MAAM,KAAK,mBAAmB,QAAQ,CAAC,EAAE,IAAI,OAAO,CAACA,YAAW,mBAAmB,MAAM;AACrF,cAAM,SAAS,iBAAiB,IAAIA,UAAS;AAC7C,YAAI;AAGA,gBAAM,cAAc,iBAAiB,SAAS,IACxC,MAAM,KAAK,mBAAmB,QAAQ,mBAAmB,IACzD;AAEN,gBAAM,SAAS,MAAM,KAAK,YAAY,QAAQ,aAAa;AAAA,YACvD,SAAS,KAAK;AAAA,YACd,SAAS,KAAK;AAAA,YACd,UAAU,KAAK;AAAA,YACf,QAAQ,KAAK;AAAA,YACb,yBAAyB,KAAK;AAAA,YAC9B,wBAAwB,KAAK;AAAA,UACjC,CAAC;AAGD,iBAAO;AAAA,YACH,WAAAA;AAAA,YACA;AAAA,YACA,QAAQ,OAAO,IAAI,YAAU,EAAE,GAAG,OAAO,WAAAA,WAAU,EAAE;AAAA,UACzD;AAAA,QACJ,SAAS,OAAO;AAEZ,cAAI,iBAAiB,SAAS,GAAG;AAC7B,kBAAM;AAAA,UACV;AACA,gBAAM,SAAS,iBAAiB,QAAQ,MAAM,UAAU,OAAO,KAAK;AACpE,0BAAgB,KAAK;AAAA,YACjB,WAAAA;AAAA,YACA;AAAA,UACJ,CAAC;AACD,kBAAQ,OAAO,MAAM,+CAA+CA,UAAS,MAAM,MAAM;AAAA,CAAI;AAE7F,iBAAO,EAAE,WAAAA,YAAW,aAAa,CAAC,GAAG,QAAQ,CAAC,EAAE;AAAA,QACpD;AAAA,MACJ,CAAC;AAAA,IACL;AAGA,UAAM,YAAY,iBAAiB,QAAQ,YAAU,OAAO,MAAM;AAClE,UAAM,wBAAwB,CAAC,GAAG,IAAI,IAAI,iBAAiB,QAAQ,YAAU,OAAO,WAAW,CAAC,CAAC;AAGjG,SAAK,sBAAsB,SAAS;AAGpC,UAAM,mBAAsC,UAAU;AAAA,MAAI,WACtD,+BAA+B,OAAO,MAAM,YAAY,MAAM,SAAS;AAAA,IAC3E;AACA,UAAM,WAAqB,CAAC,GAAG,kBAAkB;AAGjD,QAAI,gBAAgB,SAAS,GAAG;AAC5B,iBAAW,WAAW,iBAAiB;AACnC,iBAAS,KAAK,YAAY,QAAQ,SAAS,aAAa,QAAQ,MAAM,EAAE;AAAA,MAC5E;AAAA,IACJ;AAGA,QAAI;AACJ,QAAI,iBAAiB,OAAO,GAAG;AAC3B,YAAM,qBAAqB,iBAAiB,OAAO,gBAAgB;AACnE,UAAI,gBAAgB,SAAS,GAAG;AAC5B,eAAO,uDAA6C,kBAAkB,OAAO,iBAAiB,IAAI,gBAAgB,gBAAgB,MAAM;AAAA,MAC5I,OAAO;AACH,eAAO,8BAA8B,iBAAiB,IAAI;AAAA,MAC9D;AAAA,IACJ;AAEA,UAAM,WAA+B;AAAA,MACjC,QAAQ;AAAA,MACR,YAAY,UAAU;AAAA,MACtB,WAAW,sBAAsB,SAAS,IAAI,wBAAwB;AAAA,MACtE,GAAI,gBAAgB,SAAS,KAAK,EAAE,gBAAgB;AAAA,MACpD,GAAI,SAAS,SAAS,KAAK,EAAE,SAAS;AAAA,MACtC,GAAI,iBAAiB,OAAO,KAAK,EAAE,UAAU,MAAM,KAAK,iBAAiB,KAAK,CAAC,EAAE;AAAA,MACjF,GAAI,QAAQ,EAAE,KAAK;AAAA,IACvB;AAEA,WAAO,yBAAyB,QAAQ;AAAA,EAC5C;AAAA,EAEA,MAAc,YACV,QACA,aACA,SACwB;AACxB,QAAI,YAAY,WAAW,GAAG;AAC1B,aAAO,KAAK,0BAA0B,QAAQ,YAAY,CAAC,GAAG,OAAO;AAAA,IACzE;AAEA,WAAO,KAAK,4BAA4B,QAAQ,aAAa,OAAO;AAAA,EACxE;AAAA,EAEA,MAAc,0BACV,QACA,YACA,SACwB;AACxB,QAAI;AACA,YAAM,WAAW,KAAK,YAAY,MAAM;AAGxC,YAAM,EAAE,SAAS,QAAQ,IAAI,MAAM,KAAK;AAAA,QACpC;AAAA,QAAQ;AAAA,QAAY,QAAQ;AAAA,QAAS,QAAQ;AAAA,QAAS,QAAQ;AAAA,MAClE;AAEA,YAAM,YAAY,mBAAmB,QAAQ,MAAM;AAEnD,YAAM,WAAW,MAAM,SAAS,OAAO,KAAK;AAAA,QACxC;AAAA,QACA;AAAA,QACA;AAAA,QACA,cAAc;AAAA,QACd,SAAS;AAAA,QACT,GAAI,aAAa,EAAE,QAAQ,UAAU;AAAA,QACrC,GAAI,QAAQ,2BAA2B,EAAE,yBAAyB,QAAQ,wBAA+B;AAAA,QACzG,GAAI,QAAQ,0BAA0B,EAAE,wBAAwB,QAAQ,uBAA8B;AAAA,MAC1G,CAAC;AAGD,cAAQ,SAAS,KAAK,SAAS,CAAC,GAAG,IAAI,YAAU;AAAA,QAC7C,GAAG;AAAA,QACH;AAAA,MACJ,EAAE;AAAA,IACN,SAAS,OAAO;AACZ,YAAM,KAAK,qBAAqB,KAAK;AAAA,IACzC;AAAA,EACJ;AAAA,EAEA,MAAc,4BACV,QACA,aACA,SACwB;AACxB,UAAM,eAAe,IAAI,oBAAoB,MAAM;AAEnD,UAAM,WAAW,MAAM,QAAQ,IAAI,YAAY,IAAI,OAAO,gBAAgB;AAAA,MACtE,QAAQ;AAAA,MACR,MAAM,MAAM,KAAK,gBAAgB,QAAQ,YAAY,OAAO;AAAA,IAChE,EAAE,CAAC;AAEH,UAAM,YAAY,MAAM,aAAa,aAAa,QAAQ;AAE1D,UAAM,EAAE,QAAQ,OAAO,IAAI,KAAK,sBAAsB,WAAW,WAAW;AAE5E,QAAI,OAAO,SAAS,GAAG;AACnB,cAAQ,OAAO,MAAM,8BAA8B,OAAO,IAAI,OAAK,GAAG,EAAE,UAAU,KAAK,EAAE,KAAK,EAAE,EAAE,KAAK,IAAI,CAAC;AAAA,CAAI;AAAA,IACpH;AAEA,WAAO,KAAK,sBAAsB,MAAM;AAAA,EAC5C;AAAA,EAEA,MAAc,gBAAgB,QAAsB,YAAoB,SAA+K;AAEnP,UAAM,EAAE,SAAS,QAAQ,IAAI,MAAM,KAAK;AAAA,MACpC;AAAA,MAAQ;AAAA,MAAY,QAAQ;AAAA,MAAS,QAAQ;AAAA,MAAS,QAAQ;AAAA,IAClE;AAEA,UAAM,YAAY,mBAAmB,QAAQ,MAAM;AAEnD,UAAM,SAAS,IAAI,gBAAgB;AAAA,MAC/B,cAAc;AAAA,MACd,SAAS;AAAA,IACb,CAAC;AACD,QAAI,QAAS,QAAO,IAAI,WAAW,OAAO;AAC1C,QAAI,QAAS,QAAO,IAAI,WAAW,OAAO;AAC1C,QAAI,UAAW,QAAO,IAAI,UAAU,SAAS;AAC7C,QAAI,QAAQ,yBAAyB;AACjC,iBAAW,MAAM,QAAQ,wBAAyB,QAAO,OAAO,2BAA2B,EAAE;AAAA,IACjG;AACA,QAAI,QAAQ,wBAAwB;AAChC,iBAAW,MAAM,QAAQ,uBAAwB,QAAO,OAAO,0BAA0B,EAAE;AAAA,IAC/F;AAEA,WAAO,0BAA0B,mBAAmB,UAAU,CAAC,WAAW,OAAO,SAAS,CAAC;AAAA,EAC/F;AAAA,EAEQ,sBACJ,WACA,aACiF;AACjF,UAAM,SAA0B,CAAC;AACjC,UAAM,SAAuD,CAAC;AAE9D,cAAU,QAAQ,CAAC,UAAU,UAAU;AACnC,YAAM,aAAa,YAAY,KAAK;AAEpC,UAAI,SAAS,eAAe,OAAO,SAAS,MAAM,OAAO;AACrD,cAAM,iBAAkC,SAAS,KAAK,MAAM,IAAI,CAAC,WAAgB;AAAA,UAC7E,GAAG;AAAA,UACH;AAAA,QACJ,EAAE;AACF,eAAO,KAAK,GAAG,cAAc;AAAA,MACjC,OAAO;AACH,cAAM,eAAe,SAAS,MAAM,OAAO,WACxB,SAAS,MAAM,WACf,QAAQ,SAAS,UAAU;AAC9C,eAAO,KAAK,EAAE,YAAY,OAAO,aAAa,CAAC;AAAA,MACnD;AAAA,IACJ,CAAC;AAED,WAAO,EAAE,QAAQ,OAAO;AAAA,EAC5B;AACJ;;;ACpPO,IAAM,sBAAN,cAAkC,gBAAgB;AAAA,EACrD,MAAM,QAAQ,MAAW,UAA8D;AACnF,UAAM,YAAY;AAGlB,UAAM,qBAAqB,MAAM,QAAQ,UAAU,UAAU,IACvD,UAAU,aACV,CAAC,UAAU,UAAU;AAG3B,UAAM,mBAAmB,KAAK,sBAAsB,KAAK,SAAS,QAAQ;AAG1E,QAAI;AACJ,UAAM,qBAA+B,CAAC;AAEtC,QAAI,iBAAiB,OAAO,KAAK,mBAAmB,SAAS,GAAG;AAE5D,YAAM,EAAE,UAAU,SAAS,IAAI,MAAM,KAAK,iBAAiB;AAAA,QACvD;AAAA,QACA;AAAA,MACJ;AACA,2BAAqB;AACrB,yBAAmB,KAAK,GAAG,QAAQ;AAGnC,UAAI,mBAAmB,SAAS,GAAG;AAC/B,cAAM,KAAK,2BAA2B,oBAAoB,gBAAgB;AAAA,MAC9E;AAAA,IACJ,OAAO;AAEH,YAAM,EAAE,WAAAC,YAAW,WAAW,IAAI,MAAM,KAAK;AAAA,QACzC,KAAK;AAAA,QACL,mBAAmB,CAAC;AAAA;AAAA,QACpB;AAAA,QACA;AAAA,MACJ;AACA,2BAAqB,oBAAI,IAAI,CAAC,CAACA,YAAW,CAAC,UAAU,CAAC,CAAC,CAAC;AAAA,IAC5D;AAGA,UAAM,YAA6B,CAAC;AACpC,UAAM,qBAA+B,CAAC;AAEtC,UAAM,QAAQ;AAAA,MACV,MAAM,KAAK,mBAAmB,QAAQ,CAAC,EAAE,IAAI,OAAO,CAACA,YAAW,WAAW,MAAM;AAC7E,cAAM,SAAS,iBAAiB,IAAIA,UAAS;AAC7C,mBAAW,cAAc,aAAa;AAClC,cAAI;AACA,kBAAM,SAAS,MAAM,KAAK,aAAa,QAAQ;AAAA,cAC3C,GAAG;AAAA,cACH;AAAA,YACJ,CAAC;AAED,uBAAW,SAAS,QAAQ;AACxB,wBAAU,KAAK;AAAA,gBACX,GAAG;AAAA,gBACH;AAAA,gBACA,WAAAA;AAAA,cACJ,CAAC;AAAA,YACL;AACA,+BAAmB,KAAK,UAAU;AAAA,UACtC,SAAS,OAAO;AAEZ,gBAAI,mBAAmB,OAAO,KAAK,YAAY,SAAS,GAAG;AACvD,oBAAM,UAAU,iBAAiB,QAAQ,MAAM,UAAU,OAAO,KAAK;AACrE,iCAAmB,KAAK,8BAA8B,UAAU,iBAAiBA,UAAS,MAAM,OAAO,EAAE;AAAA,YAC7G,OAAO;AACH,oBAAM;AAAA,YACV;AAAA,UACJ;AAAA,QACJ;AAAA,MACJ,CAAC;AAAA,IACL;AAGA,SAAK,sBAAsB,SAAS;AAGpC,UAAM,mBAAsC,UAAU;AAAA,MAAI,WACtD,+BAA+B,OAAO,MAAM,YAAY,MAAM,SAAS;AAAA,IAC3E;AAEA,UAAM,WAAiC;AAAA,MACnC,QAAQ;AAAA,MACR,YAAY,UAAU;AAAA,MACtB,OAAO,UAAU;AAAA;AAAA,MAEjB,GAAI,mBAAmB,WAAW,KAAK,EAAE,YAAY,mBAAmB,CAAC,EAAE;AAAA,MAC3E,GAAI,mBAAmB,SAAS,KAAK,EAAE,WAAW,mBAAmB;AAAA,MACrE,GAAI,iBAAiB,OAAO,KAAK,EAAE,UAAU,MAAM,KAAK,iBAAiB,KAAK,CAAC,EAAE;AAAA,MACjF,GAAI,mBAAmB,SAAS,KAAK,EAAE,UAAU,mBAAmB;AAAA,IACxE;AAEA,QAAI,UAAU,WAAW,UAAU,SAAS;AAExC,YAAM,iBAAiB,mBAAmB,KAAK,EAAE,KAAK,EAAE;AACxD,YAAM,kBAAkB,mBAAmB,IAAI,cAAc,IAAI,CAAC,KAAK;AACvE,YAAM,SAAS,iBAAiB,IAAI,cAAc;AAClD,YAAM,EAAE,SAAS,QAAQ,IAAI,MAAM,KAAK;AAAA,QACpC;AAAA,QAAQ;AAAA,QAAiB,UAAU;AAAA,QAAS,UAAU;AAAA,QAAS,UAAU;AAAA,MAC7E;AACA,eAAS,YAAY;AAAA,QACjB,OAAO,WAAW;AAAA,QAClB,KAAK,WAAW;AAAA,MACpB;AAAA,IACJ;AAEA,WAAO,yBAAyB,QAAQ;AAAA,EAC5C;AAAA,EAEA,MAAc,aACV,QACA,MACmC;AACnC,QAAI;AACA,YAAM,WAAW,KAAK,YAAY,MAAM;AAGxC,YAAM,EAAE,SAAS,QAAQ,IAAI,MAAM,KAAK;AAAA,QACpC;AAAA,QAAQ,KAAK;AAAA,QAAY,KAAK;AAAA,QAAS,KAAK;AAAA,QAAS,KAAK;AAAA,MAC9D;AAEA,YAAM,YAAY,mBAAmB,KAAK,MAAM;AAEhD,YAAM,WAAW,MAAM,SAAS,OAAO,KAAK;AAAA,QACxC,YAAY,KAAK;AAAA,QACjB,GAAG,KAAK;AAAA,QACR;AAAA,QACA;AAAA,QACA,cAAc;AAAA,QACd,SAAS;AAAA,QACT,GAAI,aAAa,EAAE,QAAQ,UAAU;AAAA,QACrC,GAAI,KAAK,2BAA2B,EAAE,yBAAyB,KAAK,wBAA+B;AAAA,QACnG,GAAI,KAAK,0BAA0B,EAAE,wBAAwB,KAAK,uBAA8B;AAAA,MACpG,CAAC;AACD,aAAO,SAAS,KAAK,SAAS,CAAC;AAAA,IACnC,SAAS,OAAO;AACZ,YAAM,KAAK,qBAAqB,KAAK;AAAA,IACzC;AAAA,EACJ;AAEJ;;;ACpJO,IAAM,kBAAN,cAA8B,gBAAgB;AAAA,EACjD,MAAM,QAAQ,MAAoB,UAA8D;AAC5F,UAAM,YAAY;AAIlB,UAAM,EAAE,QAAQ,cAAc,WAAW,mBAAmB,YAAY,mBAAmB,IAAI,MAAM,KAAK;AAAA,MACtG,KAAK;AAAA,MACL,UAAU;AAAA,MACV;AAAA,MACA;AAAA,IACJ;AAEA,QAAI;AAEA,YAAM,2BAA2B,EAAE,GAAG,WAAW,YAAY,mBAAmB;AAChF,YAAM,QAAQ,MAAM,KAAK,SAAS,cAAc,wBAAwB;AAExE,UAAI,CAAC,OAAO;AACR,cAAM,IAAI,MAAM,kBAAkB,UAAU,OAAO,4BAA4B,kBAAkB,IAAI;AAAA,MACzG;AAEA,YAAM,WAA6B;AAAA,QAC/B,OAAO,+BAA+B,OAAO,oBAAoB,iBAAiB;AAAA,MACtF;AAEA,aAAO,yBAAyB,QAAQ;AAAA,IAC5C,SAAS,OAAO;AACZ,YAAM,KAAK,qBAAqB,KAAK;AAAA,IACzC;AAAA,EACJ;AAAA,EAEA,MAAc,SACV,QACA,MACwC;AACxC,UAAM,WAAW,KAAK,YAAY,MAAM;AAExC,UAAM,YAAY,0BAA0B,KAAK,MAAM;AAEvD,QAAI;AACA,YAAM,WAAW,MAAM,SAAS,OAAO,IAAI;AAAA,QACvC,YAAY,KAAK;AAAA,QACjB,SAAS,KAAK;AAAA,QACd,GAAI,aAAa,EAAE,QAAQ,UAAU;AAAA,MACzC,CAAC;AAED,aAAO,SAAS;AAAA,IACpB,SAAS,OAAY;AAEjB,UAAI,OAAO,SAAS,OAAO,OAAO,UAAU,WAAW,KAAK;AACxD,eAAO;AAAA,MACX;AACA,YAAM;AAAA,IACV;AAAA,EACJ;AACJ;;;AChEO,IAAM,oBAAN,cAAgC,gBAAgB;AAAA,EACnD,MAAM,QAAQ,MAAW,UAA8D;AAEnF,UAAM,eAAe,KAAK,2BAA2B,KAAK,SAAS,QAAQ;AAE3E,UAAM,SAAS,MAAM,KAAK,WAAW,YAAY;AAEjD,UAAM,WAA+B;AAAA,MACjC,OAAO,CAAC;AAAA,MACR,UAAU,CAAC;AAAA,IACf;AAGA,QAAI,OAAO,OAAO;AACd,iBAAW,CAAC,IAAI,KAAK,KAAK,OAAO,QAAQ,OAAO,KAAK,GAAG;AACpD,iBAAS,MAAM,EAAE,IAAI;AAAA,UACjB,YAAY,MAAM,cAAc;AAAA,UAChC,YAAY,MAAM,cAAc;AAAA,QACpC;AAAA,MACJ;AAAA,IACJ;AAGA,QAAI,OAAO,UAAU;AACjB,iBAAW,CAAC,IAAI,KAAK,KAAK,OAAO,QAAQ,OAAO,QAAQ,GAAG;AACvD,iBAAS,SAAS,EAAE,IAAI;AAAA,UACpB,YAAY,MAAM,cAAc;AAAA,UAChC,YAAY,MAAM,cAAc;AAAA,QACpC;AAAA,MACJ;AAAA,IACJ;AAEA,WAAO,yBAAyB,QAAQ;AAAA,EAC5C;AAAA,EAEA,MAAc,WAAW,QAA0D;AAC/E,QAAI;AACA,YAAM,WAAW,KAAK,YAAY,MAAM;AACxC,YAAM,WAAW,MAAM,SAAS,OAAO,IAAI;AAC3C,UAAI,CAAC,SAAS,KAAM,OAAM,IAAI,MAAM,2BAA2B;AAC/D,aAAO,SAAS;AAAA,IACpB,SAAS,OAAO;AACZ,YAAM,KAAK,qBAAqB,KAAK;AAAA,IACzC;AAAA,EACJ;AAAA;AAAA;AAAA;AAAA,EAKQ,gBAAgB,QAA2C;AAC/D,UAAM,cAAc,OAAO,SAAS,CAAC;AACrC,WAAO,OAAO,QAAQ,WAAW,EAC5B,IAAI,CAAC,CAAC,IAAI,SAAS,MAAM,aAAa,EAAE,MAAM,UAAU,UAAU,mBAAmB,UAAU,UAAU,eAAe,EACxH,KAAK,IAAI;AAAA,EAClB;AACJ;;;ACnCO,SAAS,eAAe,SAA0B;AAEvD,MAAI,QAAQ,SAAS,KAAK,QAAQ,SAAS,MAAM;AAC/C,WAAO;AAAA,EACT;AAKA,QAAM,eAAe;AACrB,SAAO,aAAa,KAAK,OAAO;AAClC;AAOO,SAAS,gBAAgB,SAAuB;AACrD,MAAI,CAAC,eAAe,OAAO,GAAG;AAC5B,UAAM,SAAmB,CAAC;AAE1B,QAAI,QAAQ,SAAS,GAAG;AACtB,aAAO,KAAK,oCAAoC;AAAA,IAClD;AAEA,QAAI,QAAQ,SAAS,MAAM;AACzB,aAAO,KAAK,iCAAiC;AAAA,IAC/C;AAEA,QAAI,CAAC,cAAc,KAAK,OAAO,GAAG;AAChC,aAAO,KAAK,4EAA4E;AAAA,IAC1F;AAEA,UAAM,IAAI,MAAM,qBAAqB,OAAO,KAAK,IAAI,CAAC,EAAE;AAAA,EAC1D;AACF;;;AC9DA,SAAS,UAAAC,eAA2B;;;ACE7B,IAAM,yBAAN,MAA6B;AAAA,EACjB,+BAA+B;AAAA;AAAA;AAAA;AAAA;AAAA,EAMhD,gBAAgB,QAAkC,QAA0C;AAE1F,UAAM,iBAAiB,KAAK,cAAc,MAAM;AAChD,UAAM,iBAAiB,KAAK,cAAc,MAAM;AAEhD,QAAI,mBAAmB,gBAAgB;AAErC,aAAO;AAAA,IACT;AAEA,UAAM,aAAa,KAAK,YAAY,OAAO,SAAS,OAAO,OAAO;AAClE,UAAM,cAAc,KAAK,cAAc,QAAQ,MAAM;AACrD,UAAM,UAAU,KAAK,gBAAgB,QAAQ,MAAM;AAGnD,QAAI,WAAW,SAAS,aAAa;AACnC,aAAO;AAAA,IACT;AAEA,QAAI,WAAW,WAAW,aAAa;AACrC,aAAO;AAAA,IACT;AAEA,QAAI,WAAW,SAAS,SAAS;AAC/B,aAAO;AAAA,IACT;AAEA,QAAI,WAAW,SAAS,CAAC,SAAS;AAChC,aAAO;AAAA,IACT;AAEA,QAAI,WAAW,SAAS;AACtB,aAAO;AAAA,IACT;AAEA,WAAO;AAAA,EACT;AAAA;AAAA;AAAA;AAAA,EAKQ,cAAc,OAA0C;AAC9D,WAAO,CAAC,MAAM,OAAO,YAAY,CAAC,CAAC,MAAM,OAAO;AAAA,EAClD;AAAA;AAAA;AAAA;AAAA;AAAA,EAMQ,YAAY,QAAwB,QAA8D;AACxG,QAAI,CAAC,UAAU,CAAC,QAAQ;AACtB,aAAO,EAAE,OAAO,OAAO,SAAS,MAAM;AAAA,IACxC;AAEA,UAAM,KAAK,OAAO,YAAY,EAAE,KAAK;AACrC,UAAM,KAAK,OAAO,YAAY,EAAE,KAAK;AAGrC,QAAI,OAAO,IAAI;AACb,aAAO,EAAE,OAAO,MAAM,SAAS,KAAK;AAAA,IACtC;AAGA,QAAI,GAAG,SAAS,EAAE,KAAK,GAAG,SAAS,EAAE,GAAG;AACtC,aAAO,EAAE,OAAO,OAAO,SAAS,KAAK;AAAA,IACvC;AAGA,UAAM,SAAS,GAAG,MAAM,KAAK,EAAE,OAAO,OAAK,EAAE,SAAS,CAAC;AACvD,UAAM,SAAS,GAAG,MAAM,KAAK,EAAE,OAAO,OAAK,EAAE,SAAS,CAAC;AAEvD,QAAI,OAAO,SAAS,KAAK,OAAO,SAAS,GAAG;AAC1C,YAAM,cAAc,OAAO,OAAO,OAAK,OAAO,SAAS,CAAC,CAAC;AACzD,YAAM,aAAa,YAAY,SAAS,KAAK,IAAI,OAAO,QAAQ,OAAO,MAAM;AAE7E,aAAO,EAAE,OAAO,OAAO,SAAS,cAAc,IAAI;AAAA,IACpD;AAEA,WAAO,EAAE,OAAO,OAAO,SAAS,MAAM;AAAA,EACxC;AAAA;AAAA;AAAA;AAAA,EAKQ,gBAAgB,QAAkC,QAA2C;AACnG,UAAM,QAAQ,KAAK,aAAa,MAAM;AACtC,UAAM,QAAQ,KAAK,aAAa,MAAM;AAEtC,QAAI,CAAC,SAAS,CAAC,MAAO,QAAO;AAG7B,UAAM,QAAQ,IAAI,KAAK,MAAM,KAAK;AAClC,UAAM,QAAQ,IAAI,KAAK,MAAM,KAAK;AAElC,WAAO,MAAM,YAAY,MAAM,MAAM,YAAY,KAC1C,MAAM,SAAS,MAAM,MAAM,SAAS,KACpC,MAAM,QAAQ,MAAM,MAAM,QAAQ;AAAA,EAC3C;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAYQ,aAAa,OAAoE;AACvF,UAAM,YAAY,MAAM,OAAO,YAAY,MAAM,OAAO;AACxD,UAAM,UAAU,MAAM,KAAK,YAAY,MAAM,KAAK;AAElD,QAAI,CAAC,aAAa,CAAC,QAAS,QAAO;AAInC,WAAO;AAAA,MACL,OAAO,IAAI,KAAK,SAAS;AAAA,MACzB,KAAK,IAAI,KAAK,OAAO;AAAA,IACvB;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,cAAc,QAAkC,QAA2C;AACzF,UAAM,QAAQ,KAAK,aAAa,MAAM;AACtC,UAAM,QAAQ,KAAK,aAAa,MAAM;AAEtC,QAAI,CAAC,SAAS,CAAC,MAAO,QAAO;AAE7B,WAAO,MAAM,QAAQ,MAAM,OAAO,MAAM,QAAQ,MAAM;AAAA,EACxD;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,yBAAyB,QAAkC,QAA0C;AACnG,UAAM,QAAQ,KAAK,aAAa,MAAM;AACtC,UAAM,QAAQ,KAAK,aAAa,MAAM;AAEtC,QAAI,CAAC,SAAS,CAAC,MAAO,QAAO;AAE7B,UAAM,eAAe,KAAK,IAAI,MAAM,MAAM,QAAQ,GAAG,MAAM,MAAM,QAAQ,CAAC;AAC1E,UAAM,aAAa,KAAK,IAAI,MAAM,IAAI,QAAQ,GAAG,MAAM,IAAI,QAAQ,CAAC;AACpE,WAAO,KAAK,IAAI,GAAG,aAAa,YAAY;AAAA,EAC9C;AAAA;AAAA;AAAA;AAAA,EAKA,YAAY,QAAkC,QAAkC,WAA6B;AAC3G,UAAM,aAAa,KAAK,gBAAgB,QAAQ,MAAM;AACtD,WAAO,eAAe,aAAa,KAAK;AAAA,EAC1C;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,eAAe,QAAkC,QAM/C;AACA,UAAM,aAAa,KAAK,cAAc,QAAQ,MAAM;AAEpD,QAAI,CAAC,YAAY;AACf,aAAO,EAAE,YAAY,MAAM;AAAA,IAC7B;AAEA,UAAM,QAAQ,KAAK,kBAAkB,MAAM;AAC3C,UAAM,QAAQ,KAAK,kBAAkB,MAAM;AAE3C,QAAI,CAAC,SAAS,CAAC,OAAO;AACpB,aAAO,EAAE,YAAY,MAAM;AAAA,IAC7B;AAEA,UAAM,kBAAkB,KAAK,yBAAyB,QAAQ,MAAM;AACpE,UAAM,eAAe,IAAI,KAAK,KAAK,IAAI,MAAM,MAAM,QAAQ,GAAG,MAAM,MAAM,QAAQ,CAAC,CAAC;AACpF,UAAM,aAAa,IAAI,KAAK,KAAK,IAAI,MAAM,IAAI,QAAQ,GAAG,MAAM,IAAI,QAAQ,CAAC,CAAC;AAE9E,UAAM,iBAAiB,MAAM,IAAI,QAAQ,IAAI,MAAM,MAAM,QAAQ;AACjE,UAAM,oBAAoB,KAAK,MAAO,kBAAkB,iBAAkB,GAAG;AAE7E,WAAO;AAAA,MACL,YAAY;AAAA,MACZ,UAAU,KAAK,eAAe,eAAe;AAAA,MAC7C,YAAY;AAAA,MACZ,WAAW,aAAa,YAAY;AAAA,MACpC,SAAS,WAAW,YAAY;AAAA,IAClC;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,kBAAkB,OAAwD;AACxE,UAAM,YAAY,MAAM,OAAO,YAAY,MAAM,OAAO;AACxD,UAAM,UAAU,MAAM,KAAK,YAAY,MAAM,KAAK;AAElD,QAAI,CAAC,aAAa,CAAC,QAAS,QAAO;AAEnC,UAAM,QAAQ,IAAI,KAAK,SAAS;AAChC,UAAM,MAAM,IAAI,KAAK,OAAO;AAC5B,UAAM,WAAW,CAAC,MAAM,OAAO,YAAY,CAAC,CAAC,MAAM,OAAO;AAE1D,WAAO,EAAE,OAAO,KAAK,SAAS;AAAA,EAChC;AAAA;AAAA;AAAA;AAAA;AAAA,EAMQ,eAAe,cAA8B;AACnD,UAAM,UAAU,KAAK,MAAM,gBAAgB,MAAO,GAAG;AACrD,UAAM,QAAQ,KAAK,MAAM,UAAU,EAAE;AACrC,UAAM,OAAO,KAAK,MAAM,QAAQ,EAAE;AAElC,QAAI,OAAO,GAAG;AACZ,YAAM,iBAAiB,QAAQ;AAC/B,aAAO,iBAAiB,IACpB,GAAG,IAAI,OAAO,OAAO,IAAI,MAAM,EAAE,IAAI,cAAc,QAAQ,iBAAiB,IAAI,MAAM,EAAE,KACxF,GAAG,IAAI,OAAO,OAAO,IAAI,MAAM,EAAE;AAAA,IACvC;AAEA,QAAI,QAAQ,GAAG;AACb,YAAM,mBAAmB,UAAU;AACnC,aAAO,mBAAmB,IACtB,GAAG,KAAK,QAAQ,QAAQ,IAAI,MAAM,EAAE,IAAI,gBAAgB,UAAU,mBAAmB,IAAI,MAAM,EAAE,KACjG,GAAG,KAAK,QAAQ,QAAQ,IAAI,MAAM,EAAE;AAAA,IAC1C;AAEA,WAAO,GAAG,OAAO,UAAU,UAAU,IAAI,MAAM,EAAE;AAAA,EACnD;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,kBAAkB,OAAiC,UAAmE;AACpH,UAAM,QAAQ,SAAS,SAAS;AAChC,UAAM,MAAM,SAAS,OAAO;AAE5B,QAAI,CAAC,SAAS,CAAC,IAAK,QAAO;AAE3B,UAAM,YAAsC;AAAA,MAC1C,OAAO,EAAE,UAAU,MAAM;AAAA,MACzB,KAAK,EAAE,UAAU,IAAI;AAAA,IACvB;AAEA,WAAO,KAAK,cAAc,OAAO,SAAS;AAAA,EAC5C;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,sBACE,QACA,aAC4B;AAC5B,WAAO,OAAO,OAAO,WAAS;AAC5B,UAAI,MAAM,OAAO,YAAY,GAAI,QAAO;AACxC,UAAI,MAAM,WAAW,YAAa,QAAO;AACzC,aAAO,KAAK,cAAc,aAAa,KAAK;AAAA,IAC9C,CAAC;AAAA,EACH;AACF;;;ACxRO,IAAM,4BAA4B;AAAA;AAAA;AAAA;AAAA,EAIvC,sBAAsB;AAAA;AAAA;AAAA;AAAA;AAAA,IAKpB,SAAS;AAAA;AAAA;AAAA;AAAA;AAAA,IAMT,UAAU;AAAA,EACZ;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,6BAA6B;AAC/B;;;ACtBO,SAAS,iBAAiB,YAAoB,SAAyB;AAC1E,QAAM,oBAAoB,mBAAmB,UAAU;AACvD,QAAM,iBAAiB,mBAAmB,OAAO;AACjD,SAAO,kDAAkD,cAAc,QAAQ,iBAAiB;AACpG;AAKO,SAAS,YAAY,OAAiC,YAAoC;AAC7F,MAAI,MAAM,UAAU;AAChB,WAAO,MAAM;AAAA,EACjB,WAAW,cAAc,MAAM,IAAI;AAC/B,WAAO,iBAAiB,YAAY,MAAM,EAAE;AAAA,EAChD;AACA,SAAO;AACX;;;AHEO,IAAM,2BAAN,MAA+B;AAAA,EAC5B;AAAA,EAER,cAAc;AACZ,SAAK,oBAAoB,IAAI,uBAAuB;AAAA,EACtD;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,eACJ,cACA,OACA,YACA,UAAoC,CAAC,GACP;AAC9B,UAAM;AAAA,MACJ,kBAAkB;AAAA,MAClB,iBAAiB;AAAA,MACjB,mBAAmB,CAAC,UAAU;AAAA,MAC9B,+BAA+B,0BAA0B;AAAA,MACzD,wBAAwB;AAAA,IAC1B,IAAI;AAEJ,UAAM,SAA8B;AAAA,MAClC,cAAc;AAAA,MACd,WAAW,CAAC;AAAA,MACZ,YAAY,CAAC;AAAA,IACf;AAEA,QAAI,CAAC,MAAM,SAAS,CAAC,MAAM,KAAK;AAC9B,aAAO;AAAA,IACT;AAGA,UAAM,kBAAkB,KAAK,4BAA4B,KAAK;AAG9D,QAAI,UAAU,gBAAgB,OAAO,YAAY,gBAAgB,OAAO;AACxE,QAAI,UAAU,gBAAgB,KAAK,YAAY,gBAAgB,KAAK;AAEpE,QAAI,CAAC,WAAW,CAAC,SAAS;AACxB,aAAO;AAAA,IACT;AAGA,UAAM,WAAW,gBAAgB,OAAO,YAAY,gBAAgB,KAAK;AAMzE,UAAM,kBAAkB,YAAY,WAClC,CAAC,QAAQ,SAAS,GAAG,KACrB,CAAC,QAAQ,SAAS,GAAG,KACrB,CAAC,QAAQ,UAAU,EAAE,EAAE,SAAS,GAAG;AAErC,QAAI,iBAAiB;AACnB,gBAAU,iBAAiB,SAAS,QAAQ;AAC5C,gBAAU,iBAAiB,SAAS,QAAQ;AAAA,IAC9C;AAKA,UAAM,gBAAgB;AACtB,UAAM,gBAAgB;AAGtB,eAAW,mBAAmB,kBAAkB;AAC9C,UAAI;AAEF,cAAM,SAAS,MAAM,KAAK;AAAA,UACxB;AAAA,UACA;AAAA,UACA;AAAA,UACA;AAAA,UACA,YAAY;AAAA,QACd;AAGA,YAAI,iBAAiB;AACnB,gBAAM,aAAa,KAAK;AAAA,YACtB;AAAA,YACA;AAAA,YACA;AAAA,YACA;AAAA,UACF;AACA,iBAAO,WAAW,KAAK,GAAG,UAAU;AAAA,QACtC;AAGA,YAAI,gBAAgB;AAClB,gBAAM,YAAY,KAAK;AAAA,YACrB;AAAA,YACA;AAAA,YACA;AAAA,YACA;AAAA,UACF;AACA,iBAAO,UAAU,KAAK,GAAG,SAAS;AAAA,QACpC;AAAA,MACF,SAAS,OAAO;AAAA,MAGhB;AAAA,IACF;AAEA,WAAO,eAAe,OAAO,UAAU,SAAS,KAAK,OAAO,WAAW,SAAS;AAChF,WAAO;AAAA,EACT;AAAA;AAAA;AAAA;AAAA;AAAA,EAMQ,4BAA4B,OAA2D;AAC7F,UAAM,QAAkC,KAAK,MAAM,KAAK,UAAU,KAAK,CAAC;AACxE,UAAM,WAAW,MAAM,OAAO,YAAY,MAAM,KAAK;AAErD,QAAI,MAAM,OAAO,YAAY,YAAY,CAAC,sBAAsB,MAAM,MAAM,QAAQ,GAAG;AACrF,YAAM,MAAM,WAAW,iBAAiB,MAAM,MAAM,UAAU,QAAQ;AAAA,IACxE;AACA,QAAI,MAAM,KAAK,YAAY,YAAY,CAAC,sBAAsB,MAAM,IAAI,QAAQ,GAAG;AACjF,YAAM,IAAI,WAAW,iBAAiB,MAAM,IAAI,UAAU,QAAQ;AAAA,IACpE;AAEA,WAAO;AAAA,EACT;AAAA;AAAA;AAAA;AAAA,EAKA,MAAc,qBACZ,cACA,YACA,SACA,SACA,UACqC;AAErC,UAAM,WAAWC,QAAO,SAAS,EAAE,SAAS,MAAM,MAAM,aAAa,CAAC;AAGtE,UAAM,aAAkB;AAAA,MACtB;AAAA,MACA;AAAA,MACA;AAAA,MACA,cAAc;AAAA,MACd,SAAS;AAAA,MACT,YAAY;AAAA,IACd;AAMA,QAAI,UAAU;AACZ,iBAAW,WAAW;AAAA,IACxB;AAIA,UAAM,WAAW,MAAM,SAAS,OAAO,KAAK,UAAU;AAEtD,UAAM,SAAS,UAAU,MAAM,SAAS,CAAC;AAEzC,WAAO;AAAA,EACT;AAAA;AAAA;AAAA;AAAA,EAKQ,eACN,UACA,gBACA,YACA,WACyB;AACzB,UAAM,aAAsC,CAAC;AAG7C,eAAW,iBAAiB,gBAAgB;AAE1C,UAAI,cAAc,OAAO,SAAS,GAAI;AAGtC,UAAI,cAAc,WAAW,YAAa;AAE1C,YAAM,aAAa,KAAK,kBAAkB,gBAAgB,UAAU,aAAa;AAGjF,UAAI,cAAc,WAAW;AAC3B,mBAAW,KAAK;AAAA,UACd,OAAO;AAAA,YACL,IAAI,cAAc;AAAA,YAClB,OAAO,cAAc,WAAW;AAAA,YAChC,KAAK,YAAY,eAAe,UAAU,KAAK;AAAA,YAC/C,YAAY,KAAK,MAAM,aAAa,GAAG,IAAI;AAAA,UAC7C;AAAA,UACA,WAAW;AAAA,UACX;AAAA,UACA,YAAY,cAAc,0BAA0B,qBAAqB,WACrE,kFACA;AAAA,QACN,CAAC;AAAA,MACH;AAAA,IACF;AAGA,WAAO;AAAA,EACT;AAAA;AAAA;AAAA;AAAA;AAAA,EAMQ,cACN,UACA,gBACA,YACA,wBACwB;AACxB,UAAM,YAAoC,CAAC;AAC3C,UAAM,oBAAoB,KAAK,kBAAkB,sBAAsB,gBAAgB,QAAQ;AAE/F,eAAW,oBAAoB,mBAAmB;AAChD,YAAM,UAAU,KAAK,kBAAkB,eAAe,UAAU,gBAAgB;AAEhF,UAAI,QAAQ,YAAY;AACtB,kBAAU,KAAK;AAAA,UACb,MAAM;AAAA,UACN,UAAU;AAAA,UACV,OAAO;AAAA,YACL,IAAI,iBAAiB;AAAA,YACrB,OAAO,iBAAiB,WAAW;AAAA,YACnC,KAAK,YAAY,kBAAkB,UAAU,KAAK;AAAA,YAClD,OAAO,iBAAiB,OAAO,YAAY,iBAAiB,OAAO,QAAQ;AAAA,YAC3E,KAAK,iBAAiB,KAAK,YAAY,iBAAiB,KAAK,QAAQ;AAAA,UACvE;AAAA,UACA,WAAW;AAAA,UACX,SAAS;AAAA,YACP,UAAU,QAAQ;AAAA,YAClB,YAAY,QAAQ;AAAA,YACpB,WAAW,QAAQ;AAAA,YACnB,SAAS,QAAQ;AAAA,UACnB;AAAA,QACF,CAAC;AAAA,MACH;AAAA,IACF;AAEA,WAAO;AAAA,EACT;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,2BACJ,cACA,cACA,kBACiC;AACjC,UAAM,YAAoC,CAAC;AAE3C,QAAI,CAAC,aAAa,SAAS,CAAC,aAAa,IAAK,QAAO;AAErD,UAAM,UAAU,aAAa,MAAM,YAAY,aAAa,MAAM;AAClE,UAAM,UAAU,aAAa,IAAI,YAAY,aAAa,IAAI;AAE9D,QAAI,CAAC,WAAW,CAAC,QAAS,QAAO;AAEjC,UAAM,WAAWA,QAAO,SAAS,EAAE,SAAS,MAAM,MAAM,aAAa,CAAC;AAEtE,QAAI;AACF,YAAM,mBAAmB,MAAM,SAAS,SAAS,MAAM;AAAA,QACrD,aAAa;AAAA,UACX;AAAA,UACA;AAAA,UACA,OAAO,iBAAiB,IAAI,SAAO,EAAE,GAAG,EAAE;AAAA,QAC5C;AAAA,MACF,CAAC;AAED,iBAAW,CAAC,YAAY,YAAY,KAAK,OAAO,QAAQ,iBAAiB,KAAK,aAAa,CAAC,CAAC,GAAG;AAC9F,YAAI,aAAa,QAAQ,aAAa,KAAK,SAAS,GAAG;AACrD,qBAAW,YAAY,aAAa,MAAM;AACxC,gBAAI,KAAK,kBAAkB,kBAAkB,cAAc,QAAQ,GAAG;AACpE,wBAAU,KAAK;AAAA,gBACb,MAAM;AAAA,gBACN,UAAU;AAAA,gBACV,OAAO;AAAA,kBACL,IAAI;AAAA,kBACJ,OAAO;AAAA,kBACP,OAAO,SAAS,SAAS;AAAA,kBACzB,KAAK,SAAS,OAAO;AAAA,gBACvB;AAAA,cACF,CAAC;AAAA,YACH;AAAA,UACF;AAAA,QACF;AAAA,MACF;AAAA,IACF,SAAS,OAAO;AACd,cAAQ,MAAM,8BAA8B,KAAK;AAAA,IACnD;AAEA,WAAO;AAAA,EACT;AACF;;;AI5TO,IAAM,qBAAN,cAAiC,gBAAgB;AAAA,EAC5C;AAAA,EAER,cAAc;AACV,UAAM;AACN,SAAK,2BAA2B,IAAI,yBAAyB;AAAA,EACjE;AAAA,EAEA,MAAM,QAAQ,MAAW,UAA8D;AACnF,UAAM,YAAY;AAIlB,UAAM,EAAE,QAAQ,cAAc,WAAW,mBAAmB,YAAY,mBAAmB,IAAI,MAAM,KAAK;AAAA,MACtG,KAAK;AAAA,MACL,UAAU;AAAA,MACV;AAAA,MACA;AAAA,IACJ;AAGA,QAAI,UAAU,cAAc,iBAAiB,UAAU,cAAc,mBAAmB;AACpF,UAAI,uBAAuB,aAAa,CAAC,mBAAmB,SAAS,GAAG,GAAG;AACvE,cAAM,gBAAgB,UAAU,cAAc,gBAAgB,kBAAkB;AAChF,cAAM,IAAI;AAAA,UACN,GAAG,aAAa;AAAA,QAEpB;AAAA,MACJ;AAAA,IACJ;AAGA,UAAM,WAAW,KAAK,YAAY,MAAM,KAAK,oBAAoB,cAAc,kBAAkB;AACjG,UAAM,eAAyC;AAAA,MAC3C,SAAS,KAAK;AAAA,MACd,aAAa,KAAK;AAAA,MAClB,OAAO,iBAAiB,KAAK,OAAO,QAAQ;AAAA,MAC5C,KAAK,iBAAiB,KAAK,KAAK,QAAQ;AAAA,MACxC,WAAW,KAAK;AAAA,MAChB,UAAU,KAAK;AAAA,IACnB;AAGA,UAAM,YAAY,MAAM,KAAK,yBAAyB;AAAA,MAClD;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,QACI,iBAAiB;AAAA,QACjB,gBAAgB;AAAA,QAChB,kBAAkB,UAAU,oBAAoB,CAAC,kBAAkB;AAAA,QACnE,8BAA8B,UAAU,gCAAgC,0BAA0B;AAAA,MACtG;AAAA,IACJ;AAGA,UAAM,iBAAiB,UAAU,WAAW;AAAA,MACxC,SAAO,IAAI,MAAM,cAAc,0BAA0B,qBAAqB;AAAA,IAClF;AAEA,QAAI,kBAAkB,UAAU,oBAAoB,MAAM;AAEtD,YAAM,IAAI;AAAA,QACN,6BAA6B,KAAK,MAAM,eAAe,MAAM,aAAa,GAAG,CAAC,sBACpE,eAAe,MAAM,KAAK;AAAA,MAExC;AAAA,IACJ;AAGA,UAAM,2BAA2B,EAAE,GAAG,WAAW,YAAY,mBAAmB;AAChF,UAAM,QAAQ,MAAM,KAAK,YAAY,cAAc,wBAAwB;AAG3E,UAAM,sBAAsB,6BAA6B,SAAS;AAClE,UAAM,WAAgC;AAAA,MAClC,OAAO,+BAA+B,OAAO,oBAAoB,iBAAiB;AAAA,MAClF,WAAW,oBAAoB;AAAA,MAC/B,YAAY,oBAAoB;AAAA,MAChC,UAAU,oBAAoB,SAAS;AAAA,IAC3C;AAEA,WAAO,yBAAyB,QAAQ;AAAA,EAC5C;AAAA,EAEA,MAAc,YACV,QACA,MACiC;AACjC,QAAI;AACA,YAAM,WAAW,KAAK,YAAY,MAAM;AAGxC,UAAI,KAAK,SAAS;AACd,wBAAgB,KAAK,OAAO;AAAA,MAChC;AAGA,YAAM,WAAW,KAAK,YAAY,MAAM,KAAK,oBAAoB,QAAQ,KAAK,UAAU;AAGxF,YAAM,EAAE,cAAc,WAAW,IAAI,KAAK,qBAAqB,IAAI;AAGnE,YAAM,UAAU,KAAK,cAAc,qBAAqB,CAAC,KAAK,UACxD,KAAK,+BAA+B,IAAI,IACxC,KAAK;AAEX,YAAM,cAAwC;AAAA,QAC1C;AAAA,QACA,aAAa,KAAK;AAAA,QAClB,OAAO,iBAAiB,KAAK,OAAO,QAAQ;AAAA,QAC5C,KAAK,iBAAiB,KAAK,KAAK,QAAQ;AAAA,QACxC,WAAW,KAAK;AAAA,QAChB,UAAU,KAAK;AAAA,QACf,SAAS,KAAK;AAAA,QACd,WAAW,KAAK;AAAA,QAChB,YAAY,KAAK;AAAA,QACjB;AAAA,QACA;AAAA,QACA,uBAAuB,KAAK;AAAA,QAC5B,iBAAiB,KAAK;AAAA,QACtB,yBAAyB,KAAK;AAAA,QAC9B,kBAAkB,KAAK;AAAA,QACvB,gBAAgB,KAAK;AAAA,QACrB,oBAAoB,KAAK;AAAA,QACzB,aAAa,KAAK;AAAA,QAClB,QAAQ,KAAK;AAAA,QACb,WAAW,KAAK;AAAA,QAChB,GAAI,KAAK,WAAW,EAAE,IAAI,KAAK,QAAQ;AAAA;AAAA,QACvC,GAAI,KAAK,uBAAuB,EAAE,qBAAqB,KAAK,oBAAoB;AAAA,QAChF,GAAI,KAAK,cAAc,iBAAiB,EAAE,uBAAuB,KAAK,2BAA2B,IAAI,EAAE;AAAA,QACvG,GAAI,KAAK,cAAc,qBAAqB,EAAE,2BAA2B,KAAK,+BAA+B,IAAI,EAAE;AAAA,MACvH;AAGA,YAAM,wBAAwB,KAAK,iBAAiB,IAAI;AACxD,YAAM,sBAAsB,KAAK,cAAc,OAAO;AAEtD,YAAM,WAAW,MAAM,SAAS,OAAO,OAAO;AAAA,QAC1C,YAAY,KAAK;AAAA,QACjB;AAAA,QACA,aAAa,KAAK;AAAA,QAClB,GAAI,yBAAyB,EAAE,sBAAsB;AAAA,QACrD,GAAI,uBAAuB,EAAE,oBAAoB;AAAA,MACrD,CAAC;AAED,UAAI,CAAC,SAAS,KAAM,OAAM,IAAI,MAAM,0CAA0C;AAC9E,aAAO,SAAS;AAAA,IACpB,SAAS,OAAY;AAEjB,UAAI,OAAO,SAAS,OAAO,OAAO,UAAU,WAAW,KAAK;AACxD,cAAM,IAAI,MAAM,aAAa,KAAK,OAAO,8CAA8C;AAAA,MAC3F;AACA,YAAM,KAAK,qBAAqB,KAAK;AAAA,IACzC;AAAA,EACJ;AAAA;AAAA;AAAA;AAAA,EAKQ,qBAAqB,MAG3B;AAEE,QAAI,eAAe,KAAK;AACxB,QAAI,aAAa,KAAK;AAEtB,YAAQ,KAAK,WAAW;AAAA,MACpB,KAAK;AAAA,MACL,KAAK;AAED,YAAI,CAAC,aAAc,gBAAe;AAClC;AAAA,MACJ,KAAK;AAED,YAAI,CAAC,aAAc,gBAAe;AAClC,YAAI,CAAC,WAAY,cAAa;AAC9B;AAAA,IACR;AAEA,WAAO,EAAE,cAAc,WAAW;AAAA,EACtC;AAAA;AAAA;AAAA;AAAA,EAKQ,2BAA2B,MAAuE;AACtG,UAAM,QAAQ,KAAK;AACnB,WAAO;AAAA,MACH,iBAAiB,OAAO,mBAAmB;AAAA,MAC3C,GAAI,OAAO,kBAAkB,EAAE,gBAAgB,MAAM,eAAe;AAAA,IACxE;AAAA,EACJ;AAAA;AAAA;AAAA;AAAA,EAKQ,+BAA+B,MAA2E;AAC9G,UAAM,QAAQ,KAAK;AACnB,QAAI,CAAC,OAAO;AACR,YAAM,IAAI,MAAM,2EAA2E;AAAA,IAC/F;AAEA,UAAM,aAAgE;AAAA,MAClE,MAAM,MAAM;AAAA,IAChB;AAEA,YAAQ,MAAM,MAAM;AAAA,MAChB,KAAK;AACD,mBAAW,aAAa,CAAC;AACzB;AAAA,MACJ,KAAK;AACD,mBAAW,iBAAiB,MAAM,kBAAkB,CAAC;AACrD;AAAA,MACJ,KAAK;AACD,mBAAW,iBAAiB,MAAM,kBAAkB,CAAC;AACrD;AAAA,IACR;AAEA,WAAO;AAAA,EACX;AAAA;AAAA;AAAA;AAAA,EAKQ,+BAA+B,MAAgC;AACnE,UAAM,QAAQ,KAAK;AACnB,QAAI,CAAC,MAAO,QAAO;AAEnB,YAAQ,MAAM,MAAM;AAAA,MAChB,KAAK;AACD,eAAO;AAAA,MACX,KAAK;AACD,eAAO,MAAM,gBAAgB,QACvB,gBAAgB,MAAM,eAAe,KAAK,KAC1C;AAAA,MACV,KAAK;AACD,eAAO,MAAM,gBAAgB,QACvB,gBAAgB,MAAM,eAAe,KAAK,KAC1C;AAAA,MACV;AACI,eAAO;AAAA,IACf;AAAA,EACJ;AACJ;;;AC/PO,IAAM,wBAAN,MAA4B;AAAA,EACzB;AAAA,EAER,YAAY,UAAgC;AAC1C,SAAK,WAAW;AAAA,EAClB;AAAA;AAAA;AAAA;AAAA,EAKA,cAAoC;AAClC,WAAO,KAAK;AAAA,EACd;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,gBAAgB,SAAiB,YAAqD;AAC1F,UAAM,WAAW,MAAM,KAAK,SAAS,OAAO,IAAI;AAAA,MAC9C;AAAA,MACA;AAAA,IACF,CAAC;AAED,UAAM,QAAQ,SAAS;AACvB,WAAO,MAAM,cAAc,MAAM,WAAW,SAAS,IAAI,cAAc;AAAA,EACzE;AAAA;AAAA;AAAA;AAAA,EAKA,iBAAiB,SAAiB,mBAAmC;AAEnE,UAAM,UAAU,IAAI,KAAK,iBAAiB;AAC1C,UAAM,kBAAkB,QAAQ,YAAY,EAAE,QAAQ,SAAS,EAAE,EAAE,MAAM,GAAG,EAAE,CAAC,IAAI;AAEnF,WAAO,GAAG,OAAO,IAAI,eAAe;AAAA,EACtC;AAAA;AAAA;AAAA;AAAA,EAKA,mBAAmB,iBAAiC;AAClD,UAAM,aAAa,IAAI,KAAK,eAAe;AAC3C,UAAM,YAAY,IAAI,KAAK,WAAW,QAAQ,IAAI,KAAQ;AAC1D,WAAO,UAAU,YAAY,EAAE,QAAQ,SAAS,EAAE,EAAE,MAAM,GAAG,EAAE,CAAC,IAAI;AAAA,EACtE;AAAA;AAAA;AAAA;AAAA,EAKA,iBAAiB,cAAsB,eAAiD;AACtF,UAAM,WAAW,IAAI,KAAK,YAAY;AACtC,UAAM,gBAAgB,IAAI,KAAK,cAAc,MAAO,QAAS;AAC7D,UAAM,cAAc,IAAI,KAAK,cAAc,IAAK,QAAS;AACzD,UAAM,WAAW,YAAY,QAAQ,IAAI,cAAc,QAAQ;AAE/D,WAAO,IAAI,KAAK,SAAS,QAAQ,IAAI,QAAQ,EAAE,YAAY;AAAA,EAC7D;AAAA;AAAA;AAAA;AAAA,EAKA,0BAA0B,YAAsB,WAA6B;AAC3E,QAAI,CAAC,cAAc,WAAW,WAAW,GAAG;AAC1C,YAAM,IAAI,MAAM,0BAA0B;AAAA,IAC5C;AAEA,UAAM,oBAA8B,CAAC;AACrC,QAAI,aAAa;AAEjB,eAAW,QAAQ,YAAY;AAC7B,UAAI,KAAK,WAAW,QAAQ,GAAG;AAC7B,qBAAa;AACb,cAAM,cAAc,KACjB,QAAQ,wBAAwB,EAAE,EAClC,QAAQ,eAAe,EAAE,IACxB,UAAU,SAAS;AACvB,0BAAkB,KAAK,WAAW;AAAA,MACpC,OAAO;AAEL,0BAAkB,KAAK,IAAI;AAAA,MAC7B;AAAA,IACF;AAEA,QAAI,CAAC,YAAY;AACf,YAAM,IAAI,MAAM,oCAAoC;AAAA,IACtD;AAEA,WAAO;AAAA,EACT;AAAA;AAAA;AAAA;AAAA,EAKA,yBAAyB,OAA2D;AAClF,UAAM,eAAe,EAAE,GAAG,MAAM;AAGhC,WAAO,aAAa;AACpB,WAAO,aAAa;AACpB,WAAO,aAAa;AACpB,WAAO,aAAa;AACpB,WAAO,aAAa;AACpB,WAAO,aAAa;AACpB,WAAO,aAAa;AAEpB,WAAO;AAAA,EACT;AAAA;AAAA;AAAA;AAAA,EAKA,uBAAuB,MAAW,iBAAoD;AACpF,UAAM,cAAwC,CAAC;AAE/C,QAAI,KAAK,YAAY,UAAa,KAAK,YAAY,KAAM,aAAY,UAAU,KAAK;AACpF,QAAI,KAAK,gBAAgB,UAAa,KAAK,gBAAgB,KAAM,aAAY,cAAc,KAAK;AAChG,QAAI,KAAK,aAAa,UAAa,KAAK,aAAa,KAAM,aAAY,WAAW,KAAK;AACvF,QAAI,KAAK,YAAY,UAAa,KAAK,YAAY,KAAM,aAAY,UAAU,KAAK;AACpF,QAAI,KAAK,cAAc,UAAa,KAAK,cAAc,KAAM,aAAY,YAAY,KAAK;AAC1F,QAAI,KAAK,cAAc,UAAa,KAAK,cAAc,KAAM,aAAY,YAAY,KAAK;AAC1F,QAAI,KAAK,eAAe,UAAa,KAAK,eAAe,KAAM,aAAY,aAAa,KAAK;AAC7F,QAAI,KAAK,mBAAmB,UAAa,KAAK,mBAAmB,KAAM,aAAY,iBAAiB,KAAK;AACzG,QAAI,KAAK,iBAAiB,UAAa,KAAK,iBAAiB,KAAM,aAAY,eAAe,KAAK;AACnG,QAAI,KAAK,eAAe,UAAa,KAAK,eAAe,KAAM,aAAY,aAAa,KAAK;AAC7F,QAAI,KAAK,0BAA0B,UAAa,KAAK,0BAA0B,KAAM,aAAY,wBAAwB,KAAK;AAC9H,QAAI,KAAK,oBAAoB,UAAa,KAAK,oBAAoB,KAAM,aAAY,kBAAkB,KAAK;AAC5G,QAAI,KAAK,4BAA4B,UAAa,KAAK,4BAA4B,KAAM,aAAY,0BAA0B,KAAK;AACpI,QAAI,KAAK,qBAAqB,UAAa,KAAK,qBAAqB,KAAM,aAAY,mBAAmB,KAAK;AAC/G,QAAI,KAAK,uBAAuB,UAAa,KAAK,uBAAuB,KAAM,aAAY,qBAAqB,KAAK;AACrH,QAAI,KAAK,gBAAgB,UAAa,KAAK,gBAAgB,KAAM,aAAY,cAAc,KAAK;AAChG,QAAI,KAAK,cAAc,UAAa,KAAK,cAAc,KAAM,aAAY,YAAY,KAAK;AAG1F,UAAM,oBAAoB,KAAK,YAAY;AAE3C,QAAI,KAAK,UAAU,UAAa,KAAK,UAAU,MAAM;AACnD,YAAM,UAAU,iBAAiB,KAAK,OAAO,iBAAiB;AAG9D,UAAI,QAAQ,SAAS,QAAW;AAE9B,oBAAY,QAAQ,EAAE,MAAM,QAAQ,MAAM,UAAU,KAAK;AAAA,MAC3D,OAAO;AAEL,oBAAY,QAAQ,EAAE,UAAU,QAAQ,UAAU,UAAU,QAAQ,UAAU,MAAM,KAAK;AAAA,MAC3F;AAAA,IACF;AACA,QAAI,KAAK,QAAQ,UAAa,KAAK,QAAQ,MAAM;AAC/C,YAAM,UAAU,iBAAiB,KAAK,KAAK,iBAAiB;AAE5D,UAAI,QAAQ,SAAS,QAAW;AAE9B,oBAAY,MAAM,EAAE,MAAM,QAAQ,MAAM,UAAU,KAAK;AAAA,MACzD,OAAO;AAEL,oBAAY,MAAM,EAAE,UAAU,QAAQ,UAAU,UAAU,QAAQ,UAAU,MAAM,KAAK;AAAA,MACzF;AAAA,IACF;AAEA,WAAO;AAAA,EACT;AACF;AAKO,IAAM,sBAAN,cAAkC,MAAM;AAAA,EACtC;AAAA,EAEP,YAAY,SAAiB,MAAc;AACzC,UAAM,OAAO;AACb,SAAK,OAAO;AACZ,SAAK,OAAO;AAAA,EACd;AACF;AAEO,IAAM,yBAAyB;AAAA,EACpC,eAAe;AAAA,EACf,uBAAuB;AAAA,EACvB,qBAAqB;AAAA,EACrB,kBAAkB;AAAA,EAClB,qBAAqB;AACvB;;;ACxKO,IAAM,qBAAN,cAAiC,gBAAgB;AAAA,EAC5C;AAAA,EAER,cAAc;AACV,UAAM;AACN,SAAK,2BAA2B,IAAI,yBAAyB;AAAA,EACjE;AAAA,EAEA,MAAM,QAAQ,MAAW,UAA8D;AACnF,UAAM,YAAY;AAGlB,UAAM,EAAE,QAAQ,cAAc,UAAU,WAAW,mBAAmB,YAAY,mBAAmB,IACjG,MAAM,KAAK,eAAe,KAAK,SAAS,UAAU,YAAY,UAAU,OAAO;AAGnF,UAAM,qBACD,UAAU,mBAAmB,UAAU,UAAU,SAAS,UAAU,QACpE,UAAU,cAAc,UAAa,UAAU,cAAc;AAElE,QAAI,gBAAiD;AACrD,QAAI,oBAAoB;AACpB,YAAM,wBAAwB,MAAM,SAAS,OAAO,IAAI;AAAA,QACpD,YAAY;AAAA,QACZ,SAAS,UAAU;AAAA,MACvB,CAAC;AACD,sBAAgB,sBAAsB;AAEtC,UAAI,CAAC,eAAe;AAChB,cAAM,IAAI,MAAM,iBAAiB;AAAA,MACrC;AAAA,IACJ;AAGA,QAAI,YAAY;AAChB,QAAI,UAAU,mBAAmB,UAAU,UAAU,SAAS,UAAU,QAAQ,eAAe;AAE3F,YAAM,WAAW,UAAU,YAAY,MAAM,KAAK,oBAAoB,cAAc,kBAAkB;AACtG,YAAM,eAAyC;AAAA,QAC3C,GAAG;AAAA,QACH,IAAI,UAAU;AAAA,QACd,SAAS,UAAU,WAAW,cAAc;AAAA,QAC5C,aAAa,UAAU,eAAe,cAAc;AAAA,QACpD,OAAO,UAAU,QAAQ,iBAAiB,UAAU,OAAO,QAAQ,IAAI,cAAc;AAAA,QACrF,KAAK,UAAU,MAAM,iBAAiB,UAAU,KAAK,QAAQ,IAAI,cAAc;AAAA,QAC/E,UAAU,UAAU,YAAY,cAAc;AAAA,MAClD;AAGA,kBAAY,MAAM,KAAK,yBAAyB;AAAA,QAC5C;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,UACI,iBAAiB;AAAA;AAAA,UACjB,gBAAgB;AAAA,UAChB,kBAAkB,UAAU,oBAAoB,CAAC,kBAAkB;AAAA,QACvE;AAAA,MACJ;AAAA,IACJ;AAGA,QAAI,0BAAqE,EAAE,GAAG,WAAW,YAAY,mBAAmB;AACxH,QAAI,UAAU,cAAc,UAAa,UAAU,cAAc,QAAQ,eAAe;AACpF,YAAM,kBAAkB,KAAK,eAAe,cAAc,aAAa,CAAC,GAAG,UAAU,SAAS;AAE9F,gCAA0B;AAAA,QACtB,GAAG;AAAA,QACH,WAAW;AAAA,MACf;AAAA,IACJ;AAGA,UAAM,QAAQ,MAAM,KAAK,qBAAqB,cAAc,uBAAuB;AAGnF,UAAM,WAAgC;AAAA,MAClC,OAAO,+BAA+B,OAAO,oBAAoB,iBAAiB;AAAA,IACtF;AAGA,QAAI,aAAa,UAAU,cAAc;AACrC,YAAM,sBAAsB,6BAA6B,SAAS;AAClE,UAAI,oBAAoB,WAAW;AAC/B,iBAAS,YAAY,oBAAoB;AAAA,MAC7C;AACA,eAAS,WAAW,oBAAoB,SAAS;AAAA,IACrD;AAEA,WAAO,yBAAyB,QAAQ;AAAA,EAC5C;AAAA,EAEA,MAAc,qBACV,QACA,MACiC;AACjC,QAAI;AACA,YAAM,WAAW,KAAK,YAAY,MAAM;AACxC,YAAM,UAAU,IAAI,sBAAsB,QAAQ;AAGlD,YAAM,kBAAkB,MAAM,KAAK,oBAAoB,QAAQ,KAAK,UAAU;AAG9E,YAAM,YAAY,MAAM,QAAQ,gBAAgB,KAAK,SAAS,KAAK,UAAU;AAE7E,UAAI,KAAK,qBAAqB,KAAK,sBAAsB,SAAS,cAAc,aAAa;AACzF,cAAM,IAAI;AAAA,UACN;AAAA,UACA,uBAAuB;AAAA,QAC3B;AAAA,MACJ;AAEA,cAAQ,KAAK,mBAAmB;AAAA,QAC5B,KAAK;AACD,iBAAO,KAAK,qBAAqB,SAAS,MAAM,eAAe;AAAA,QACnE,KAAK;AAAA,QACL,KAAK;AACD,iBAAO,KAAK,mBAAmB,SAAS,MAAM,eAAe;AAAA,QACjE,KAAK;AACD,iBAAO,KAAK,sBAAsB,SAAS,MAAM,eAAe;AAAA,QACpE;AACI,gBAAM,IAAI;AAAA,YACN,+BAA+B,KAAK,iBAAiB;AAAA,YACrD,uBAAuB;AAAA,UAC3B;AAAA,MACR;AAAA,IACJ,SAAS,OAAO;AACZ,UAAI,iBAAiB,qBAAqB;AACtC,cAAM;AAAA,MACV;AACA,YAAM,KAAK,qBAAqB,KAAK;AAAA,IACzC;AAAA,EACJ;AAAA,EAEA,MAAc,qBACV,SACA,MACA,iBACiC;AACjC,QAAI,CAAC,KAAK,mBAAmB;AACzB,YAAM,IAAI;AAAA,QACN;AAAA,QACA,uBAAuB;AAAA,MAC3B;AAAA,IACJ;AAEA,UAAM,WAAW,QAAQ,YAAY;AACrC,UAAM,aAAa,QAAQ,iBAAiB,KAAK,SAAS,KAAK,iBAAiB;AAEhF,UAAM,cAAc,QAAQ,uBAAuB,MAAM,eAAe;AACxE,UAAM,wBAAwB,YAAY,mBAAmB,SAAY,IAAI;AAC7E,UAAM,sBAAsB,YAAY,gBAAgB,SAAY,OAAO;AAE3E,UAAM,WAAW,MAAM,SAAS,OAAO,MAAM;AAAA,MACzC,YAAY,KAAK;AAAA,MACjB,SAAS;AAAA,MACT;AAAA,MACA,GAAI,yBAAyB,EAAE,sBAAsB;AAAA,MACrD,GAAI,uBAAuB,EAAE,oBAAoB;AAAA,IACrD,CAAC;AAED,QAAI,CAAC,SAAS,KAAM,OAAM,IAAI,MAAM,iCAAiC;AACrE,WAAO,SAAS;AAAA,EACpB;AAAA,EAEA,MAAc,mBACV,SACA,MACA,iBACiC;AACjC,UAAM,WAAW,QAAQ,YAAY;AAErC,UAAM,cAAc,QAAQ,uBAAuB,MAAM,eAAe;AACxE,UAAM,wBAAwB,YAAY,mBAAmB,SAAY,IAAI;AAC7E,UAAM,sBAAsB,YAAY,gBAAgB,SAAY,OAAO;AAE3E,UAAM,WAAW,MAAM,SAAS,OAAO,MAAM;AAAA,MACzC,YAAY,KAAK;AAAA,MACjB,SAAS,KAAK;AAAA,MACd;AAAA,MACA,GAAI,yBAAyB,EAAE,sBAAsB;AAAA,MACrD,GAAI,uBAAuB,EAAE,oBAAoB;AAAA,IACrD,CAAC;AAED,QAAI,CAAC,SAAS,KAAM,OAAM,IAAI,MAAM,wBAAwB;AAC5D,WAAO,SAAS;AAAA,EACpB;AAAA,EAEA,MAAc,sBACV,SACA,MACA,iBACiC;AACjC,QAAI,CAAC,KAAK,iBAAiB;AACvB,YAAM,IAAI;AAAA,QACN;AAAA,QACA,uBAAuB;AAAA,MAC3B;AAAA,IACJ;AAEA,UAAM,WAAW,QAAQ,YAAY;AACrC,UAAM,oBAAoB,KAAK,YAAY;AAG3C,UAAM,mBAAmB,MAAM,SAAS,OAAO,IAAI;AAAA,MAC/C,YAAY,KAAK;AAAA,MACjB,SAAS,KAAK;AAAA,IAClB,CAAC;AACD,UAAM,gBAAgB,iBAAiB;AAEvC,QAAI,CAAC,cAAc,YAAY;AAC3B,YAAM,IAAI,MAAM,sCAAsC;AAAA,IAC1D;AAGA,UAAM,YAAY,QAAQ,mBAAmB,KAAK,eAAe;AACjE,UAAM,oBAAoB,QAAQ,0BAA0B,cAAc,YAAY,SAAS;AAE/F,UAAM,SAAS,OAAO,MAAM;AAAA,MACxB,YAAY,KAAK;AAAA,MACjB,SAAS,KAAK;AAAA,MACd,aAAa,EAAE,YAAY,kBAAkB;AAAA,IACjD,CAAC;AAGD,UAAM,cAAc,QAAQ,uBAAuB,MAAM,eAAe;AAGxE,QAAI,UAAU,KAAK;AACnB,QAAI,KAAK,SAAS,KAAK,iBAAiB;AACpC,YAAM,eAAe,KAAK,SAAS,KAAK;AACxC,gBAAU,WAAW,QAAQ,iBAAiB,cAAc,aAAa;AAAA,IAC7E;AAEA,UAAM,WAAW;AAAA,MACb,GAAG,QAAQ,yBAAyB,aAAa;AAAA,MACjD,GAAG;AAAA,MACH,OAAO;AAAA,QACH,UAAU,KAAK,SAAS,KAAK;AAAA,QAC7B,UAAU;AAAA,MACd;AAAA,MACA,KAAK;AAAA,QACD,UAAU;AAAA,QACV,UAAU;AAAA,MACd;AAAA,IACJ;AAEA,UAAM,wBAAwB,SAAS,mBAAmB,SAAY,IAAI;AAC1E,UAAM,sBAAsB,SAAS,gBAAgB,SAAY,OAAO;AAExE,UAAM,WAAW,MAAM,SAAS,OAAO,OAAO;AAAA,MAC1C,YAAY,KAAK;AAAA,MACjB,aAAa;AAAA,MACb,GAAI,yBAAyB,EAAE,sBAAsB;AAAA,MACrD,GAAI,uBAAuB,EAAE,oBAAoB;AAAA,IACrD,CAAC;AAED,QAAI,CAAC,SAAS,KAAM,OAAM,IAAI,MAAM,sCAAsC;AAC1E,WAAO,SAAS;AAAA,EACpB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOQ,eACJ,mBACA,cACkC;AAClC,UAAM,kBAAkB,oBAAI,IAA8C;AAC1E,eAAW,YAAY,mBAAmB;AACtC,UAAI,SAAS,OAAO;AAChB,wBAAgB,IAAI,SAAS,MAAM,YAAY,GAAG,QAAQ;AAAA,MAC9D;AAAA,IACJ;AAEA,UAAM,kBAAsD,CAAC;AAG7D,eAAW,eAAe,cAAc;AACpC,YAAM,WAAW,gBAAgB,IAAI,YAAY,MAAM,YAAY,CAAC;AACpE,UAAI,UAAU;AAEV,wBAAgB,KAAK,QAAQ;AAAA,MACjC,OAAO;AAEH,wBAAgB,KAAK,EAAE,OAAO,YAAY,MAAM,CAAC;AAAA,MACrD;AAAA,IACJ;AAEA,WAAO;AAAA,EACX;AAEJ;;;AClTO,IAAM,qBAAN,cAAiC,gBAAgB;AAAA,EACpD,MAAM,QAAQ,MAAW,UAA8D;AACnF,UAAM,YAAY;AAIlB,UAAM,EAAE,QAAQ,cAAc,YAAY,mBAAmB,IAAI,MAAM,KAAK;AAAA,MACxE,KAAK;AAAA,MACL,UAAU;AAAA,MACV;AAAA,MACA;AAAA,IACJ;AAGA,UAAM,2BAA2B,EAAE,GAAG,WAAW,YAAY,mBAAmB;AAChF,UAAM,KAAK,YAAY,cAAc,wBAAwB;AAE7D,UAAM,WAAgC;AAAA,MAClC,SAAS;AAAA,MACT,SAAS,UAAU;AAAA,MACnB,YAAY;AAAA,MACZ,SAAS;AAAA,IACb;AAEA,WAAO,yBAAyB,QAAQ;AAAA,EAC5C;AAAA,EAEA,MAAc,YACV,QACA,MACa;AACb,QAAI;AACA,YAAM,WAAW,KAAK,YAAY,MAAM;AACxC,YAAM,SAAS,OAAO,OAAO;AAAA,QACzB,YAAY,KAAK;AAAA,QACjB,SAAS,KAAK;AAAA,QACd,aAAa,KAAK;AAAA,MACtB,CAAC;AAAA,IACL,SAAS,OAAO;AACZ,YAAM,KAAK,qBAAqB,KAAK;AAAA,IACzC;AAAA,EACJ;AACJ;;;AC1CA,SAAS,YAAAC,iBAAgB;AACzB,SAAS,aAAAC,kBAAiB;AAQnB,IAAM,uBAAN,cAAmC,gBAAgB;AAAA,EACxD,MAAM,QAAQ,MAAW,UAA8D;AACrF,UAAM,YAAY;AAElB,QAAI,CAAC,KAAK,sBAAsB,UAAU,SAAS,UAAU,OAAO,GAAG;AACrE,YAAM,IAAIC;AAAA,QACRC,WAAU;AAAA,QACV;AAAA,MACF;AAAA,IACF;AAGA,UAAM,mBAAmB,KAAK,sBAAsB,KAAK,SAAS,QAAQ;AAG1E,UAAM,kBAAkB,MAAM,KAAK,0BAA0B,kBAAkB,SAAS;AAExF,UAAM,WAA6B;AAAA,MACjC,SAAS,UAAU;AAAA,MACnB,SAAS,UAAU;AAAA,MACnB,WAAW;AAAA,IACb;AAEA,WAAO,yBAAyB,QAAQ;AAAA,EAC1C;AAAA,EAEA,MAAc,0BACZ,UACA,MACiD;AACjD,UAAM,kBAA0D,CAAC;AACjE,UAAM,cAAc,KAAK,UAAU,IAAI,OAAK,EAAE,EAAE;AAKhD,QAAI;AACJ,UAAM,qBAA+B,CAAC;AAEtC,QAAI,SAAS,OAAO,GAAG;AACrB,YAAM,EAAE,UAAU,SAAS,IAAI,MAAM,KAAK,iBAAiB;AAAA,QACzD;AAAA,QACA;AAAA,MACF;AACA,2BAAqB;AACrB,yBAAmB,KAAK,GAAG,QAAQ;AAGnC,UAAI,mBAAmB,SAAS,GAAG;AACjC,mBAAW,SAAS,aAAa;AAC/B,0BAAgB,KAAK,IAAI;AAAA,YACvB,MAAM,CAAC;AAAA,YACP,QAAQ,CAAC,EAAE,QAAQ,WAAW,CAAC;AAAA,UACjC;AAAA,QACF;AACA,eAAO;AAAA,MACT;AAAA,IACF,OAAO;AAEL,YAAM,CAACC,UAAS,IAAI,SAAS,KAAK;AAClC,2BAAqB,oBAAI,IAAI,CAAC,CAACA,YAAW,WAAW,CAAC,CAAC;AAAA,IACzD;AAGA,UAAM,UAAU,MAAM,QAAQ;AAAA,MAC5B,MAAM,KAAK,mBAAmB,QAAQ,CAAC,EAAE,IAAI,OAAO,CAACA,YAAW,mBAAmB,MAAM;AACvF,cAAM,SAAS,SAAS,IAAIA,UAAS;AACrC,YAAI;AAEF,gBAAM,eAAiC;AAAA,YACrC,GAAG;AAAA,YACH,WAAW,KAAK,UAAU,OAAO,OAAK,oBAAoB,SAAS,EAAE,EAAE,CAAC;AAAA,UAC1E;AACA,gBAAM,SAAS,MAAM,KAAK,cAAc,QAAQ,YAAY;AAC5D,iBAAO,EAAE,WAAAA,YAAW,QAAQ,OAAO,MAAM,kBAAkB,oBAAoB;AAAA,QACjF,SAAS,OAAO;AAEd,gBAAM,UAAU,iBAAiB,QAAQ,MAAM,UAAU,OAAO,KAAK;AACrE,kBAAQ,OAAO,MAAM,+CAA+CA,UAAS,MAAM,OAAO;AAAA,CAAI;AAC9F,iBAAO,EAAE,WAAAA,YAAW,QAAQ,MAAM,OAAO,SAAS,kBAAkB,oBAAoB;AAAA,QAC1F;AAAA,MACF,CAAC;AAAA,IACH;AAIA,eAAW,SAAS,aAAa;AAC/B,UAAI,aAA4C;AAEhD,iBAAW,EAAE,OAAO,KAAK,SAAS;AAChC,YAAI,CAAC,QAAQ,UAAW;AAExB,cAAM,UAAU,OAAO,UAAU,KAAK;AACtC,YAAI,CAAC,QAAS;AAGd,YAAI,CAAC,YAAY;AACf,uBAAa;AAAA,YACX,MAAM,QAAQ,MAAM,IAAI,CAAC,UAAe,EAAE,OAAO,KAAK,OAAO,KAAK,KAAK,IAAI,EAAE,KAAK,CAAC;AAAA,YACnF,QAAQ,QAAQ,QAAQ,IAAI,CAAC,SAAc,EAAE,QAAQ,IAAI,QAAQ,QAAQ,IAAI,OAAO,EAAE;AAAA,UACxF;AAAA,QACF,WAAW,WAAW,UAAU,CAAC,QAAQ,QAAQ;AAE/C,uBAAa;AAAA,YACX,MAAM,QAAQ,MAAM,IAAI,CAAC,UAAe,EAAE,OAAO,KAAK,OAAO,KAAK,KAAK,IAAI,EAAE,KAAK,CAAC;AAAA,UACrF;AAAA,QACF;AAAA,MACF;AAGA,UAAI,CAAC,YAAY;AACf,wBAAgB,KAAK,IAAI;AAAA,UACvB,MAAM,CAAC;AAAA,UACP,QAAQ,CAAC,EAAE,QAAQ,WAAW,CAAC;AAAA,QACjC;AAAA,MACF,OAAO;AACL,wBAAgB,KAAK,IAAI;AAAA,MAC3B;AAAA,IACF;AAEA,WAAO;AAAA,EACT;AAAA,EAEA,MAAc,cACZ,QACA,MACiC;AACjC,QAAI;AACF,YAAM,WAAW,KAAK,YAAY,MAAM;AAMxC,UAAI;AACJ,UAAI,KAAK,UAAU;AACjB,mBAAW,KAAK;AAAA,MAClB,OAAO;AACL,YAAI;AACF,qBAAW,MAAM,KAAK,oBAAoB,QAAQ,SAAS;AAAA,QAC7D,SAAS,OAAO;AAGd,qBAAW;AAAA,QACb;AAAA,MACF;AAIA,YAAM,UAAU,iBAAiB,KAAK,SAAS,QAAQ;AACvD,YAAM,UAAU,iBAAiB,KAAK,SAAS,QAAQ;AAMvD,YAAM,cAAmB;AAAA,QACvB;AAAA,QACA;AAAA,QACA,OAAO,KAAK;AAAA,QACZ,UAAU;AAAA;AAAA,MACZ;AAGA,UAAI,KAAK,sBAAsB,QAAW;AACxC,oBAAY,oBAAoB,KAAK;AAAA,MACvC;AACA,UAAI,KAAK,yBAAyB,QAAW;AAC3C,oBAAY,uBAAuB,KAAK;AAAA,MAC1C;AAEA,YAAM,WAAW,MAAM,SAAS,SAAS,MAAM;AAAA,QAC7C;AAAA,MACF,CAAC;AACD,aAAO,SAAS;AAAA,IAClB,SAAS,OAAO;AACd,YAAM,KAAK,qBAAqB,KAAK;AAAA,IACvC;AAAA,EACF;AAAA,EAEQ,sBAAsB,SAAiB,SAA0B;AACvE,UAAM,UAAU,IAAI,KAAK,OAAO;AAChC,UAAM,UAAU,IAAI,KAAK,OAAO;AAEhC,UAAM,qBAAqB,QAAQ,QAAQ,IAAI,QAAQ,QAAQ;AAC/D,UAAM,4BAA4B,IAAI,KAAK,KAAK,KAAK,KAAK;AAE1D,WAAO,sBAAsB;AAAA,EAC/B;AACF;;;AC1MA,SAAS,YAAAC,WAAU,aAAAC,kBAAiB;AAK7B,IAAM,wBAAN,cAAoC,gBAAgB;AAAA,EACvD,MAAM,QAAQ,MAAW,UAA8D;AAEnF,UAAM,YAAY;AAIlB,UAAM,eAAe,KAAK,2BAA2B,KAAK,SAAS,QAAQ;AAE3E,UAAM,MAAM,oBAAI,KAAK;AAGrB,UAAM,oBAAoB,UAAU;AAEpC,QAAI;AACJ,QAAI,UAAU,UAAU;AACpB,UAAI,CAAC,KAAK,gBAAgB,UAAU,QAAQ,GAAG;AAC3C,cAAM,IAAIC;AAAA,UACNC,WAAU;AAAA,UACV,qBAAqB,UAAU,QAAQ;AAAA,QAC3C;AAAA,MACJ;AACA,iBAAW,UAAU;AAAA,IACzB,OAAO;AACH,UAAI;AACA,mBAAW,MAAM,KAAK,oBAAoB,cAAc,SAAS;AACjE,YAAI,aAAa,OAAO;AACpB,gBAAM,MAAM,KAAK,kBAAkB;AACnC,cAAI,QAAQ,MAAO,YAAW;AAAA,QAClC;AAAA,MACJ,QAAQ;AACJ,mBAAW,KAAK,kBAAkB;AAAA,MACtC;AAAA,IACJ;AAEA,UAAM,WAAmC;AAAA,MACrC,aAAa,KAAK,gBAAgB,KAAK,QAAQ;AAAA,MAC/C;AAAA,MACA,QAAQ,KAAK,kBAAkB,KAAK,QAAQ;AAAA,MAC5C,OAAO,KAAK,qBAAqB,KAAK,QAAQ;AAAA,MAC9C,WAAW,IAAI,KAAK,eAAe,SAAS;AAAA,QACxC,SAAS;AAAA,QACT,UAAU;AAAA,MACd,CAAC,EAAE,OAAO,GAAG;AAAA,IACjB;AAEA,WAAO,yBAAyB,QAAQ;AAAA,EAC5C;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAoBQ,gBAAgB,MAAY,UAA0B;AAC1D,UAAM,QAAQ,IAAI,KAAK,eAAe,SAAS;AAAA,MAC3C;AAAA,MACA,MAAM;AAAA,MACN,OAAO;AAAA,MACP,KAAK;AAAA,MACL,MAAM;AAAA,MACN,QAAQ;AAAA,MACR,QAAQ;AAAA,MACR,QAAQ;AAAA,MACR,wBAAwB;AAAA;AAAA,IAC5B,CAAC,EAAE,cAAc,IAAI;AAErB,UAAM,MAAM,MAAM,OAAO,CAAC,KAAK,MAAM;AACjC,UAAI,EAAE,IAAI,IAAI,EAAE;AAChB,aAAO;AAAA,IACX,GAAG,CAAC,CAA2B;AAE/B,UAAM,MAAM,GAAG,IAAI,IAAI,IAAI,IAAI,KAAK,IAAI,IAAI,GAAG,IAAI,IAAI,IAAI,IAAI,IAAI,MAAM,IAAI,IAAI,MAAM,IAAI,IAAI,oBAAoB,KAAK;AACxH,UAAM,SAAS,KAAK,kBAAkB,MAAM,QAAQ;AACpD,WAAO,WAAW,MAAM,GAAG,GAAG,MAAM,GAAG,GAAG,GAAG,MAAM;AAAA,EACvD;AAAA,EAEQ,oBAA4B;AAChC,QAAI;AACA,aAAO,KAAK,eAAe,EAAE,gBAAgB,EAAE;AAAA,IACnD,QAAQ;AACJ,aAAO;AAAA,IACX;AAAA,EACJ;AAAA,EAEQ,gBAAgB,UAA2B;AAC/C,QAAI;AACA,WAAK,eAAe,QAAW,EAAE,SAAS,CAAC;AAC3C,aAAO;AAAA,IACX,QAAQ;AACJ,aAAO;AAAA,IACX;AAAA,EACJ;AAAA,EAEQ,kBAAkB,OAAa,UAA0B;AAC7D,QAAI;AACA,YAAM,gBAAgB,KAAK,yBAAyB,QAAQ;AAE5D,UAAI,kBAAkB,GAAG;AACrB,eAAO;AAAA,MACX;AAEA,YAAM,cAAc,KAAK,MAAM,KAAK,IAAI,aAAa,IAAI,EAAE;AAC3D,YAAM,aAAa,KAAK,IAAI,aAAa,IAAI;AAC7C,YAAM,OAAO,iBAAiB,IAAI,MAAM;AAExC,aAAO,GAAG,IAAI,GAAG,YAAY,SAAS,EAAE,SAAS,GAAG,GAAG,CAAC,IAAI,WAAW,SAAS,EAAE,SAAS,GAAG,GAAG,CAAC;AAAA,IACtG,QAAQ;AACJ,aAAO;AAAA,IACX;AAAA,EACJ;AAAA,EAEQ,yBAAyB,UAA0B;AACvD,WAAO,KAAK,yBAAyB,oBAAI,KAAK,GAAG,QAAQ;AAAA,EAC7D;AAAA,EAEQ,qBAAqB,MAAY,UAA2B;AAChE,QAAI;AAEA,YAAM,gBAAgB,KAAK,yBAAyB,MAAM,QAAQ;AAGlE,YAAM,UAAU,IAAI,KAAK,KAAK,YAAY,GAAG,GAAG,CAAC;AACjD,YAAM,gBAAgB,KAAK,yBAAyB,SAAS,QAAQ;AAGrE,YAAM,OAAO,IAAI,KAAK,KAAK,YAAY,GAAG,GAAG,CAAC;AAC9C,YAAM,aAAa,KAAK,yBAAyB,MAAM,QAAQ;AAI/D,UAAI,kBAAkB,YAAY;AAC9B,cAAM,YAAY,KAAK,IAAI,eAAe,UAAU;AACpD,eAAO,kBAAkB;AAAA,MAC7B;AAEA,aAAO;AAAA,IACX,QAAQ;AACJ,aAAO;AAAA,IACX;AAAA,EACJ;AAAA,EAEQ,yBAAyB,MAAY,UAA0B;AAEnE,UAAM,mBAAmB,IAAI,KAAK,eAAe,SAAS;AAAA,MACtD;AAAA,MACA,MAAM;AAAA,MACN,OAAO;AAAA,MACP,KAAK;AAAA,MACL,MAAM;AAAA,MACN,QAAQ;AAAA,MACR,QAAQ;AAAA,IACZ,CAAC,EAAE,OAAO,IAAI;AAGd,UAAM,gBAAgB,IAAI,KAAK,eAAe,SAAS;AAAA,MACnD,UAAU;AAAA,MACV,MAAM;AAAA,MACN,OAAO;AAAA,MACP,KAAK;AAAA,MACL,MAAM;AAAA,MACN,QAAQ;AAAA,MACR,QAAQ;AAAA,IACZ,CAAC,EAAE,OAAO,IAAI;AAGd,UAAM,cAAa,oBAAI,KAAK,iBAAiB,QAAQ,KAAK,GAAG,IAAI,GAAG,GAAE,QAAQ;AAC9E,UAAM,iBAAgB,oBAAI,KAAK,cAAc,QAAQ,KAAK,GAAG,IAAI,GAAG,GAAE,QAAQ;AAE9E,YAAQ,aAAa,kBAAkB,MAAO;AAAA,EAClD;AACJ;;;AC7KO,IAAM,wBAAN,cAAoC,gBAAgB;AAAA,EACvD,MAAM,QAAQ,MAA2B,UAA8D;AACnG,UAAM,YAAY;AAGlB,UAAM,EAAE,UAAU,WAAW,mBAAmB,YAAY,mBAAmB,IAC3E,MAAM,KAAK,eAAe,KAAK,SAAS,UAAU,YAAY,UAAU,OAAO;AAEnF,QAAI;AACA,YAAM,UAAU,IAAI,sBAAsB,QAAQ;AAGlD,UAAI,gBAAgB,UAAU;AAG9B,UAAI,UAAU,sBAAsB,iBAAiB;AACjD,YAAI,CAAC,UAAU,mBAAmB;AAC9B,gBAAM,IAAI;AAAA,YACN;AAAA,YACA,uBAAuB;AAAA,UAC3B;AAAA,QACJ;AAGA,cAAM,YAAY,MAAM,QAAQ,gBAAgB,UAAU,SAAS,kBAAkB;AACrF,YAAI,cAAc,aAAa;AAC3B,gBAAM,IAAI;AAAA,YACN;AAAA,YACA,uBAAuB;AAAA,UAC3B;AAAA,QACJ;AAGA,wBAAgB,QAAQ,iBAAiB,UAAU,SAAS,UAAU,iBAAiB;AAAA,MAC3F,WAAW,UAAU,sBAAsB,OAAO;AAI9C,wBAAgB,UAAU,QAAQ,MAAM,GAAG,EAAE,CAAC;AAAA,MAClD;AAIA,YAAM,gBAAgB,MAAM,SAAS,OAAO,IAAI;AAAA,QAC5C,YAAY;AAAA,QACZ,SAAS;AAAA,MACb,CAAC;AAED,YAAM,QAAQ,cAAc;AAC5B,UAAI,CAAC,OAAO;AACR,cAAM,IAAI,MAAM,iBAAiB;AAAA,MACrC;AAGA,YAAM,YAAY,MAAM,aAAa,CAAC;AACtC,YAAM,oBAAoB,UAAU,UAAU,OAAK,EAAE,SAAS,IAAI;AAElE,UAAI,sBAAsB,IAAI;AAC1B,cAAM,IAAI;AAAA,UACN;AAAA,QACJ;AAAA,MACJ;AAEA,YAAM,eAAe,UAAU,iBAAiB;AAGhD,UAAI,aAAa,cAAc,MAAM;AACjC,cAAM,IAAI;AAAA,UACN;AAAA,QACJ;AAAA,MACJ;AAGA,YAAM,mBAAmB,CAAC,GAAG,SAAS;AACtC,uBAAiB,iBAAiB,IAAI;AAAA,QAClC,GAAG;AAAA,QACH,gBAAgB,UAAU;AAAA,QAC1B,GAAI,UAAU,YAAY,UAAa,EAAE,SAAS,UAAU,QAAQ;AAAA,MACxE;AAGA,YAAM,oBAAoB,UAAU,eAAe;AACnD,YAAM,iBAAiB,MAAM,SAAS,OAAO,MAAM;AAAA,QAC/C,YAAY;AAAA,QACZ,SAAS;AAAA,QACT,aAAa;AAAA,UACT,WAAW;AAAA,QACf;AAAA,QACA,aAAa;AAAA,MACjB,CAAC;AAED,UAAI,CAAC,eAAe,MAAM;AACtB,cAAM,IAAI,MAAM,iCAAiC;AAAA,MACrD;AAGA,UAAI,UAAU,kCAAkC,UAAU,QAAQ;AAClE,UAAI,UAAU,sBAAsB,iBAAiB;AACjD,mBAAW;AAAA,MACf,WAAW,UAAU,sBAAsB,OAAO;AAC9C,mBAAW;AAAA,MACf;AACA,UAAI,UAAU,SAAS;AACnB,mBAAW,gBAAgB,UAAU,OAAO;AAAA,MAChD;AAEA,YAAM,WAAmC;AAAA,QACrC,OAAO,+BAA+B,eAAe,MAAM,oBAAoB,iBAAiB;AAAA,QAChG,gBAAgB,UAAU;AAAA,QAC1B,aAAa;AAAA,QACb;AAAA,MACJ;AAEA,aAAO,yBAAyB,QAAQ;AAAA,IAC5C,SAAS,OAAY;AACjB,UAAI,iBAAiB,qBAAqB;AACtC,cAAM;AAAA,MACV;AACA,YAAM,KAAK,qBAAqB,KAAK;AAAA,IACzC;AAAA,EACJ;AACJ;;;AxBjHA,IAAM,uBAAuB;AAC7B,IAAM,0BAA0B;AAChC,IAAM,gBAAgB;AAGtB,IAAM,qBAAqB,CAAC,QAC1B,qBAAqB,KAAK,GAAG,KAAK,wBAAwB,KAAK,GAAG;AAEpE,IAAM,2BAA2B,CAAC,QAChC,cAAc,KAAK,GAAG,KAAK,mBAAmB,GAAG;AAMnD,IAAM,sBAAsB,CAAC,OAAO,gBAAgB,MAAM;AAC1D,IAAM,oBAAoB,CAAC,WAAW,UAAU,WAAW,cAAc;AACzE,IAAM,sBAAsB,CAAC,UAAU,aAAa;AACpD,IAAM,2BAA2B;AAAA,EAC/B;AAAA,EACA;AAAA,EACA;AACF;AACA,IAAM,yBAAyB,CAAC,eAAe,YAAY,aAAa,UAAU;AAClF,IAAM,yBAAyB,CAAC,gBAAgB,gBAAgB,qBAAqB,OAAO;AAM5F,IAAM,kBAAkB,EAAE,OAAO;AAAA,EAC/B,YAAY,EAAE,QAAQ,EAAE,SAAS,sCAAsC;AAAA,EACvE,WAAW,EAAE,MAAM,EAAE,OAAO;AAAA,IAC1B,QAAQ,EAAE,KAAK,CAAC,SAAS,OAAO,CAAC,EAAE,QAAQ,OAAO,EAAE,SAAS,iBAAiB;AAAA,IAC9E,SAAS,EAAE,OAAO,EAAE,SAAS,kDAAkD;AAAA,EACjF,CAAC,EAAE,QAAQ,EAAE,QAAQ,KAAK,CAAC,CAAC,EAAE,SAAS,EAAE,SAAS,kBAAkB;AACtE,CAAC,EAAE,SAAS,iCAAiC,EAAE,SAAS;AAExD,IAAM,uBAAuB,EAAE,OAAO;AAAA,EACpC,eAAe,EAAE,OAAO;AAAA,IACtB,WAAW,EAAE,OAAO,EAAE,SAAS,mEAAmE;AAAA,IAClG,uBAAuB,EAAE,OAAO;AAAA,MAC9B,MAAM,EAAE,KAAK,sBAAsB,EAAE,SAAS,0BAA0B;AAAA,IAC1E,CAAC,EAAE,SAAS,+BAA+B;AAAA,EAC7C,CAAC,EAAE,SAAS,sCAAsC;AACpD,CAAC,EAAE,SAAS;AAEZ,IAAM,2BAA2B,EAAE,OAAO;AAAA,EACxC,SAAS,EAAE,OAAO,EAAE,OAAO,CAAC,EAAE,SAAS,EAAE;AAAA,IACvC;AAAA,EACF;AAAA,EACA,QAAQ,EAAE,OAAO,EAAE,OAAO,CAAC,EAAE,SAAS,EAAE;AAAA,IACtC;AAAA,EACF;AACF,CAAC,EAAE,SAAS,EAAE;AAAA,EACZ;AACF;AAMA,IAAM,gBAAgB,EAAE,OAAO,EAC5B,OAAO,oBAAoB,gDAAgD,EAC3E,SAAS,8DAA8D,EACvE,SAAS;AAEZ,IAAM,gBAAgB,EAAE,OAAO,EAC5B,OAAO,oBAAoB,gDAAgD,EAC3E,SAAS,4DAA4D,EACrE,SAAS;AAEZ,IAAM,iBAAiB,EAAE,OAAO,EAAE,SAAS,EAAE;AAAA,EAC3C;AACF;AAMA,IAAM,uBAAuB,CAAC,QAA0B;AACtD,MAAI,OAAO,QAAQ,SAAU,QAAO;AACpC,QAAM,UAAU,IAAI,KAAK;AACzB,MAAI,CAAC,QAAQ,WAAW,GAAG,KAAK,CAAC,QAAQ,SAAS,GAAG,EAAG,QAAO;AAE/D,MAAI;AAEF,QAAI,aAAa;AACjB,QAAI,WAAW,SAAS,GAAG,GAAG;AAC5B,mBAAa,WACV,QAAQ,WAAW,IAAI,EACvB,QAAQ,cAAc,MAAM,EAC5B,QAAQ,WAAW,IAAI;AAAA,IAC5B;AACA,UAAM,SAAS,KAAK,MAAM,UAAU;AACpC,QAAI,MAAM,QAAQ,MAAM,KAAK,OAAO,MAAM,UAAQ,OAAO,SAAS,QAAQ,GAAG;AAC3E,aAAO;AAAA,IACT;AAAA,EACF,QAAQ;AAAA,EAER;AACA,SAAO;AACT;AAEA,IAAM,eAAe,EAAE;AAAA,EACrB;AAAA,EACA,EAAE,MAAM,EAAE,KAAK,oBAAoB,CAAC;AACtC,EAAE,SAAS,EAAE;AAAA,EACX;AACF;AAEA,IAAM,yBAAyB,EAAE;AAAA,EAC/B;AAAA,EACA,EAAE,MAAM,EAAE,OAAO,CAAC;AACpB,EAAE,SAAS,EAAE;AAAA,EACX;AACF;AAEA,IAAM,mBAAmB,EAAE;AAAA,EACzB;AAAA,EACA,EAAE,MAAM,EAAE,OAAO,CAAC;AACpB,EAAE,SAAS,EAAE;AAAA,EACX;AACF;AAEA,IAAM,gCAAgC,EACnC,MAAM,EAAE,OAAO,EAAE,MAAM,iBAAiB,6BAA6B,CAAC,EACtE,SAAS,EACT;AAAA,EACC;AACF;AAEF,IAAM,+BAA+B,EAClC,MAAM,EAAE,OAAO,EAAE,MAAM,iBAAiB,6BAA6B,CAAC,EACtE,SAAS,EACT;AAAA,EACC;AACF;AAGF,IAAM,sBAAsB,EAAE,OAAO,EAClC,MAAM,sBAAsB,gGAAgG,EAC5H,SAAS,EACT;AAAA,EACC;AACF;AAGF,IAAM,iBAAiB;AAGvB,IAAM,qBAAqB,EAAE;AAAA,EAC3B;AAAA,EACA,EAAE,MAAM;AAAA,IACN,EAAE,OAAO,EACN,MAAM,gBAAgB,gGAAgG;AAAA,IACzH,EAAE,MAAM,EAAE,OAAO,EACd,MAAM,gBAAgB,gGAAgG,CAAC,EACvH,IAAI,GAAG,2CAA2C,EAClD,IAAI,IAAI,yCAAyC;AAAA,EACtD,CAAC;AACH,EACG,SAAS,EACT;AAAA,EACC;AACF;AAGK,IAAM,cAAc;AAAA,EACzB,kBAAkB,EAAE,OAAO;AAAA,IACzB,SAAS;AAAA,EACX,CAAC;AAAA,EAED,eAAe,EAAE,OAAO;AAAA,IACtB,SAAS;AAAA,IACT,YAAY,EAAE,MAAM;AAAA,MAClB,EAAE,OAAO,EAAE;AAAA,QACT;AAAA,MACF;AAAA,MACA,EAAE,MAAM,EAAE,OAAO,EAAE,IAAI,CAAC,CAAC,EACtB,IAAI,GAAG,sCAAsC,EAC7C,IAAI,IAAI,0CAA0C,EAClD;AAAA,QACC,CAAC,QAAQ,IAAI,IAAI,GAAG,EAAE,SAAS,IAAI;AAAA,QACnC;AAAA,MACF,EACC,SAAS,oEAAoE;AAAA,IAClF,CAAC;AAAA,IACD,SAAS;AAAA,IACT,SAAS;AAAA,IACT,UAAU;AAAA,IACV,QAAQ;AAAA,IACR,yBAAyB;AAAA,IACzB,wBAAwB;AAAA,EAC1B,CAAC;AAAA,EAED,iBAAiB,EAAE,OAAO;AAAA,IACxB,SAAS;AAAA,IACT,YAAY,EAAE,MAAM;AAAA,MAClB,EAAE,OAAO,EAAE;AAAA,QACT;AAAA,MACF;AAAA,MACA,EAAE,MAAM,EAAE,OAAO,CAAC;AAAA,IACpB,CAAC,EAAE,UAAU,CAAC,QAAQ;AACpB,UAAI,OAAO,QAAQ,UAAU;AAE3B,YAAI,IAAI,WAAW,GAAG,GAAG;AACvB,cAAI;AACF,kBAAM,SAAS,KAAK,MAAM,GAAG;AAC7B,gBAAI,MAAM,QAAQ,MAAM,EAAG,QAAO;AAAA,UACpC,QAAQ;AAAA,UAAe;AAAA,QACzB;AACA,eAAO;AAAA,MACT;AACA,aAAO;AAAA,IACT,CAAC,EAAE,SAAS,0GAA0G;AAAA,IACtH,OAAO,EAAE,OAAO,EAAE;AAAA,MAChB;AAAA,IACF;AAAA,IACA,SAAS,EAAE,OAAO,EACf,OAAO,oBAAoB,gDAAgD,EAC3E,SAAS,8DAA8D;AAAA,IAC1E,SAAS,EAAE,OAAO,EACf,OAAO,oBAAoB,gDAAgD,EAC3E,SAAS,4DAA4D;AAAA,IACxE,UAAU;AAAA,IACV,QAAQ,EAAE,MAAM,EAAE,KAAK,oBAAoB,CAAC,EAAE,SAAS,EAAE;AAAA,MACvD;AAAA,IACF;AAAA,IACA,yBAAyB,EACtB,MAAM,EAAE,OAAO,EAAE,MAAM,iBAAiB,6BAA6B,CAAC,EACtE,SAAS,EACT;AAAA,MACC;AAAA,IACF;AAAA,IACF,wBAAwB,EACrB,MAAM,EAAE,OAAO,EAAE,MAAM,iBAAiB,6BAA6B,CAAC,EACtE,SAAS,EACT;AAAA,MACC;AAAA,IACF;AAAA,EACJ,CAAC;AAAA,EAED,aAAa,EAAE,OAAO;AAAA,IACpB,SAAS;AAAA,IACT,YAAY,EAAE,OAAO,EAAE,SAAS,0DAA0D;AAAA,IAC1F,SAAS,EAAE,OAAO,EAAE,SAAS,6BAA6B;AAAA,IAC1D,QAAQ,EAAE,MAAM,EAAE,KAAK,oBAAoB,CAAC,EAAE,SAAS,EAAE;AAAA,MACvD;AAAA,IACF;AAAA,EACF,CAAC;AAAA,EAED,eAAe,EAAE,OAAO;AAAA,IACtB,SAAS;AAAA,EACX,CAAC;AAAA,EAED,gBAAgB,EAAE,OAAO;AAAA,IACvB,SAAS;AAAA,IACT,YAAY,EAAE,OAAO,EAAE,SAAS,0DAA0D;AAAA,IAC1F,SAAS,EAAE,OAAO,EAAE,SAAS,EAAE,SAAS,kKAAkK;AAAA,IAC1M,SAAS,EAAE,OAAO,EAAE,SAAS,oBAAoB;AAAA,IACjD,aAAa,EAAE,OAAO,EAAE,SAAS,EAAE,SAAS,iCAAiC;AAAA,IAC7E,OAAO,EAAE,OAAO,EACb,OAAO,0BAA0B,oGAAoG,EACrI,SAAS,yOAAyO;AAAA,IACrP,KAAK,EAAE,OAAO,EACX,OAAO,0BAA0B,oGAAoG,EACrI,SAAS,mPAAmP;AAAA,IAC/P,UAAU,EAAE,OAAO,EAAE,SAAS,EAAE;AAAA,MAC9B;AAAA,IACF;AAAA,IACA,UAAU,EAAE,OAAO,EAAE,SAAS,EAAE,SAAS,uBAAuB;AAAA,IAChE,WAAW,EAAE,MAAM,EAAE,OAAO;AAAA,MAC1B,OAAO,EAAE,OAAO,EAAE,MAAM,EAAE,SAAS,+BAA+B;AAAA,MAClE,aAAa,EAAE,OAAO,EAAE,SAAS,EAAE,SAAS,8BAA8B;AAAA,MAC1E,UAAU,EAAE,QAAQ,EAAE,SAAS,EAAE,SAAS,sCAAsC;AAAA,MAChF,gBAAgB,EAAE,KAAK,sBAAsB,EAAE,SAAS,EAAE,SAAS,4BAA4B;AAAA,MAC/F,SAAS,EAAE,OAAO,EAAE,SAAS,EAAE,SAAS,6BAA6B;AAAA,MACrE,kBAAkB,EAAE,OAAO,EAAE,IAAI,EAAE,IAAI,CAAC,EAAE,SAAS,EAAE,SAAS,sDAAsD;AAAA,IACtH,CAAC,CAAC,EAAE,SAAS,EAAE,SAAS,4CAA4C;AAAA,IACpE,SAAS,EAAE,OAAO,EAAE,SAAS,EAAE;AAAA,MAC7B;AAAA,IACF;AAAA,IACA,WAAW;AAAA,IACX,YAAY;AAAA,IACZ,cAAc,EAAE,KAAK,mBAAmB,EAAE,SAAS,EAAE;AAAA,MACnD;AAAA,IACF;AAAA,IACA,YAAY,EAAE,KAAK,iBAAiB,EAAE,SAAS,EAAE;AAAA,MAC/C;AAAA,IACF;AAAA,IACA,uBAAuB,EAAE,QAAQ,EAAE,SAAS,EAAE;AAAA,MAC5C;AAAA,IACF;AAAA,IACA,iBAAiB,EAAE,QAAQ,EAAE,SAAS,EAAE;AAAA,MACtC;AAAA,IACF;AAAA,IACA,yBAAyB,EAAE,QAAQ,EAAE,SAAS,EAAE;AAAA,MAC9C;AAAA,IACF;AAAA,IACA,kBAAkB,EAAE,QAAQ,EAAE,SAAS,EAAE;AAAA,MACvC;AAAA,IACF;AAAA,IACA,aAAa,EAAE,KAAK,mBAAmB,EAAE,SAAS,EAAE;AAAA,MAClD;AAAA,IACF;AAAA,IACA,gBAAgB,qBAAqB;AAAA,MACnC;AAAA,IACF;AAAA,IACA,oBAAoB;AAAA,IACpB,aAAa,EAAE,MAAM,EAAE,OAAO;AAAA,MAC5B,SAAS,EAAE,OAAO,EAAE,SAAS,0BAA0B;AAAA,MACvD,OAAO,EAAE,OAAO,EAAE,SAAS,EAAE,SAAS,yBAAyB;AAAA,MAC/D,UAAU,EAAE,OAAO,EAAE,SAAS,EAAE,SAAS,6BAA6B;AAAA,MACtE,UAAU,EAAE,OAAO,EAAE,SAAS,EAAE,SAAS,oCAAoC;AAAA,MAC7E,QAAQ,EAAE,OAAO,EAAE,SAAS,EAAE,SAAS,yCAAyC;AAAA,IAClF,CAAC,CAAC,EAAE,SAAS,EAAE;AAAA,MACb;AAAA,IACF;AAAA,IACA,QAAQ,EAAE,OAAO;AAAA,MACf,KAAK,EAAE,OAAO,EAAE,SAAS,mBAAmB;AAAA,MAC5C,OAAO,EAAE,OAAO,EAAE,SAAS,qBAAqB;AAAA,IAClD,CAAC,EAAE,SAAS,EAAE;AAAA,MACZ;AAAA,IACF;AAAA,IACA,kBAAkB;AAAA,IAClB,8BAA8B,EAAE,OAAO,EAAE,IAAI,CAAC,EAAE,IAAI,CAAC,EAAE,SAAS,EAAE;AAAA,MAChE;AAAA,IACF;AAAA,IACA,iBAAiB,EAAE,QAAQ,EAAE,SAAS,EAAE;AAAA,MACtC;AAAA,IACF;AAAA,IACA,WAAW,EAAE,KAAK,CAAC,WAAW,aAAa,eAAe,iBAAiB,CAAC,EAAE,SAAS,EAAE;AAAA,MACvF;AAAA,IACF;AAAA,IACA,qBAAqB,EAAE,OAAO;AAAA,MAC5B,iBAAiB,EAAE,KAAK,wBAAwB,EAAE,SAAS,EAAE,SAAS,8CAA8C;AAAA,MACpH,YAAY,EAAE,KAAK,CAAC,aAAa,cAAc,CAAC,EAAE,SAAS,EACxD,SAAS,+BAA+B;AAAA,MAC3C,gBAAgB,EAAE,OAAO,EAAE,SAAS,EACjC,SAAS,yCAAyC;AAAA,IACvD,CAAC,EAAE,SAAS,EAAE;AAAA,MACZ;AAAA,IACF;AAAA,IACA,uBAAuB,EAAE,OAAO;AAAA,MAC9B,iBAAiB,EAAE,KAAK,wBAAwB,EAAE,SAAS,EAAE,QAAQ,kCAAkC,EACpG,SAAS,0EAA0E;AAAA,MACtF,gBAAgB,EAAE,OAAO,EAAE,SAAS,EACjC,SAAS,iGAAiG;AAAA,IAC/G,CAAC,EAAE,SAAS,EAAE;AAAA,MACZ;AAAA,IACF;AAAA,IACA,2BAA2B,EAAE,OAAO;AAAA,MAClC,MAAM,EAAE,KAAK,CAAC,cAAc,kBAAkB,gBAAgB,CAAC,EAC5D,SAAS,0BAA0B;AAAA,MACtC,YAAY,EAAE,OAAO,CAAC,CAAC,EAAE,SAAS,EAC/B,SAAS,mCAAmC;AAAA,MAC/C,gBAAgB,EAAE,OAAO;AAAA,QACvB,OAAO,EAAE,OAAO,EAAE,SAAS,EAAE,SAAS,mEAAmE;AAAA,QACzG,YAAY,EAAE,OAAO,EAAE,SAAS,EAAE,SAAS,mDAAmD;AAAA,QAC9F,SAAS,EAAE,OAAO,EAAE,SAAS,EAAE,SAAS,kBAAkB;AAAA,QAC1D,gBAAgB,EAAE,OAAO,EAAE,SAAS,EAAE,SAAS,0BAA0B;AAAA,QACzE,QAAQ,EAAE,OAAO,EAAE,SAAS,EAAE,SAAS,iBAAiB;AAAA,MAC1D,CAAC,EAAE,SAAS,EAAE,SAAS,yBAAyB;AAAA,MAChD,gBAAgB,EAAE,OAAO;AAAA,QACvB,OAAO,EAAE,OAAO,EAAE,SAAS,EAAE,SAAS,gEAAgE;AAAA,MACxG,CAAC,EAAE,SAAS,EAAE,SAAS,yBAAyB;AAAA,IAClD,CAAC,EAAE,SAAS,EAAE;AAAA,MACZ;AAAA,IACF;AAAA,EACF,CAAC,EAAE;AAAA,IACD,CAAC,SAAS;AAER,UAAI,KAAK,cAAc,eAAe,KAAK,cAAc,eAAe;AACtE,YAAI,cAAc,KAAK,KAAK,KAAK,KAAK,cAAc,KAAK,KAAK,GAAG,GAAG;AAClE,iBAAO;AAAA,QACT;AAAA,MACF;AACA,aAAO;AAAA,IACT;AAAA,IACA;AAAA,MACE,SAAS;AAAA,MACT,MAAM,CAAC,WAAW;AAAA,IACpB;AAAA,EACF;AAAA,EAEA,gBAAgB,EAAE,OAAO;AAAA,IACvB,SAAS;AAAA,IACT,YAAY,EAAE,OAAO,EAAE,SAAS,0DAA0D;AAAA,IAC1F,SAAS,EAAE,OAAO,EAAE,SAAS,2BAA2B;AAAA,IACxD,SAAS,EAAE,OAAO,EAAE,SAAS,EAAE,SAAS,4BAA4B;AAAA,IACpE,aAAa,EAAE,OAAO,EAAE,SAAS,EAAE,SAAS,2BAA2B;AAAA,IACvE,OAAO,EAAE,OAAO,EACb,OAAO,0BAA0B,oGAAoG,EACrI,SAAS,2OAA2O,EACpP,SAAS;AAAA,IACZ,KAAK,EAAE,OAAO,EACX,OAAO,0BAA0B,oGAAoG,EACrI,SAAS,qPAAqP,EAC9P,SAAS;AAAA,IACZ,UAAU,EAAE,OAAO,EAAE,SAAS,EAAE,SAAS,0GAA0G;AAAA,IACnJ,UAAU,EAAE,OAAO,EAAE,SAAS,EAAE,SAAS,kBAAkB;AAAA,IAC3D,WAAW,EAAE,MAAM,EAAE,OAAO;AAAA,MAC1B,OAAO,EAAE,OAAO,EAAE,MAAM,EAAE,SAAS,+BAA+B;AAAA,IACpE,CAAC,CAAC,EAAE,SAAS,EAAE,SAAS,uBAAuB;AAAA,IAC/C,SAAS,EAAE,OAAO,EAAE,SAAS,EAAE,SAAS,kBAAkB;AAAA,IAC1D,WAAW;AAAA,IACX,YAAY;AAAA,IACZ,aAAa,EAAE,KAAK,mBAAmB,EAAE,QAAQ,KAAK,EAAE;AAAA,MACtD;AAAA,IACF;AAAA,IACA,mBAAmB,EAAE,KAAK,CAAC,oBAAoB,OAAO,eAAe,CAAC,EAAE,SAAS,EAAE;AAAA,MACjF;AAAA,IACF;AAAA,IACA,mBAAmB,EAAE,OAAO,EACzB,OAAO,oBAAoB,gDAAgD,EAC3E,SAAS,kEAAkE,EAC3E,SAAS;AAAA,IACZ,iBAAiB,EAAE,OAAO,EACvB,OAAO,oBAAoB,gDAAgD,EAC3E,SAAS,8EAA8E,EACvF,SAAS;AAAA,IACZ,gBAAgB,EAAE,QAAQ,EAAE,SAAS,EAAE;AAAA,MACrC;AAAA,IACF;AAAA,IACA,kBAAkB;AAAA,IAClB,gBAAgB,qBAAqB,SAAS,+EAA+E;AAAA,IAC7H,cAAc,EAAE,KAAK,mBAAmB,EAAE,SAAS,EAAE;AAAA,MACnD;AAAA,IACF;AAAA,IACA,YAAY,EAAE,KAAK,iBAAiB,EAAE,SAAS,EAAE;AAAA,MAC/C;AAAA,IACF;AAAA,IACA,uBAAuB,EAAE,QAAQ,EAAE,SAAS,EAAE;AAAA,MAC5C;AAAA,IACF;AAAA,IACA,iBAAiB,EAAE,QAAQ,EAAE,SAAS,EAAE;AAAA,MACtC;AAAA,IACF;AAAA,IACA,yBAAyB,EAAE,QAAQ,EAAE,SAAS,EAAE;AAAA,MAC9C;AAAA,IACF;AAAA,IACA,kBAAkB,EAAE,QAAQ,EAAE,SAAS,EAAE;AAAA,MACvC;AAAA,IACF;AAAA,IACA,oBAAoB;AAAA,IACpB,aAAa,EAAE,MAAM,EAAE,OAAO;AAAA,MAC5B,SAAS,EAAE,OAAO,EAAE,IAAI,EAAE,SAAS,4BAA4B;AAAA,MAC/D,OAAO,EAAE,OAAO,EAAE,SAAS,yBAAyB;AAAA,MACpD,UAAU,EAAE,OAAO,EAAE,SAAS,EAAE,SAAS,6BAA6B;AAAA,MACtE,UAAU,EAAE,OAAO,EAAE,SAAS,EAAE,SAAS,mCAAmC;AAAA,MAC5E,QAAQ,EAAE,OAAO,EAAE,SAAS,EAAE,SAAS,sCAAsC;AAAA,IAC/E,CAAC,CAAC,EAAE,SAAS,EAAE,SAAS,gCAAgC;AAAA;AAAA,EAE1D,CAAC,EAAE;AAAA,IACD,CAAC,SAAS;AAER,UAAI,KAAK,sBAAsB,mBAAmB,CAAC,KAAK,mBAAmB;AACzE,eAAO;AAAA,MACT;AACA,aAAO;AAAA,IACT;AAAA,IACA;AAAA,MACE,SAAS;AAAA,MACT,MAAM,CAAC,mBAAmB;AAAA,IAC5B;AAAA,EACF,EAAE;AAAA,IACA,CAAC,SAAS;AAER,UAAI,KAAK,sBAAsB,sBAAsB,CAAC,KAAK,iBAAiB;AAC1E,eAAO;AAAA,MACT;AACA,aAAO;AAAA,IACT;AAAA,IACA;AAAA,MACE,SAAS;AAAA,MACT,MAAM,CAAC,iBAAiB;AAAA,IAC1B;AAAA,EACF,EAAE;AAAA,IACA,CAAC,SAAS;AAER,UAAI,KAAK,iBAAiB;AACxB,cAAM,aAAa,IAAI,KAAK,KAAK,eAAe;AAChD,cAAM,MAAM,oBAAI,KAAK;AACrB,eAAO,aAAa;AAAA,MACtB;AACA,aAAO;AAAA,IACT;AAAA,IACA;AAAA,MACE,SAAS;AAAA,MACT,MAAM,CAAC,iBAAiB;AAAA,IAC1B;AAAA,EACF;AAAA,EAEA,gBAAgB,EAAE,OAAO;AAAA,IACvB,SAAS;AAAA,IACT,YAAY,EAAE,OAAO,EAAE,SAAS,0DAA0D;AAAA,IAC1F,SAAS,EAAE,OAAO,EAAE,SAAS,2BAA2B;AAAA,IACxD,aAAa,EAAE,KAAK,mBAAmB,EAAE,QAAQ,KAAK,EAAE;AAAA,MACtD;AAAA,IACF;AAAA,EACF,CAAC;AAAA,EAED,gBAAgB,EAAE,OAAO;AAAA,IACvB,SAAS,mBAAmB;AAAA,MAC1B;AAAA,IACF;AAAA,IACA,WAAW,EAAE,MAAM,EAAE,OAAO;AAAA,MAC1B,IAAI,EAAE,OAAO,EAAE,SAAS,0DAA0D;AAAA,IACpF,CAAC,CAAC,EAAE;AAAA,MACF;AAAA,IACF;AAAA,IACA,SAAS,EAAE,OAAO,EACf,OAAO,oBAAoB,gDAAgD,EAC3E,SAAS,8DAA8D;AAAA,IAC1E,SAAS,EAAE,OAAO,EACf,OAAO,oBAAoB,gDAAgD,EAC3E,SAAS,4DAA4D;AAAA,IACxE,UAAU,EAAE,OAAO,EAAE,SAAS,EAAE,SAAS,8BAA8B;AAAA,IACvE,mBAAmB,EAAE,OAAO,EAAE,IAAI,EAAE,IAAI,GAAG,EAAE,SAAS,EAAE;AAAA,MACtD;AAAA,IACF;AAAA,IACA,sBAAsB,EAAE,OAAO,EAAE,IAAI,EAAE,IAAI,EAAE,EAAE,SAAS,EAAE;AAAA,MACxD;AAAA,IACF;AAAA,EACF,CAAC;AAAA,EAED,oBAAoB,EAAE,OAAO;AAAA,IAC3B,SAAS;AAAA,IACT,UAAU,EAAE,OAAO,EAAE,SAAS,EAAE;AAAA,MAC9B;AAAA,IACF;AAAA,EACF,CAAC;AAAA,EAED,oBAAoB,EAAE,OAAO;AAAA,IAC3B,YAAY,EAAE,OAAO,EAAE,SAAS,0DAA0D;AAAA,IAC1F,SAAS,EAAE,OAAO,EAAE,SAAS,+BAA+B;AAAA,IAC5D,SAAS,EAAE,OAAO,EAAE,SAAS,EAAE;AAAA,MAC7B;AAAA,IACF;AAAA,IACA,UAAU,EAAE,KAAK,sBAAsB,EAAE;AAAA,MACvC;AAAA,IACF;AAAA,IACA,SAAS,EAAE,OAAO,EAAE,SAAS,EAAE;AAAA,MAC7B;AAAA,IACF;AAAA,IACA,mBAAmB,EAAE,KAAK,CAAC,iBAAiB,KAAK,CAAC,EAAE,SAAS,EAAE;AAAA,MAC7D;AAAA,IACF;AAAA,IACA,mBAAmB,EAAE,OAAO,EACzB,OAAO,oBAAoB,gDAAgD,EAC3E,SAAS,mGAAmG,EAC5G,SAAS;AAAA,IACZ,aAAa,EAAE,KAAK,mBAAmB,EAAE,SAAS,EAAE;AAAA,MAClD;AAAA,IACF;AAAA,EACF,CAAC,EAAE;AAAA,IACD,CAAC,SAAS;AAER,UAAI,KAAK,sBAAsB,mBAAmB,CAAC,KAAK,mBAAmB;AACzE,eAAO;AAAA,MACT;AACA,aAAO;AAAA,IACT;AAAA,IACA;AAAA,MACE,SAAS;AAAA,MACT,MAAM,CAAC,mBAAmB;AAAA,IAC5B;AAAA,EACF;AACF;AA8BO,IAAM,eAAN,MAAmB;AAAA,EACxB,OAAe,mBAAmB,QAA6B;AAC7D,UAAM,YAAY;AAGlB,QAAI,UAAU,QAAQ,UAAU,KAAK,aAAa,cAAc;AAC9D,aAAO,KAAK,mBAAmB,UAAU,KAAK,MAAM;AAAA,IACtD;AAGA,QAAI,WAAW,WAAW;AACxB,aAAO,UAAU;AAAA,IACnB;AAGA,QAAI,UAAU,QAAQ,UAAU,KAAK,QAAQ;AAC3C,aAAO,KAAK,mBAAmB,UAAU,KAAK,MAAM;AAAA,IACtD;AAGA,WAAO,UAAU,MAAM,QAAQ,SAAS,UAAU;AAAA,EACpD;AAAA,EAEA,OAAe,QAA0B;AAAA,IACvC;AAAA,MACE,MAAM;AAAA,MACN,aAAa;AAAA,MACb,QAAQ,YAAY,gBAAgB;AAAA,MACpC,SAAS;AAAA,IACX;AAAA,IACA;AAAA,MACE,MAAM;AAAA,MACN,aAAa;AAAA,MACb,QAAQ,YAAY,aAAa;AAAA,MACjC,SAAS;AAAA,MACT,iBAAiB,OAAO,SAA8D;AACpF,YAAI,sBAAyC,KAAK;AAGlD,YAAI,MAAM,QAAQ,KAAK,UAAU,GAAG;AAClC,gCAAsB,KAAK;AAAA,QAC7B,WAES,OAAO,KAAK,eAAe,YAAY,KAAK,WAAW,KAAK,EAAE,WAAW,GAAG,KAAK,KAAK,WAAW,KAAK,EAAE,SAAS,GAAG,GAAG;AAC9H,cAAI;AACF,gBAAI,aAAa,KAAK,WAAW,KAAK;AAKtC,gBAAI,WAAW,SAAS,GAAG,GAAG;AAC5B,2BAAa,WACV,QAAQ,WAAW,IAAI,EACvB,QAAQ,cAAc,MAAM,EAC5B,QAAQ,WAAW,IAAI;AAAA,YAC5B;AAEA,kBAAM,SAAS,KAAK,MAAM,UAAU;AAGpC,gBAAI,CAAC,MAAM,QAAQ,MAAM,GAAG;AAC1B,oBAAM,IAAI,MAAM,mCAAmC;AAAA,YACrD;AACA,gBAAI,CAAC,OAAO,MAAM,QAAM,OAAO,OAAO,YAAY,GAAG,SAAS,CAAC,GAAG;AAChE,oBAAM,IAAI,MAAM,2CAA2C;AAAA,YAC7D;AACA,gBAAI,OAAO,WAAW,GAAG;AACvB,oBAAM,IAAI,MAAM,sCAAsC;AAAA,YACxD;AACA,gBAAI,OAAO,SAAS,IAAI;AACtB,oBAAM,IAAI,MAAM,8BAA8B;AAAA,YAChD;AACA,gBAAI,IAAI,IAAI,MAAM,EAAE,SAAS,OAAO,QAAQ;AAC1C,oBAAM,IAAI,MAAM,wCAAwC;AAAA,YAC1D;AAEA,kCAAsB;AAAA,UACxB,SAAS,OAAO;AACd,kBAAM,IAAI;AAAA,cACR,uCAAuC,iBAAiB,QAAQ,MAAM,UAAU,uBAAuB;AAAA,YACzG;AAAA,UACF;AAAA,QACF;AAGA,eAAO;AAAA,UACL,SAAS,KAAK;AAAA,UACd,YAAY;AAAA,UACZ,SAAS,KAAK;AAAA,UACd,SAAS,KAAK;AAAA,UACd,UAAU,KAAK;AAAA,UACf,QAAQ,KAAK;AAAA,UACb,yBAAyB,KAAK;AAAA,UAC9B,wBAAwB,KAAK;AAAA,QAC/B;AAAA,MACF;AAAA,IACF;AAAA,IACA;AAAA,MACE,MAAM;AAAA,MACN,aAAa;AAAA,MACb,QAAQ,YAAY,eAAe;AAAA,MACnC,SAAS;AAAA,IACX;AAAA,IACA;AAAA,MACE,MAAM;AAAA,MACN,aAAa;AAAA,MACb,QAAQ,YAAY,WAAW;AAAA,MAC/B,SAAS;AAAA,IACX;AAAA,IACA;AAAA,MACE,MAAM;AAAA,MACN,aAAa;AAAA,MACb,QAAQ,YAAY,aAAa;AAAA,MACjC,SAAS;AAAA,IACX;AAAA,IACA;AAAA,MACE,MAAM;AAAA,MACN,aAAa;AAAA,MACb,QAAQ,YAAY,cAAc;AAAA,MAClC,SAAS;AAAA,IACX;AAAA,IACA;AAAA,MACE,MAAM;AAAA,MACN,aAAa;AAAA,MACb,QAAQ,YAAY,cAAc;AAAA,MAClC,SAAS;AAAA,IACX;AAAA,IACA;AAAA,MACE,MAAM;AAAA,MACN,aAAa;AAAA,MACb,QAAQ,YAAY,cAAc;AAAA,MAClC,SAAS;AAAA,IACX;AAAA,IACA;AAAA,MACE,MAAM;AAAA,MACN,aAAa;AAAA,MACb,QAAQ,YAAY,cAAc;AAAA,MAClC,SAAS;AAAA,IACX;AAAA,IACA;AAAA,MACE,MAAM;AAAA,MACN,aAAa;AAAA,MACb,QAAQ,YAAY,kBAAkB;AAAA,MACtC,SAAS;AAAA,IACX;AAAA,IACA;AAAA,MACE,MAAM;AAAA,MACN,aAAa;AAAA,MACb,QAAQ,YAAY,kBAAkB;AAAA,MACtC,SAAS;AAAA,IACX;AAAA,EACF;AAAA,EAEA,OAAO,sBAAsB;AAC3B,WAAO,KAAK,MAAM,IAAI,UAAQ;AAC5B,YAAM,aAAa,KAAK,oBACpB,gBAAgB,EAAE,OAAO,KAAK,iBAAiB,CAAC,IAChD,gBAAgB,KAAK,MAAM;AAC/B,aAAO;AAAA,QACL,MAAM,KAAK;AAAA,QACX,aAAa,KAAK;AAAA,QAClB,aAAa;AAAA,MACf;AAAA,IACF,CAAC;AAAA,EACH;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,OAAe,wBAAwB,UAAkB,MAAgB;AAEvE,UAAM,oBAAoB,CAAC,gBAAgB,cAAc;AACzD,QAAI,CAAC,kBAAkB,SAAS,QAAQ,GAAG;AACzC,aAAO;AAAA,IACT;AAEA,UAAM,aAAa,EAAE,GAAG,KAAK;AAC7B,UAAM,iBAAiB,CAAC,SAAS,OAAO,qBAAqB,iBAAiB;AAE9E,eAAW,SAAS,gBAAgB;AAClC,UAAI,WAAW,KAAK,KAAK,OAAO,WAAW,KAAK,MAAM,UAAU;AAC9D,cAAM,MAAM,WAAW,KAAK;AAE5B,YAAI,IAAI,MAAM;AACZ,qBAAW,KAAK,IAAI,IAAI;AAAA,QAC1B,WAAW,IAAI,UAAU;AACvB,qBAAW,KAAK,IAAI,IAAI;AAAA,QAC1B;AAAA,MACF;AAAA,IACF;AAEA,WAAO;AAAA,EACT;AAAA;AAAA;AAAA;AAAA,EAKA,OAAO,wBAAkC;AACvC,WAAO,KAAK,MAAM,IAAI,OAAK,EAAE,IAAI;AAAA,EACnC;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,OAAO,kBAAkB,WAA2B;AAClD,UAAM,iBAAiB,oBAAI,IAAI,CAAC,GAAG,KAAK,sBAAsB,GAAG,iBAAiB,CAAC;AACnF,UAAM,eAAe,UAAU,OAAO,UAAQ,CAAC,eAAe,IAAI,IAAI,CAAC;AAEvE,QAAI,aAAa,SAAS,GAAG;AAC3B,YAAM,YAAY,CAAC,GAAG,KAAK,sBAAsB,GAAG,iBAAiB,EAAE,KAAK,IAAI;AAChF,YAAM,IAAI;AAAA,QACR,yBAAyB,aAAa,KAAK,IAAI,CAAC,sBAC5B,SAAS;AAAA,MAC/B;AAAA,IACF;AAAA,EACF;AAAA,EAEA,aAAa,YACX,QACA,oBAIA,QACA;AAEA,QAAI,QAAQ,cAAc;AACxB,UAAI,OAAO,aAAa,WAAW,GAAG;AACpC,cAAM,IAAI,MAAM,8DAA8D;AAAA,MAChF;AACA,WAAK,kBAAkB,OAAO,YAAY;AAC1C,YAAM,aAAa,IAAI,IAAI,OAAO,YAAY;AAC9C,cAAQ,OAAO,MAAM,2BAA2B,OAAO,aAAa,KAAK,IAAI,CAAC;AAAA,CAAI;AAGlF,iBAAW,QAAQ,KAAK,OAAO;AAC7B,YAAI,CAAC,WAAW,IAAI,KAAK,IAAI,GAAG;AAC9B;AAAA,QACF;AACA,aAAK,mBAAmB,QAAQ,MAAM,kBAAkB;AAAA,MAC1D;AACA;AAAA,IACF;AAGA,eAAW,QAAQ,KAAK,OAAO;AAC7B,WAAK,mBAAmB,QAAQ,MAAM,kBAAkB;AAAA,IAC1D;AAAA,EACF;AAAA,EAEA,OAAe,mBACb,QACA,MACA,oBAIA;AAEA,WAAO;AAAA,MACH,KAAK;AAAA,MACL;AAAA,QACE,aAAa,KAAK;AAAA,QAClB,aAAa,KAAK,qBAAqB,KAAK,mBAAmB,KAAK,MAAM;AAAA,MAC5E;AAAA,MACA,OAAO,SAAc;AAGnB,cAAM,iBAAiB,KAAK,wBAAwB,KAAK,MAAM,IAAI;AAGnE,cAAM,gBAAgB,KAAK,OAAO,MAAM,cAAc;AAGtD,cAAM,gBAAgB,KAAK,kBAAkB,MAAM,KAAK,gBAAgB,aAAa,IAAI;AAGzF,cAAM,UAAU,IAAI,KAAK,QAAQ;AACjC,eAAO,mBAAmB,SAAS,aAAa;AAAA,MAClD;AAAA,IACF;AAAA,EACJ;AACF;;;AyBz4BA;AALA,SAAS,YAAAC,WAAU,aAAAC,kBAAiB;AAEpC,SAAS,UAAAC,eAAc;AAkChB,IAAM,wBAAN,MAA4B;AAAA,EACjC,MAAM,QAAQ,MAA0B,SAAiD;AACvF,YAAQ,KAAK,QAAQ;AAAA,MACnB,KAAK;AACH,eAAO,KAAK,aAAa,KAAK,YAAY,OAAO;AAAA,MACnD,KAAK;AACH,eAAO,KAAK,WAAW,KAAK,YAAY,OAAO;AAAA,MACjD,KAAK;AACH,eAAO,KAAK,cAAc,KAAK,YAAY,OAAO;AAAA,MACpD;AACE,cAAM,IAAIF;AAAA,UACRC,WAAU;AAAA,UACV,mBAAmB,KAAK,MAAM;AAAA,QAChC;AAAA,IACJ;AAAA,EACF;AAAA;AAAA,EAGA,MAAc,aAAaE,YAA+B,SAAiD;AAEzG,UAAM,WAAW,MAAM,QAAQ,eAAe;AAG9C,QAAIA,YAAW;AACb,YAAM,eAAeA,WAAU,YAAY;AAC3C,YAAM,SAAS,SAAS,IAAI,YAAY;AAExC,UAAI,CAAC,QAAQ;AACX,cAAM,oBAAoB,MAAM,KAAK,SAAS,KAAK,CAAC,EAAE,KAAK,IAAI,KAAK;AACpE,cAAM,IAAIH;AAAA,UACRC,WAAU;AAAA,UACV,YAAY,YAAY,oCAAoC,iBAAiB;AAAA,QAC/E;AAAA,MACF;AAEA,YAAM,cAAc,MAAM,KAAK,eAAe,cAAc,MAAM;AAElE,YAAMG,YAAkC;AAAA,QACtC,UAAU,CAAC,WAAW;AAAA,QACtB,gBAAgB;AAAA,QAChB,SAAS,kBAAkB,YAAY;AAAA,MACzC;AAEA,aAAO;AAAA,QACL,SAAS,CAAC;AAAA,UACR,MAAM;AAAA,UACN,MAAM,KAAK,UAAUA,WAAU,MAAM,CAAC;AAAA,QACxC,CAAC;AAAA,MACH;AAAA,IACF;AAGA,QAAI,SAAS,SAAS,GAAG;AACvB,YAAMA,YAAkC;AAAA,QACtC,UAAU,CAAC;AAAA,QACX,gBAAgB;AAAA,QAChB,SAAS;AAAA,MACX;AAEA,aAAO;AAAA,QACL,SAAS,CAAC;AAAA,UACR,MAAM;AAAA,UACN,MAAM,KAAK,UAAUA,WAAU,MAAM,CAAC;AAAA,QACxC,CAAC;AAAA,MACH;AAAA,IACF;AAEA,UAAM,eAA8B,CAAC;AACrC,UAAM,SAAmB,CAAC;AAE1B,eAAW,CAAC,OAAO,MAAM,KAAK,UAAU;AACtC,UAAI;AACF,cAAM,OAAO,MAAM,KAAK,eAAe,OAAO,MAAM;AACpD,qBAAa,KAAK,IAAI;AAAA,MACxB,SAAS,OAAO;AACd,eAAO,KAAK,GAAG,KAAK,KAAK,iBAAiB,QAAQ,MAAM,UAAU,eAAe,EAAE;AACnF,qBAAa,KAAK;AAAA,UAChB,YAAY;AAAA,UACZ,QAAQ;AAAA,UACR,OAAO,iBAAiB,QAAQ,MAAM,UAAU;AAAA,QAClD,CAAC;AAAA,MACH;AAAA,IACF;AAEA,UAAM,WAAkC;AAAA,MACtC,UAAU;AAAA,MACV,gBAAgB,aAAa;AAAA,MAC7B,SAAS,OAAO,SAAS,IACrB,SAAS,aAAa,MAAM,oBAAoB,OAAO,MAAM,cAC7D,SAAS,aAAa,MAAM;AAAA,IAClC;AAEA,WAAO;AAAA,MACL,SAAS,CAAC;AAAA,QACR,MAAM;AAAA,QACN,MAAM,KAAK,UAAU,UAAU,MAAM,CAAC;AAAA,MACxC,CAAC;AAAA,IACH;AAAA,EACF;AAAA,EAEA,MAAc,eAAeD,YAAmB,QAA4C;AAC1F,QAAI;AACF,YAAM,WAAWD,QAAO,SAAS,EAAE,SAAS,MAAM,MAAM,OAAO,CAAC;AAEhE,YAAM,eAAe,MAAM,SAAS,aAAa,KAAK;AACtD,YAAM,YAAY,aAAa,KAAK,SAAS,CAAC;AAC9C,YAAM,kBAAkB,UAAU,KAAK,OAAK,EAAE,OAAO;AAErD,YAAM,cAAc,OAAO;AAC3B,YAAM,aAAa,YAAY;AAC/B,YAAM,YAAY,aAAa,KAAK,IAAI,IAAI,aAAa;AAEzD,YAAM,QAAQ,iBAAiB,MAAM;AAErC,aAAO;AAAA,QACL,YAAYC;AAAA,QACZ,QAAQ,YAAY,YAAY;AAAA,QAChC;AAAA,QACA,gBAAgB,UAAU;AAAA,QAC1B,kBAAkB,kBAAkB;AAAA,UAClC,IAAI,gBAAgB,MAAM;AAAA,UAC1B,MAAM,gBAAgB,WAAW;AAAA,UACjC,UAAU,gBAAgB,YAAY;AAAA,QACxC,IAAI;AAAA,QACJ,cAAc,aAAa,IAAI,KAAK,UAAU,EAAE,YAAY,IAAI;AAAA,MAClE;AAAA,IACF,SAAS,OAAO;AACd,YAAM,cAAc,OAAO;AAC3B,aAAO;AAAA,QACL,YAAYA;AAAA,QACZ,QAAQ,YAAY,gBAAgB,WAAW;AAAA,QAC/C,OAAO,iBAAiB,QAAQ,MAAM,UAAU;AAAA,MAClD;AAAA,IACF;AAAA,EACF;AAAA;AAAA,EAGA,MAAc,WAAWA,YAA+B,SAAiD;AACvG,QAAI,CAACA,YAAW;AACd,YAAM,IAAIH;AAAA,QACRC,WAAU;AAAA,QACV;AAAA,MACF;AAAA,IACF;AAEA,UAAM,eAAeE,WAAU,YAAY;AAG3C,QAAI;AACF,wBAAkB,YAAY;AAAA,IAChC,SAAS,OAAO;AACd,YAAM,IAAIH;AAAA,QACRC,WAAU;AAAA,QACV,iBAAiB,QAAQ,MAAM,UAAU;AAAA,MAC3C;AAAA,IACF;AAGA,QAAI,QAAQ,SAAS,IAAI,YAAY,GAAG;AACtC,YAAM,WAA+B;AAAA,QACnC,QAAQ;AAAA,QACR,YAAY;AAAA,QACZ,SAAS,6BAA6B,YAAY;AAAA,MACpD;AAEA,aAAO;AAAA,QACL,SAAS,CAAC;AAAA,UACR,MAAM;AAAA,UACN,MAAM,KAAK,UAAU,UAAU,MAAM,CAAC;AAAA,QACxC,CAAC;AAAA,MACH;AAAA,IACF;AAGA,YAAQ,IAAI,sBAAsB;AAClC,YAAQ,aAAa,eAAe,YAAY;AAGhD,QAAI;AACF,YAAM,UAAU,MAAM,QAAQ,WAAW,gBAAgB,YAAY;AAErE,UAAI,CAAC,QAAQ,SAAS;AACpB,cAAM,IAAID;AAAA,UACRC,WAAU;AAAA,UACV,QAAQ,SAAS;AAAA,QACnB;AAAA,MACF;AAEA,YAAM,WAA+B;AAAA,QACnC,QAAQ;AAAA,QACR,YAAY;AAAA,QACZ,UAAU,QAAQ;AAAA,QAClB,cAAc,QAAQ;AAAA,QACtB,cAAc,4GAA4G,YAAY;AAAA,QACtI,oBAAoB;AAAA,QACpB,WAAW;AAAA,MACb;AAEA,aAAO;AAAA,QACL,SAAS,CAAC;AAAA,UACR,MAAM;AAAA,UACN,MAAM,KAAK,UAAU,UAAU,MAAM,CAAC;AAAA,QACxC,CAAC;AAAA,MACH;AAAA,IACF,SAAS,OAAO;AACd,UAAI,iBAAiBD,WAAU;AAC7B,cAAM;AAAA,MACR;AACA,YAAM,IAAIA;AAAA,QACRC,WAAU;AAAA,QACV,mCAAmC,iBAAiB,QAAQ,MAAM,UAAU,eAAe;AAAA,MAC7F;AAAA,IACF;AAAA,EACF;AAAA;AAAA,EAGA,MAAc,cAAcE,YAA+B,SAAiD;AAC1G,QAAI,CAACA,YAAW;AACd,YAAM,IAAIH;AAAA,QACRC,WAAU;AAAA,QACV;AAAA,MACF;AAAA,IACF;AAEA,UAAM,eAAeE,WAAU,YAAY;AAG3C,QAAI;AACF,wBAAkB,YAAY;AAAA,IAChC,SAAS,OAAO;AACd,YAAM,IAAIH;AAAA,QACRC,WAAU;AAAA,QACV,iBAAiB,QAAQ,MAAM,UAAU;AAAA,MAC3C;AAAA,IACF;AAGA,UAAM,WAAW,MAAM,QAAQ,eAAe;AAG9C,QAAI,CAAC,SAAS,IAAI,YAAY,GAAG;AAC/B,YAAM,oBAAoB,MAAM,KAAK,SAAS,KAAK,CAAC,EAAE,KAAK,IAAI,KAAK;AACpE,YAAM,IAAID;AAAA,QACRC,WAAU;AAAA,QACV,YAAY,YAAY,oCAAoC,iBAAiB;AAAA,MAC/E;AAAA,IACF;AAGA,QAAI,SAAS,SAAS,GAAG;AACvB,YAAM,IAAID;AAAA,QACRC,WAAU;AAAA,QACV;AAAA,MACF;AAAA,IACF;AAGA,QAAI;AACF,YAAM,QAAQ,aAAa,cAAc,YAAY;AAGrD,YAAM,kBAAkB,MAAM,QAAQ,eAAe;AACrD,YAAM,oBAAoB,MAAM,KAAK,gBAAgB,KAAK,CAAC;AAE3D,YAAM,WAAkC;AAAA,QACtC,SAAS;AAAA,QACT,YAAY;AAAA,QACZ,SAAS,YAAY,YAAY;AAAA,QACjC,oBAAoB;AAAA,MACtB;AAEA,aAAO;AAAA,QACL,SAAS,CAAC;AAAA,UACR,MAAM;AAAA,UACN,MAAM,KAAK,UAAU,UAAU,MAAM,CAAC;AAAA,QACxC,CAAC;AAAA,MACH;AAAA,IACF,SAAS,OAAO;AACd,YAAM,IAAID;AAAA,QACRC,WAAU;AAAA,QACV,6BAA6B,iBAAiB,QAAQ,MAAM,UAAU,eAAe;AAAA,MACvF;AAAA,IACF;AAAA,EACF;AACF;;;A7BnTA,SAAS,KAAAI,UAAS;;;A8BblB,SAAS,4BAA4B;AAE9B,IAAM,wBAAN,MAA4B;AAAA,EACzB;AAAA,EAER,YAAY,QAAmB;AAC7B,SAAK,SAAS;AAAA,EAChB;AAAA,EAEA,MAAM,UAAyB;AAC7B,UAAM,YAAY,IAAI,qBAAqB;AAC3C,UAAM,KAAK,OAAO,QAAQ,SAAS;AAAA,EACrC;AACF;;;ACbA,SAAS,qCAAqC;AAC9C,OAAOC,WAAU;AAUjB,IAAM,mBAAmB;AAAA,EACvB,2BAA2B;AAAA,EAC3B,mBAAmB;AAAA,EACnB,0BAA0B;AAAA,EAC1B,mBAAmB;AAAA,EACnB,oBAAoB;AACtB;AAQO,SAAS,kBAAkB,QAAyB;AACzD,MAAI;AACF,UAAM,MAAM,IAAI,IAAI,MAAM;AAC1B,UAAM,WAAW,IAAI;AAErB,WAAO,aAAa,eAAe,aAAa;AAAA,EAClD,QAAQ;AAEN,WAAO;AAAA,EACT;AACF;AAOO,IAAM,uBAAN,MAA2B;AAAA,EACxB;AAAA,EACA;AAAA,EACA;AAAA,EAER,YACE,QACA,SAA8B,CAAC,GAC/B,cACA;AACA,SAAK,SAAS;AACd,SAAK,SAAS;AACd,SAAK,eAAe;AAAA,EACtB;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,MAAc,mBAAmBC,YAAmB,MAAc,MAAmE;AACnI,UAAM,EAAE,cAAAC,cAAa,IAAI,MAAM,OAAO,qBAAqB;AAC3D,UAAM,EAAE,iBAAAC,iBAAgB,IAAI,MAAM;AAClC,UAAM,EAAE,WAAW,cAAc,IAAI,MAAMA,iBAAgB;AAC3D,WAAO,IAAID;AAAA,MACT;AAAA,MACA;AAAA,MACA,UAAU,IAAI,IAAI,IAAI,2BAA2BD,UAAS;AAAA,IAC5D;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKQ,iBAAiB,QAA4D;AACnF,WAAO,OAAO,gBAAgB;AAAA,MAC5B,aAAa;AAAA,MACb,OAAO,CAAC,0CAA0C;AAAA,MAClD,QAAQ;AAAA,IACV,CAAC;AAAA,EACH;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,MAAc,kBAAkBA,YAAkC;AAChE,UAAM,EAAE,mBAAAG,mBAAkB,IAAI,MAAM;AACpC,IAAAA,mBAAkBH,UAAS;AAAA,EAC7B;AAAA,EAEQ,iBAAiB,KAAyC;AAChE,WAAO,IAAI,QAAQ,CAACI,UAAS,WAAW;AACtC,UAAI,OAAO;AACX,UAAI,GAAG,QAAQ,WAAS,QAAQ,MAAM,SAAS,CAAC;AAChD,UAAI,GAAG,OAAO,MAAM;AAClB,YAAI;AACF,UAAAA,SAAQ,OAAO,KAAK,MAAM,IAAI,IAAI,CAAC,CAAC;AAAA,QACtC,SAAS,OAAO;AACd,iBAAO,IAAI,MAAM,8BAA8B,CAAC;AAAA,QAClD;AAAA,MACF,CAAC;AACD,UAAI,GAAG,SAAS,MAAM;AAAA,IACxB,CAAC;AAAA,EACH;AAAA,EAEA,MAAM,UAAyB;AAC7B,UAAM,OAAO,KAAK,OAAO,QAAQ;AACjC,UAAM,OAAO,KAAK,OAAO,QAAQ;AAGjC,UAAM,YAAY,IAAI,8BAA8B;AAAA,MAClD,oBAAoB;AAAA;AAAA,IACtB,CAAC;AAED,UAAM,KAAK,OAAO,QAAQ,SAAS;AAGnC,UAAM,aAAaC,MAAK,aAAa,OAAO,KAAK,QAAQ;AAEvD,YAAM,SAAS,IAAI,QAAQ;AAI3B,UAAI,UAAU,CAAC,kBAAkB,MAAM,GAAG;AACxC,YAAI,UAAU,KAAK,EAAE,gBAAgB,mBAAmB,CAAC;AACzD,YAAI,IAAI,KAAK,UAAU;AAAA,UACrB,OAAO;AAAA,UACP,SAAS;AAAA,QACX,CAAC,CAAC;AACF;AAAA,MACF;AAGA,YAAM,gBAAgB,SAAS,IAAI,QAAQ,gBAAgB,KAAK,KAAK,EAAE;AACvE,YAAM,iBAAiB,KAAK,OAAO;AACnC,UAAI,gBAAgB,gBAAgB;AAClC,YAAI,UAAU,KAAK,EAAE,gBAAgB,mBAAmB,CAAC;AACzD,YAAI,IAAI,KAAK,UAAU;AAAA,UACrB,OAAO;AAAA,UACP,SAAS;AAAA,QACX,CAAC,CAAC;AACF;AAAA,MACF;AAIA,YAAM,oBAAoB,UAAU,kBAAkB,MAAM,IACxD,SACA,UAAU,IAAI,IAAI,IAAI;AAC1B,UAAI,UAAU,+BAA+B,iBAAiB;AAC9D,UAAI,UAAU,gCAAgC,4BAA4B;AAC1E,UAAI,UAAU,gCAAgC,8BAA8B;AAE5E,UAAI,IAAI,WAAW,WAAW;AAC5B,YAAI,UAAU,GAAG;AACjB,YAAI,IAAI;AACR;AAAA,MACF;AAGA,UAAI,IAAI,WAAW,UAAU,IAAI,WAAW,OAAO;AACjD,cAAM,eAAe,IAAI,QAAQ;AACjC,YAAI,gBAAgB,CAAC,aAAa,SAAS,kBAAkB,KAAK,CAAC,aAAa,SAAS,mBAAmB,KAAK,CAAC,aAAa,SAAS,KAAK,GAAG;AAC9I,cAAI,UAAU,KAAK,EAAE,gBAAgB,mBAAmB,CAAC;AACzD,cAAI,IAAI,KAAK,UAAU;AAAA,YACrB,OAAO;AAAA,YACP,SAAS;AAAA,UACX,CAAC,CAAC;AACF;AAAA,QACF;AAAA,MACF;AAGA,UAAI,IAAI,WAAW,UAAU,IAAI,QAAQ,OAAO,IAAI,QAAQ,cAAc;AACxE,YAAI;AACF,gBAAM,OAAO,MAAM,YAAY,eAAe;AAC9C,cAAI,UAAU,KAAK;AAAA,YACjB,gBAAgB;AAAA,YAChB,GAAG;AAAA,UACL,CAAC;AACD,cAAI,IAAI,IAAI;AAAA,QACd,SAAS,OAAO;AACd,cAAI,UAAU,KAAK,EAAE,gBAAgB,mBAAmB,CAAC;AACzD,cAAI,IAAI,KAAK,UAAU;AAAA,YACrB,OAAO;AAAA,YACP,SAAS,iBAAiB,QAAQ,MAAM,UAAU,OAAO,KAAK;AAAA,UAChE,CAAC,CAAC;AAAA,QACJ;AACA;AAAA,MACF;AAGA,UAAI,IAAI,WAAW,SAAS,IAAI,QAAQ,eAAe;AACrD,YAAI;AACF,gBAAM,MAAM,MAAM,YAAY,YAAY;AAC1C,cAAI,UAAU,KAAK;AAAA,YACjB,gBAAgB;AAAA,YAChB,GAAG;AAAA,UACL,CAAC;AACD,cAAI,IAAI,GAAG;AAAA,QACb,SAAS,OAAO;AACd,cAAI,UAAU,KAAK,EAAE,gBAAgB,aAAa,CAAC;AACnD,cAAI,IAAI,oBAAoB;AAAA,QAC9B;AACA;AAAA,MACF;AAKA,UAAI,IAAI,WAAW,SAAS,IAAI,QAAQ,iBAAiB;AACvD,YAAI;AACF,gBAAM,WAAW,MAAM,KAAK,aAAa,aAAa;AACtD,cAAI,UAAU,KAAK,EAAE,gBAAgB,mBAAmB,CAAC;AACzD,cAAI,IAAI,KAAK,UAAU,EAAE,SAAS,CAAC,CAAC;AAAA,QACtC,SAAS,OAAO;AACd,cAAI,UAAU,KAAK,EAAE,gBAAgB,mBAAmB,CAAC;AACzD,cAAI,IAAI,KAAK,UAAU;AAAA,YACrB,OAAO;AAAA,YACP,SAAS,iBAAiB,QAAQ,MAAM,UAAU,OAAO,KAAK;AAAA,UAChE,CAAC,CAAC;AAAA,QACJ;AACA;AAAA,MACF;AAGA,UAAI,IAAI,WAAW,UAAU,IAAI,QAAQ,iBAAiB;AACxD,YAAI;AACF,gBAAM,OAAO,MAAM,KAAK,iBAAiB,GAAG;AAC5C,gBAAML,aAAY,KAAK;AAEvB,cAAI,CAACA,cAAa,OAAOA,eAAc,UAAU;AAC/C,gBAAI,UAAU,KAAK,EAAE,gBAAgB,mBAAmB,CAAC;AACzD,gBAAI,IAAI,KAAK,UAAU;AAAA,cACrB,OAAO;AAAA,cACP,SAAS;AAAA,YACX,CAAC,CAAC;AACF;AAAA,UACF;AAGA,cAAI;AACF,kBAAM,KAAK,kBAAkBA,UAAS;AAAA,UACxC,SAAS,OAAO;AACd,gBAAI,UAAU,KAAK,EAAE,gBAAgB,mBAAmB,CAAC;AACzD,gBAAI,IAAI,KAAK,UAAU;AAAA,cACrB,OAAO;AAAA,cACP,SAAS,iBAAiB,QAAQ,MAAM,UAAU,OAAO,KAAK;AAAA,YAChE,CAAC,CAAC;AACF;AAAA,UACF;AAGA,gBAAM,eAAe,MAAM,KAAK,mBAAmBA,YAAW,MAAM,IAAI;AACxE,gBAAM,UAAU,KAAK,iBAAiB,YAAY;AAElD,cAAI,UAAU,KAAK,EAAE,gBAAgB,mBAAmB,CAAC;AACzD,cAAI,IAAI,KAAK,UAAU;AAAA,YACrB;AAAA,YACA,WAAAA;AAAA,UACF,CAAC,CAAC;AAAA,QACJ,SAAS,OAAO;AACd,cAAI,UAAU,KAAK,EAAE,gBAAgB,mBAAmB,CAAC;AACzD,cAAI,IAAI,KAAK,UAAU;AAAA,YACrB,OAAO;AAAA,YACP,SAAS,iBAAiB,QAAQ,MAAM,UAAU,OAAO,KAAK;AAAA,UAChE,CAAC,CAAC;AAAA,QACJ;AACA;AAAA,MACF;AAGA,UAAI,IAAI,WAAW,SAAS,IAAI,KAAK,WAAW,iBAAiB,GAAG;AAClE,YAAI;AAEF,gBAAM,MAAM,IAAI,IAAI,IAAI,KAAK,UAAU,IAAI,IAAI,IAAI,EAAE;AACrD,gBAAM,OAAO,IAAI,aAAa,IAAI,MAAM;AACxC,gBAAMA,aAAY,IAAI,aAAa,IAAI,SAAS;AAEhD,cAAI,CAAC,MAAM;AACT,gBAAI,UAAU,KAAK,EAAE,gBAAgB,YAAY,CAAC;AAClD,gBAAI,IAAI,iDAAiD;AACzD;AAAA,UACF;AAEA,cAAI,CAACA,YAAW;AACd,gBAAI,UAAU,KAAK,EAAE,gBAAgB,YAAY,CAAC;AAClD,gBAAI,IAAI,yCAAyC;AACjD;AAAA,UACF;AAGA,gBAAM,eAAe,MAAM,KAAK,mBAAmBA,YAAW,MAAM,IAAI;AACxE,gBAAM,EAAE,OAAO,IAAI,MAAM,aAAa,SAAS,IAAI;AAGnD,uBAAa,eAAe,MAAM;AAClC,cAAI,QAAQ;AACZ,cAAI;AACF,kBAAM,YAAY,MAAM,aAAa,aAAa,OAAO,gBAAgB,EAAE;AAC3E,oBAAQ,UAAU,SAAS;AAAA,UAC7B,QAAQ;AAAA,UAER;AAGA,gBAAM,eAAe,KAAK,aAAa,eAAe;AACtD,cAAI;AACF,iBAAK,aAAa,eAAeA,UAAS;AAC1C,kBAAM,KAAK,aAAa,WAAW,QAAQ,UAAU,YAAY,QAAQ,MAAS;AAAA,UACpF,UAAE;AACA,iBAAK,aAAa,eAAe,YAAY;AAAA,UAC/C;AAGA,2BAAiB,YAAY,EAAE,WAAW;AAG1C,gBAAM,oBAAoB,UAAU,IAAI,IAAI,IAAI;AAEhD,gBAAM,cAAc,MAAM,kBAAkB;AAAA,YAC1C,WAAAA;AAAA,YACA,OAAO,UAAU,YAAY,QAAQ;AAAA,YACrC,iBAAiB;AAAA,YACjB;AAAA,UACF,CAAC;AACD,cAAI,UAAU,KAAK;AAAA,YACjB,gBAAgB;AAAA,YAChB,GAAG;AAAA,UACL,CAAC;AACD,cAAI,IAAI,WAAW;AAAA,QACrB,SAAS,OAAO;AACd,gBAAM,YAAY,MAAM,gBAAgB;AAAA,YACtC,cAAc,iBAAiB,QAAQ,MAAM,UAAU,OAAO,KAAK;AAAA,YACnE,iBAAiB;AAAA,UACnB,CAAC;AACD,cAAI,UAAU,KAAK;AAAA,YACjB,gBAAgB;AAAA,YAChB,GAAG;AAAA,UACL,CAAC;AACD,cAAI,IAAI,SAAS;AAAA,QACnB;AACA;AAAA,MACF;AAGA,UAAI,IAAI,WAAW,YAAY,IAAI,KAAK,WAAW,gBAAgB,GAAG;AACpE,cAAMA,aAAY,IAAI,IAAI,UAAU,iBAAiB,MAAM;AAE3D,YAAI;AAEF,gBAAM,KAAK,kBAAkBA,UAAS;AAGtC,gBAAM,eAAe,KAAK,aAAa,eAAe;AACtD,cAAI;AACF,iBAAK,aAAa,eAAeA,UAAS;AAC1C,kBAAM,KAAK,aAAa,YAAY;AAAA,UACtC,UAAE;AACA,iBAAK,aAAa,eAAe,YAAY;AAAA,UAC/C;AAGA,2BAAiB,YAAY,EAAE,WAAW;AAE1C,cAAI,UAAU,KAAK,EAAE,gBAAgB,mBAAmB,CAAC;AACzD,cAAI,IAAI,KAAK,UAAU;AAAA,YACrB,SAAS;AAAA,YACT,WAAAA;AAAA,YACA,SAAS;AAAA,UACX,CAAC,CAAC;AAAA,QACJ,SAAS,OAAO;AACd,cAAI,UAAU,KAAK,EAAE,gBAAgB,mBAAmB,CAAC;AACzD,cAAI,IAAI,KAAK,UAAU;AAAA,YACrB,OAAO;AAAA,YACP,SAAS,iBAAiB,QAAQ,MAAM,UAAU,OAAO,KAAK;AAAA,UAChE,CAAC,CAAC;AAAA,QACJ;AACA;AAAA,MACF;AAGA,UAAI,IAAI,WAAW,UAAU,IAAI,KAAK,MAAM,kCAAkC,GAAG;AAC/E,cAAMA,aAAY,IAAI,IAAI,MAAM,GAAG,EAAE,CAAC;AAEtC,YAAI;AAEF,gBAAM,KAAK,kBAAkBA,UAAS;AAGtC,gBAAM,eAAe,MAAM,KAAK,mBAAmBA,YAAW,MAAM,IAAI;AACxE,gBAAM,UAAU,KAAK,iBAAiB,YAAY;AAElD,cAAI,UAAU,KAAK,EAAE,gBAAgB,mBAAmB,CAAC;AACzD,cAAI,IAAI,KAAK,UAAU;AAAA,YACrB;AAAA,YACA,WAAAA;AAAA,UACF,CAAC,CAAC;AAAA,QACJ,SAAS,OAAO;AACd,cAAI,UAAU,KAAK,EAAE,gBAAgB,mBAAmB,CAAC;AACzD,cAAI,IAAI,KAAK,UAAU;AAAA,YACrB,OAAO;AAAA,YACP,SAAS,iBAAiB,QAAQ,MAAM,UAAU,OAAO,KAAK;AAAA,UAChE,CAAC,CAAC;AAAA,QACJ;AACA;AAAA,MACF;AAGA,UAAI,IAAI,WAAW,SAAS,IAAI,QAAQ,WAAW;AACjD,YAAI,UAAU,KAAK,EAAE,gBAAgB,mBAAmB,CAAC;AACzD,YAAI,IAAI,KAAK,UAAU;AAAA,UACrB,QAAQ;AAAA,UACR,QAAQ;AAAA,UACR,YAAW,oBAAI,KAAK,GAAE,YAAY;AAAA,QACpC,CAAC,CAAC;AACF;AAAA,MACF;AAEA,UAAI;AACF,cAAM,UAAU,cAAc,KAAK,GAAG;AAAA,MACxC,SAAS,OAAO;AACd,gBAAQ,OAAO,MAAM,2BAA2B,iBAAiB,QAAQ,MAAM,UAAU,KAAK;AAAA,CAAI;AAClG,YAAI,CAAC,IAAI,aAAa;AACpB,cAAI,UAAU,KAAK,EAAE,gBAAgB,mBAAmB,CAAC;AACzD,cAAI,IAAI,KAAK,UAAU;AAAA,YACrB,SAAS;AAAA,YACT,OAAO;AAAA,cACL,MAAM;AAAA,cACN,SAAS;AAAA,YACX;AAAA,YACA,IAAI;AAAA,UACN,CAAC,CAAC;AAAA,QACJ;AAAA,MACF;AAAA,IACF,CAAC;AAED,eAAW,OAAO,MAAM,MAAM,MAAM;AAClC,cAAQ,OAAO,MAAM,kDAAkD,IAAI,IAAI,IAAI;AAAA,CAAI;AAAA,IACzF,CAAC;AAAA,EACH;AACF;;;A/BraO,IAAM,0BAAN,MAA8B;AAAA,EAC3B;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EAER,YAAY,QAAsB;AAChC,SAAK,SAAS;AACd,SAAK,SAAS,IAAI,UAAU;AAAA,MAC1B,MAAM;AAAA,MACN,SAAS;AAAA,IACX,CAAC;AAAA,EACH;AAAA,EAEA,MAAM,aAA4B;AAEhC,SAAK,eAAe,MAAM,uBAAuB;AACjD,SAAK,eAAe,IAAI,aAAa,KAAK,YAAY;AACtD,SAAK,aAAa,IAAI,WAAW,KAAK,YAAY;AAGlD,SAAK,WAAW,MAAM,KAAK,aAAa,gBAAgB;AAGxD,UAAM,KAAK,4BAA4B;AAGvC,SAAK,cAAc;AAGnB,SAAK,sBAAsB;AAAA,EAC7B;AAAA,EAEA,MAAc,8BAA6C;AAEzD,QAAI,QAAQ,IAAI,aAAa,QAAQ;AACnC;AAAA,IACF;AAEA,SAAK,WAAW,MAAM,KAAK,aAAa,gBAAgB;AACxD,QAAI,KAAK,SAAS,OAAO,GAAG;AAC1B,YAAM,cAAc,MAAM,KAAK,KAAK,SAAS,KAAK,CAAC,EAAE,KAAK,IAAI;AAC9D,cAAQ,OAAO,MAAM,sCAAsC,WAAW;AAAA,CAAI;AAC1E;AAAA,IACF;AAEA,UAAM,cAAc,KAAK,aAAa,eAAe;AAErD,QAAI,KAAK,OAAO,UAAU,SAAS,SAAS;AAE1C,YAAM,iBAAiB,MAAM,KAAK,aAAa,eAAe,WAAW;AACzE,UAAI,CAAC,gBAAgB;AAGnB,gBAAQ,OAAO,MAAM;AAAA,CAAwC;AAC7D,gBAAQ,OAAO,MAAM;AAAA,CAAwE;AAC7F,gBAAQ,OAAO,MAAM;AAAA;AAAA,CAA2C;AAAA,MAElE,OAAO;AACL,gBAAQ,OAAO,MAAM,SAAS,WAAW;AAAA,CAAuB;AAChE,aAAK,WAAW,MAAM,KAAK,aAAa,gBAAgB;AAAA,MAC1D;AAAA,IACF,OAAO;AAEL,YAAM,iBAAiB,MAAM,KAAK,aAAa,eAAe,WAAW;AACzE,UAAI,CAAC,gBAAgB;AACnB,gBAAQ,OAAO,MAAM,0BAAgB,WAAW;AAAA,CAAsC;AACtF,gBAAQ,OAAO,MAAM,2FAA2F;AAAA,MAClH,OAAO;AACL,gBAAQ,OAAO,MAAM,SAAS,WAAW;AAAA,CAAuB;AAChE,aAAK,WAAW,MAAM,KAAK,aAAa,gBAAgB;AAAA,MAC1D;AAAA,IACF;AAAA,EACF;AAAA,EAEQ,gBAAsB;AAC5B,iBAAa,YAAY,KAAK,QAAQ,KAAK,mBAAmB,KAAK,IAAI,GAAG,KAAK,MAAM;AAGrF,SAAK,+BAA+B;AAAA,EACtC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQQ,iCAAuC;AAC7C,UAAM,gBAA+B;AAAA,MACnC,cAAc,KAAK;AAAA,MACnB,cAAc,KAAK;AAAA,MACnB,YAAY,KAAK;AAAA,MACjB,UAAU,KAAK;AAAA,MACf,gBAAgB,YAAY;AAC1B,aAAK,WAAW,MAAM,KAAK,aAAa,gBAAgB;AACxD,eAAO,KAAK;AAAA,MACd;AAAA,IACF;AAEA,UAAM,wBAAwB,IAAI,sBAAsB;AACxD,SAAK,OAAO;AAAA,MACV;AAAA,MACA;AAAA,MACA;AAAA,QACE,QAAQM,GAAE,KAAK,CAAC,QAAQ,OAAO,QAAQ,CAAC,EACrC,SAAS,8GAA8G;AAAA,QAC1H,YAAYA,GAAE,OAAO,EAClB,MAAM,sBAAsB,gGAAgG,EAC5H,SAAS,EACT,SAAS,4KAA4K;AAAA,MAC1L;AAAA,MACA,OAAO,SAAS;AACd,eAAO,sBAAsB,QAAQ,MAAM,aAAa;AAAA,MAC1D;AAAA,IACF;AAAA,EACF;AAAA,EAEA,MAAc,sBAAqC;AACjD,UAAM,oBAAoB,MAAM,KAAK,aAAa,gBAAgB;AAClE,QAAI,kBAAkB,OAAO,GAAG;AAC9B,WAAK,WAAW;AAChB;AAAA,IACF;AAGA,QAAI,MAAM,KAAK,aAAa,eAAe,GAAG;AAC5C,YAAM,oBAAoB,MAAM,KAAK,aAAa,gBAAgB;AAClE,UAAI,kBAAkB,OAAO,GAAG;AAC9B,aAAK,WAAW;AAChB;AAAA,MACF;AAAA,IACF;AAGA,QAAI,KAAK,OAAO,UAAU,SAAS,SAAS;AAC1C,YAAM,IAAIC;AAAA,QACRC,WAAU;AAAA,QACV;AAAA,MACF;AAAA,IACF;AAGA,QAAI;AACF,YAAM,cAAc,MAAM,KAAK,WAAW,MAAM,KAAK;AAErD,UAAI,CAAC,aAAa;AAChB,cAAM,IAAID;AAAA,UACRC,WAAU;AAAA,UACV;AAAA,QACF;AAAA,MACF;AAAA,IACF,SAAS,OAAO;AACd,UAAI,iBAAiBD,WAAU;AAC7B,cAAM;AAAA,MACR;AACA,UAAI,iBAAiB,OAAO;AAC1B,cAAM,IAAIA,UAASC,WAAU,gBAAgB,MAAM,OAAO;AAAA,MAC5D;AACA,YAAM,IAAID,UAASC,WAAU,gBAAgB,qEAAqE;AAAA,IACpH;AAAA,EACF;AAAA,EAEA,MAAc,mBAAmB,SAAc,MAAwE;AACrH,UAAM,KAAK,oBAAoB;AAE/B,UAAM,SAAS,MAAM,QAAQ,QAAQ,MAAM,KAAK,QAAQ;AACxD,WAAO;AAAA,EACT;AAAA,EAEA,MAAM,QAAuB;AAC3B,YAAQ,KAAK,OAAO,UAAU,MAAM;AAAA,MAClC,KAAK;AACH,cAAM,eAAe,IAAI,sBAAsB,KAAK,MAAM;AAC1D,cAAM,aAAa,QAAQ;AAC3B;AAAA,MAEF,KAAK;AACH,cAAM,aAAkC;AAAA,UACtC,MAAM,KAAK,OAAO,UAAU;AAAA,UAC5B,MAAM,KAAK,OAAO,UAAU;AAAA,QAC9B;AACA,cAAM,cAAc,IAAI;AAAA,UACtB,KAAK;AAAA,UACL;AAAA,UACA,KAAK;AAAA,QACP;AACA,cAAM,YAAY,QAAQ;AAC1B;AAAA,MAEF;AACE,cAAM,IAAI,MAAM,+BAA+B,KAAK,OAAO,UAAU,IAAI,EAAE;AAAA,IAC/E;AAAA,EACF;AAAA,EAEQ,wBAA8B;AACpC,UAAM,UAAU,YAAY;AAC1B,UAAI;AACF,YAAI,KAAK,YAAY;AACnB,gBAAM,KAAK,WAAW,KAAK;AAAA,QAC7B;AAGA,aAAK,OAAO,MAAM;AAElB,gBAAQ,KAAK,CAAC;AAAA,MAChB,SAAS,OAAgB;AACvB,gBAAQ,OAAO,MAAM,yBAAyB,iBAAiB,QAAQ,MAAM,UAAU,KAAK;AAAA,CAAI;AAChG,gBAAQ,KAAK,CAAC;AAAA,MAChB;AAAA,IACF;AAEA,YAAQ,GAAG,UAAU,OAAO;AAC5B,YAAQ,GAAG,WAAW,OAAO;AAAA,EAC/B;AAAA;AAAA,EAGA,YAAuB;AACrB,WAAO,KAAK;AAAA,EACd;AACF;;;AgCzOA,SAAS,kBAAkB,OAA2B,QAAsC;AAC1F,MAAI,UAAU,QAAW;AACvB,WAAO;AAAA,EACT;AAEA,QAAM,SAAS,MAAM,MAAM,GAAG,EAAE,IAAI,OAAK,EAAE,KAAK,CAAC,EAAE,OAAO,OAAK,EAAE,SAAS,CAAC;AAC3E,MAAI,OAAO,WAAW,GAAG;AACvB,YAAQ,OAAO,MAAM,UAAU,MAAM;AAAA,CAAoC;AACzE,YAAQ,KAAK,CAAC;AAAA,EAChB;AAEA,SAAO;AACT;AAEO,SAAS,UAAU,MAA8B;AAEtD,QAAM,SAAuB;AAAA,IAC3B,WAAW;AAAA,MACT,MAAO,QAAQ,IAAI,aAAkC;AAAA,MACrD,MAAM,QAAQ,IAAI,OAAO,SAAS,QAAQ,IAAI,MAAM,EAAE,IAAI;AAAA,MAC1D,MAAM,QAAQ,IAAI,QAAQ;AAAA,IAC5B;AAAA,IACA,OAAO,QAAQ,IAAI,UAAU,UAAU;AAAA,IACvC,cAAc,kBAAkB,QAAQ,IAAI,eAAe,eAAe;AAAA,EAC5E;AAEA,WAAS,IAAI,GAAG,IAAI,KAAK,QAAQ,KAAK;AACpC,UAAM,MAAM,KAAK,CAAC;AAElB,YAAQ,KAAK;AAAA,MACX,KAAK;AACH,cAAM,YAAY,KAAK,EAAE,CAAC;AAC1B,YAAI,cAAc,WAAW,cAAc,QAAQ;AACjD,iBAAO,UAAU,OAAO;AAAA,QAC1B;AACA;AAAA,MACF,KAAK;AACH,eAAO,UAAU,OAAO,SAAS,KAAK,EAAE,CAAC,GAAG,EAAE;AAC9C;AAAA,MACF,KAAK;AACH,eAAO,UAAU,OAAO,KAAK,EAAE,CAAC;AAChC;AAAA,MACF,KAAK;AACH,eAAO,QAAQ;AACf;AAAA,MACF,KAAK;AACH,cAAM,eAAe,KAAK,EAAE,CAAC;AAC7B,YAAI,CAAC,cAAc;AACjB,kBAAQ,OAAO,MAAM,uEAAuE;AAC5F,kBAAQ,KAAK,CAAC;AAAA,QAChB;AACA,eAAO,eAAe,kBAAkB,cAAc,gBAAgB;AACtE;AAAA,MACF,KAAK;AACH,gBAAQ,OAAO,MAAM;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,SAyBpB;AACD,gBAAQ,KAAK,CAAC;AAAA,IAClB;AAAA,EACF;AAEA,SAAO;AACT;;;AjC1FA;AAJA,SAAS,gBAAAC,qBAAoB;AAC7B,SAAS,QAAAC,OAAM,WAAAC,gBAAe;AAO9B,IAAMC,cAAaC,eAAc,YAAY,GAAG;AAChD,IAAMC,aAAYC,SAAQH,WAAU;AACpC,IAAM,kBAAkBI,MAAKF,YAAW,MAAM,cAAc;AAC5D,IAAM,cAAc,KAAK,MAAMG,cAAa,iBAAiB,OAAO,CAAC;AACrE,IAAM,UAAU,YAAY;AAG5B,eAAe,OAAO;AACpB,MAAI;AAEF,UAAM,SAAS,UAAU,QAAQ,KAAK,MAAM,CAAC,CAAC;AAG9C,UAAM,SAAS,IAAI,wBAAwB,MAAM;AACjD,UAAM,OAAO,WAAW;AAGxB,UAAM,OAAO,MAAM;AAAA,EAErB,SAAS,OAAgB;AACvB,YAAQ,OAAO,MAAM,2BAA2B,iBAAiB,QAAQ,MAAM,UAAU,KAAK;AAAA,CAAI;AAClG,YAAQ,KAAK,CAAC;AAAA,EAChB;AACF;AAIA,eAAe,cAAcC,YAAmC;AAE9D,MAAIA,YAAW;AAEb,QAAI,CAAC,qBAAqB,KAAKA,UAAS,GAAG;AACzC,cAAQ,OAAO,MAAM,sGAAsG;AAC3H,cAAQ,KAAK,CAAC;AAAA,IAChB;AACA,YAAQ,IAAI,sBAAsBA;AAClC,YAAQ,OAAO,MAAM,2BAA2BA,UAAS;AAAA,CAAI;AAAA,EAC/D;AAGA,MAAI;AAEF,UAAM,eAAe,MAAM,uBAAuB;AAGlD,UAAM,qBAAqB,IAAI,WAAW,YAAY;AAGtD,UAAM,UAAU,MAAM,mBAAmB,MAAM,IAAI;AAEnD,QAAI,CAAC,WAAW,CAAC,mBAAmB,2BAA2B;AAE7D,cAAQ,OAAO;AAAA,QACb;AAAA,MACF;AACA,cAAQ,KAAK,CAAC;AAAA,IAChB,WAAW,mBAAmB,2BAA2B;AAEvD,cAAQ,OAAO,MAAM,8BAA8B;AACnD,cAAQ,KAAK,CAAC;AAAA,IAChB;AAGA,YAAQ,OAAO;AAAA,MACb;AAAA,IACF;AAGA,UAAM,aAAa,YAAY,YAAY;AACzC,UAAI,mBAAmB,2BAA2B;AAChD,sBAAc,UAAU;AACxB,cAAM,mBAAmB,KAAK;AAC9B,gBAAQ,OAAO,MAAM,0CAA0C;AAC/D,gBAAQ,KAAK,CAAC;AAAA,MAChB;AAAA,IACF,GAAG,GAAI;AAAA,EACT,SAAS,OAAO;AACd,YAAQ,OAAO,MAAM,0BAA0B,KAAK;AAAA,CAAI;AACxD,YAAQ,KAAK,CAAC;AAAA,EAChB;AACF;AAEA,SAAS,WAAiB;AACxB,UAAQ,OAAO,MAAM;AAAA,8BACO,OAAO;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,CA0BpC;AACD;AAEA,SAAS,cAAoB;AAC3B,UAAQ,OAAO,MAAM,+BAA+B,OAAO;AAAA,CAAI;AACjE;AAOA,SAAS,eAA+E;AACtF,QAAM,OAAO,QAAQ,KAAK,MAAM,CAAC;AACjC,MAAIC;AACJ,MAAIC;AAEJ,WAAS,IAAI,GAAG,IAAI,KAAK,QAAQ,KAAK;AACpC,UAAM,MAAM,KAAK,CAAC;AAGlB,QAAI,QAAQ,eAAe,QAAQ,QAAQ,QAAQ,YAAY,QAAQ,MAAM;AAC3E,MAAAD,WAAU;AACV;AAAA,IACF;AAGA,QAAI,QAAQ,iBAAiB,QAAQ,YAAY,QAAQ,YAAY,QAAQ,kBAAkB;AAC7F;AACA;AAAA,IACF;AAGA,QAAI,QAAQ,WAAW;AACrB;AAAA,IACF;AAGA,QAAI,CAACA,YAAW,CAAC,IAAI,WAAW,IAAI,GAAG;AACrC,MAAAA,WAAU;AACV;AAAA,IACF;AAGA,QAAIA,aAAY,UAAU,CAACC,cAAa,CAAC,IAAI,WAAW,IAAI,GAAG;AAC7D,MAAAA,aAAY;AACZ;AAAA,IACF;AAAA,EACF;AAEA,SAAO,EAAE,SAAAD,UAAS,WAAAC,WAAU;AAC9B;AAGA,IAAM,EAAE,SAAS,UAAU,IAAI,aAAa;AAE5C,QAAQ,SAAS;AAAA,EACf,KAAK;AACH,kBAAc,SAAS,EAAE,MAAM,CAAC,UAAU;AACxC,cAAQ,OAAO,MAAM,0BAA0B,KAAK;AAAA,CAAI;AACxD,cAAQ,KAAK,CAAC;AAAA,IAChB,CAAC;AACD;AAAA,EACF,KAAK;AAAA,EACL,KAAK;AACH,SAAK,EAAE,MAAM,CAAC,UAAU;AACtB,cAAQ,OAAO,MAAM,2BAA2B,KAAK;AAAA,CAAI;AACzD,cAAQ,KAAK,CAAC;AAAA,IAChB,CAAC;AACD;AAAA,EACF,KAAK;AAAA,EACL,KAAK;AAAA,EACL,KAAK;AACH,gBAAY;AACZ;AAAA,EACF,KAAK;AAAA,EACL,KAAK;AAAA,EACL,KAAK;AACH,aAAS;AACT;AAAA,EACF;AACE,YAAQ,OAAO,MAAM,oBAAoB,OAAO;AAAA,CAAI;AACpD,aAAS;AACT,YAAQ,KAAK,CAAC;AAClB;",
  "names": ["accountId", "path", "__dirname", "getAccountMode", "getSecureTokenPath", "getLegacyTokenPath", "fs", "fileURLToPath", "McpError", "ErrorCode", "OAuth2Client", "OAuth2Client", "fs", "dirname", "getSecureTokenPath", "getAccountMode", "accountId", "getLegacyTokenPath", "validateAccountId", "google", "URL", "fs", "path", "fileURLToPath", "OAuth2Client", "URL", "getAccountMode", "resolve", "accountId", "GaxiosError", "google", "accountId", "accounts", "preferredAccess", "accountId", "client", "availableAccounts", "GaxiosError", "errorMessage", "errorDetails", "fullMessage", "google", "accountId", "accountId", "response", "resolve", "warnings", "accountId", "accountId", "google", "google", "McpError", "ErrorCode", "McpError", "ErrorCode", "accountId", "McpError", "ErrorCode", "McpError", "ErrorCode", "McpError", "ErrorCode", "google", "accountId", "response", "z", "http", "accountId", "OAuth2Client", "loadCredentials", "validateAccountId", "resolve", "http", "z", "McpError", "ErrorCode", "readFileSync", "join", "dirname", "__filename", "fileURLToPath", "__dirname", "dirname", "join", "readFileSync", "accountId", "command", "accountId"]
}
